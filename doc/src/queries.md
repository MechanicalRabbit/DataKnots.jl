# Query Algebra


## Overview

This section describes the `Query` interface of vectorized data
transformations.  We will need the following definitions:

    using DataKnots:
        @VectorTree,
        as_block,
        block_filler,
        block_lift,
        chain_of,
        column,
        decode_missing,
        decode_tuple,
        decode_vector,
        filler,
        flat_block,
        in_block,
        in_tuple,
        lift,
        null_filler,
        pass,
        pull_block,
        pull_every_block,
        record_lift,
        tuple_lift,
        tuple_of


### Lifting and fillers

`DataKnots` stores structured data in a column-oriented format, serialized
using specialized composite vector types.  Consequently, operations on data
must also be adapted to the column-oriented format.

In `DataKnots`, operations on column-oriented data are called *queries*.  A
query is a vectorized transformation: it takes a vector of input values and
produces a vector of the same size containing output values.

Any unary scalar function could be vectorized, which gives us a simple method
for creating new queries.  Consider, for example, function `titlecase()`, which
transforms the input string by capitalizing the first letter of each word and
converting every other character to lowercase.

    titlecase("JEFFERY A")      #-> "Jeffery A"

This function can be converted to a query, or *lifted*, using the `lift`
operator.

    q = lift(titlecase)
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> ["Jeffery A", "James A", "Terry A"]

A scalar function with `N` arguments could be lifted by `tuple_lift` to make a
query that transforms a `TupleVector` with `N` columns.  For example, the
comparison operator `>`, which maps a pair of integers to a Boolean value,
gives rise to a query `tuple_lift(>)` that transforms the input `TupleVector`
with two integer columns to a Boolean vector.

    q = tuple_lift(>)
    q(@VectorTree (Int, Int) [260004 200000; 185364 200000; 170112 200000])
    #-> Bool[true, false, false]

In a similar manner, a function with a vector argument can be lifted by
`block_lift` to make a query that expects a `BlockVector` input.  For example,
function `length()`, which returns the length of a vector, could be converted
to a query `block_lift(length)` that transforms a block vector to an integer
vector containing block lengths.

    q = block_lift(length)
    q(@VectorTree [String] [["JEFFERY A", "NANCY A"], ["JAMES A"]])
    #-> [2, 1]

Not just functions, but also regular values could give rise to queries.  The
`filler` operator make a query from any scalar value.  This query maps any
input vector to a vector filled with the given scalar.

    q = filler(200000)
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> [200000, 200000, 200000]

Similarly, `block_filler` makes a query from any vector value.  This query
produces a `BlockVector` filled with the given vector.

    q = block_filler(["POLICE", "FIRE"])
    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [String] [["POLICE", "FIRE"], ["POLICE", "FIRE"], ["POLICE", "FIRE"]]

A variant of `block_filler` called `null_filler` makes a query that produces a
`BlockVector` filled with empty blocks.

    q = null_filler()
    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [Union{}, OPT] [missing, missing, missing]


### Query interface

Functions such as `lift()`, `tuple_lift()`, and many others return a `Query`
object.  The `Query` interface represents a vectorized data transformation that
maps an input vector to an output vector of the same length.

Functions that take one or more `Query` instances as arguments and return a new
`Query` object as the result are called *combinators*.  Combinators are used to
assemble elementary queries into complex query expressions.

For example, *composition* combinator `chain_of()` assembles a series of
queries into a sequential composition, which transforms the input vector by
sequentially applying the given queries.

    q = chain_of(lift(split), lift(first), lift(titlecase))
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> ["Jeffery", "James", "Terry"]

Another combinator, *tuple constructor* `tuple_of()` assembles a series of
queries into a parallel composition.  It outputs a `TupleVector` instance,
which columns are generated by applying the given queries to the input vector.

    q = tuple_of(lift(titlecase), lift(last))
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> @VectorTree (String, Char) [("Jeffery A", 'A'), ("James A", 'A'), ("Terry A", 'A')]

An individual column of a `TupleVector` instance could be extracted using a
`column()` query.

    q = column(:salary)
    q(@VectorTree (name=String, salary=Int) [("JEFFERY A", 101442), ("JAMES A", 103350), ("TERRY A", 93354)])
    #-> [101442, 103350, 93354]



## API Reference

```@autodocs
Modules = [DataKnots]
Pages = ["queries.jl"]
```


## Test Suite


### Fillers and lifting

Many useful queries could be generated by lifting scalar functions and values.
For example, `filler(val)` is a query that maps any input vector to the output
vector filled with `val`.

    q = filler(200000)
    #-> filler(200000)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> [200000, 200000, 200000]

Similarly, `block_filler(blk)` maps any input vector to a block vector filled
with the given block.

    q = block_filler(["POLICE", "FIRE"])
    #-> block_filler(["POLICE", "FIRE"], OPT | PLU)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [String] [["POLICE", "FIRE"], ["POLICE", "FIRE"], ["POLICE", "FIRE"]]

A variant of `block_filler()` called `null_filler()` produces a block vector
with empty blocks.

    q = null_filler()
    #-> null_filler()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [Union{}, OPT] [missing, missing, missing]

Any unary function `f` could be converted to a query `lift(f)` that transforms
the input vector by applying `f` to its elements.

    q = lift(titlecase)
    #-> lift(titlecase)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> ["Garry M", "Anthony R", "Dana A"]

Similarly, any scalar function `f` of several arguments could be lifted into
tuple vectors with `tuple_lift(f)`.

    q = tuple_lift(>)
    #-> tuple_lift(>)

    q(@VectorTree (Int, Int) [260004 200000; 185364 200000; 170112 200000])
    #-> Bool[true, false, false]

A query `record_lift(f)` is a shortcut for `chain_of(pull_every_block(),
tuple_lift(f))`.  `record_lift(f)` expects a tuple vector whose columns are
block vectors.  It produces a block vector, where each block is composed by
applying `f` to every combination of values from all the blocks on the same
row.

    q = record_lift(>)

    q(@VectorTree ([Int], [Int]) [[260004, 185364, 170112] 200000; missing 200000; [202728, 197736] [200000, 200000]])
    #-> @VectorTree [Bool] [[true, false, false], [], [true, true, false, false]]

`record_lift

Any function that takes a vector argument can be lifted into block vectors.

    q = block_lift(length)
    #-> block_lift(length)

    q(@VectorTree [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]])
    #-> [3, 2]

Some vector functions may expect a non-empty vector as an argument.  In this
case, we should provide the value to replace empty blocks.

    q = block_lift(maximum, missing)
    #-> block_lift(maximum, missing)

    q(@VectorTree [Int] [[260004, 185364, 170112], [], [202728, 197736]])
    #-> Union{Missing, Int}[260004, missing, 202728]


## Decoding vectors

Any vector of tuples can be converted to a tuple vector.

    q = decode_tuple()
    #-> decode_tuple()

    q([("GARRY M", 260004), ("ANTHONY R", 185364), ("DANA A", 170112)]) |> display
    #=>
    TupleVector of 3 × (String, Int):
     ("GARRY M", 260004)
     ("ANTHONY R", 185364)
     ("DANA A", 170112)
    =#

Vectors of named tuples are also supported.

    q([(name="GARRY M", salary=260004), (name="ANTHONY R", salary=185364), (name="DANA A", salary=170112)]) |> display
    #=>
    TupleVector of 3 × (name = String, salary = Int):
     (name = "GARRY M", salary = 260004)
     (name = "ANTHONY R", salary = 185364)
     (name = "DANA A", salary = 170112)
    =#

A vector of vector objects can be converted to a block vector.

    q = decode_vector()
    #-> decode_vector()

    q([[260004, 185364, 170112], Int[], [202728, 197736]])
    #-> @VectorTree [Int] [[260004, 185364, 170112], [], [202728, 197736]]

Similarly, a vector containing `missing` values can be converted to a block
vector with zero- and one-element blocks.

    q = decode_missing()
    #-> decode_missing()

    q([260004, 185364, 170112, missing, 202728, 197736])
    #-> @VectorTree [Int, OPT] [260004, 185364, 170112, missing, 202728, 197736]


## Tuple vectors

To create a tuple vector, we use the combinator `tuple_of()`. Its arguments are
the functions that generate the columns of the tuple.

    q = tuple_of(:title => lift(titlecase), :last => lift(last))
    #-> tuple_of([:title, :last], [lift(titlecase), lift(last)])

    q(["GARRY M", "ANTHONY R", "DANA A"]) |> display
    #=>
    TupleVector of 3 × (title = String, last = Char):
     (title = "Garry M", last = 'M')
     (title = "Anthony R", last = 'R')
     (title = "Dana A", last = 'A')
    =#

To extract a column of a tuple vector, we use the primitive `column()`.  It
accepts either the column position or the column name.

    q = column(1)
    #-> column(1)

    q(@VectorTree (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112])
    #-> ["GARRY M", "ANTHONY R", "DANA A"]

    q = column(:salary)
    #-> column(:salary)

    q(@VectorTree (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112])
    #-> [260004, 185364, 170112]

Finally, we can apply an arbitrary transformation to a selected column of a
tuple vector.

    q = in_tuple(:name, lift(titlecase))
    #-> in_tuple(:name, lift(titlecase))

    q(@VectorTree (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112]) |> display
    #=>
    TupleVector of 3 × (name = String, salary = Int):
     (name = "Garry M", salary = 260004)
     (name = "Anthony R", salary = 185364)
     (name = "Dana A", salary = 170112)
    =#


## Block vectors

Primitive `as_block()` wraps the elements of the input vector to one-element blocks.

    q = as_block()
    #-> as_block()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [String, REG] ["GARRY M", "ANTHONY R", "DANA A"]

In the opposite direction, primitive `flat_block()` flattens a block vector
with block elements.

    q = flat_block()
    #-> flat_block()

    q(@VectorTree [[String]] [[["GARRY M"], ["ANTHONY R", "DANA A"]], [missing, ["JOSE S"], ["CHARLES S"]]])
    #-> @VectorTree [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]]

Finally, we can apply an arbitrary transformation to every element of a block vector.

    q = in_block(lift(titlecase))
    #-> in_block(lift(titlecase))

    q(@VectorTree [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]])
    #-> @VectorTree [String] [["Garry M", "Anthony R", "Dana A"], ["Jose S", "Charles S"]]

The `pull_block()` primitive converts a tuple vector with a block column to a
block vector of tuples.

    q = pull_block(1)
    #-> pull_block(1)

    q(@VectorTree ([Int], [Int]) [
        [260004, 185364, 170112]    200000
        missing                     200000
        [202728, 197736]            [200000, 200000]]
    ) |> display
    #=>
    BlockVector of 3 × [(Int, [Int])]:
     [(260004, [200000]), (185364, [200000]), (170112, [200000])]
     []
     [(202728, [200000, 200000]), (197736, [200000, 200000])]
    =#

It is also possible to pull all block columns from a tuple vector.

    q = pull_every_block()
    #-> pull_every_block()

    q(@VectorTree ([Int], [Int]) [
        [260004, 185364, 170112]    200000
        missing                     200000
        [202728, 197736]            [200000, 200000]]
    ) |> display
    #=>
    BlockVector of 3 × [(Int, Int)]:
     [(260004, 200000), (185364, 200000), (170112, 200000)]
     []
     [(202728, 200000), (202728, 200000), (197736, 200000), (197736, 200000)]
    =#


## Composition

We can compose a sequence of transformations using the `chain_of()` combinator.

    q = chain_of(
            column(:employee),
            in_block(lift(titlecase)))
    #-> chain_of(column(:employee), in_block(lift(titlecase)))

    q(@VectorTree (department = String, employee = [String]) [
        "POLICE"    ["GARRY M", "ANTHONY R", "DANA A"]
        "FIRE"      ["JOSE S", "CHARLES S"]])
    #-> @VectorTree [String] [["Garry M", "Anthony R", "Dana A"], ["Jose S", "Charles S"]]

The empty chain `chain_of()` has an alias `pass()`.

    q = pass()
    #-> pass()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> ["GARRY M", "ANTHONY R", "DANA A"]

