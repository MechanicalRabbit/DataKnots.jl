# Query Execution Engine


## Overview

In `DataKnots`, structured data is stored in a column-oriented format,
serialized using specialized composite vector types.  Consequently, operations
on data take the form of vectorized functions.

Module `DataKnots.Queries` exports an interface of vectorized transformations
called `Query` and provives a rich library of query primitives and combinators.

    using DataKnots.Vectors
    using DataKnots.Queries


### Lifting

*Lifting* lets us convert a scalar function to a query.

Any unary scalar function could be lifted to a vectorized form.  Consider, for
example, function `titlecase()`, which transforms the input string by
capitalizing the first letter of each word and converting every other character
to lowercase.

    titlecase("JEFFERY A")      #-> "Jeffery A"

This function can be converted to a query using the `lift` operator.

    q = lift(titlecase)
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> ["Jeffery A", "James A", "Terry A"]

If a scalar function takes several arguments, it could be lifted to a query on
`TupleVector` instances.  For example, the comparison operator `>`, which maps
a pair of integer values to a Boolean value, could be lifted to a query
`lift_to_tuple(>)` that transforms a `TupleVector` instance with two integer
columns to a Boolean vector.

    q = lift_to_tuple(>)
    q(@VectorTree (Int, Int) [260004 200000; 185364 200000; 170112 200000])
    #-> Bool[true, false, false]

In a similar manner, a function with a vector argument can be converted to a
query on `BlockVector` instances.  For example, function `length()`, which
returns the length of a vector, could be lifted to a query
`lift_to_block(length)` that transforms a block vector to an integer vector
containing block lengths.

    q = lift_to_block(length)
    q(@VectorTree [String] [["JEFFERY A", "NANCY A"], ["JAMES A"]])
    #-> [2, 1]

A constant value could be lifted to a query as well.  The lifted constant maps
any input vector to a vector of constant values.

    q = lift_const(200000)
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> [200000, 200000, 200000]


### Query interface

Functions such as `lift()`, `lift_to_tuple()`, and many others return a `Query`
object.  The `Query` interface represents a vectorized data transformation that
maps an input vector to an output vector of the same length.

Functions that take one or more `Query` instances as arguments and return a new
`Query` object as the result are called *combinators*.  Combinators are used to
assemble elementary queries into complex query expressions.

For example, *composition* combinator `chain_of()` assembles a series of
queries into a sequential composition, which transforms the input vector by
sequentially applying the given queries.

    q = chain_of(lift(split), lift(first), lift(titlecase))
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> ["Jeffery", "James", "Terry"]

Another combinator, *tuple constructor* `tuple_of()` assembles a series of
queries into a parallel composition.  It outputs a `TupleVector` instance,
which columns are generated by applying the given queries to the input vector.

    q = tuple_of(lift(titlecase), lift(last))
    q(["JEFFERY A", "JAMES A", "TERRY A"])
    #-> @VectorTree (String, Char) [("Jeffery A", 'A'), ("James A", 'A'), ("Terry A", 'A')]

An individual column of a `TupleVector` instance could be extracted using a
`column()` query.

    q = column(:salary)
    q(@VectorTree (name=String, salary=Int) [("JEFFERY A", 101442), ("JAMES A", 103350), ("TERRY A", 93354)])
    #-> [101442, 103350, 93354]



## API Reference

```@autodocs
Modules = [DataKnots.Queries]
Private = false
```


## Test Suite


## Lifting

Many vector operations can be generated by lifting.  For example,
`lift_const()` generates a primitive operation that maps any input vector to
the output vector of the same length filled with the given value.

    q = lift_const(200000)
    #-> lift_const(200000)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> [200000, 200000, 200000]

Similarly, the output of `lift_block()` is a block vector filled with the given
block.

    q = lift_block(["POLICE", "FIRE"])
    #-> lift_block(["POLICE", "FIRE"])

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [String] [["POLICE", "FIRE"], ["POLICE", "FIRE"], ["POLICE", "FIRE"]]

A variant of `lift_block()` called `lift_null()` outputs a block vector with
empty blocks.

    q = lift_null()
    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [Union{}] [missing, missing, missing]

Any scalar function could be lifted to a vector operation by applying it to
each element of the input vector.

    q = lift(titlecase)
    #-> lift(titlecase)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> ["Garry M", "Anthony R", "Dana A"]

Similarly, any scalar function of several arguments could be lifted to an
operation on tuple vectors.

    q = lift_to_tuple(>)
    #-> lift_to_tuple(>)

    q(@VectorTree (Int, Int) [260004 200000; 185364 200000; 170112 200000])
    #-> Bool[true, false, false]

It is also possible to apply a scalar function of several arguments to a tuple
vector that has block vectors for its columns.  In this case, the function is
applied to every combination of values from all the blocks on the same row.

    q = lift_to_block_tuple(>)

    q(@VectorTree ([Int], [Int]) [[260004, 185364, 170112] 200000; missing 200000; [202728, 197736] [200000, 200000]])
    #-> @VectorTree [Bool] [Bool[true, false, false], missing, Bool[true, true, false, false]]

Any function that takes a vector argument can be lifted to an operation on
block vectors.

    q = lift_to_block(length)
    #-> lift_to_block(length)

    q(@VectorTree [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]])
    #-> [3, 2]

Some vector functions may expect a non-empty vector as an argument.  In this
case, we should provide the value to replace empty blocks.

    q = lift_to_block(maximum, missing)
    #-> lift_to_block(maximum, missing)

    q(@VectorTree [Int] [[260004, 185364, 170112], [], [202728, 197736]])
    #-> Union{Missing, Int}[260004, missing, 202728]


## Decoding vectors

Any vector of tuples can be converted to a tuple vector.

    q = decode_tuple()
    #-> decode_tuple()

    q([("GARRY M", 260004), ("ANTHONY R", 185364), ("DANA A", 170112)]) |> display
    #=>
    TupleVector of 3 × (String, Int):
     ("GARRY M", 260004)
     ("ANTHONY R", 185364)
     ("DANA A", 170112)
    =#

Vectors of named tuples are also supported.

    q([(name="GARRY M", salary=260004), (name="ANTHONY R", salary=185364), (name="DANA A", salary=170112)]) |> display
    #=>
    TupleVector of 3 × (name = String, salary = Int):
     (name = "GARRY M", salary = 260004)
     (name = "ANTHONY R", salary = 185364)
     (name = "DANA A", salary = 170112)
    =#

A vector of vector objects can be converted to a block vector.

    q = decode_vector()
    #-> decode_vector()

    q([[260004, 185364, 170112], Int[], [202728, 197736]])
    #-> @VectorTree [Int] [[260004, 185364, 170112], missing, [202728, 197736]]

Similarly, a vector containing `missing` values can be converted to a block
vector with zero- and one-element blocks.

    q = decode_missing()
    #-> decode_missing()

    q([260004, 185364, 170112, missing, 202728, 197736])
    #-> @VectorTree [Int] [260004, 185364, 170112, missing, 202728, 197736]


## Tuple vectors

To create a tuple vector, we use the combinator `tuple_of()`. Its arguments are
the functions that generate the columns of the tuple.

    q = tuple_of(:title => lift(titlecase), :last => lift(last))
    #-> tuple_of([:title, :last], [lift(titlecase), lift(last)])

    q(["GARRY M", "ANTHONY R", "DANA A"]) |> display
    #=>
    TupleVector of 3 × (title = String, last = Char):
     (title = "Garry M", last = 'M')
     (title = "Anthony R", last = 'R')
     (title = "Dana A", last = 'A')
    =#

To extract a column of a tuple vector, we use the primitive `column()`.  It
accepts either the column position or the column name.

    q = column(1)
    #-> column(1)

    q(@VectorTree (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112])
    #-> ["GARRY M", "ANTHONY R", "DANA A"]

    q = column(:salary)
    #-> column(:salary)

    q(@VectorTree (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112])
    #-> [260004, 185364, 170112]

Finally, we can apply an arbitrary transformation to a selected column of a
tuple vector.

    q = in_tuple(:name, lift(titlecase))
    #-> in_tuple(:name, lift(titlecase))

    q(@VectorTree (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112]) |> display
    #=>
    TupleVector of 3 × (name = String, salary = Int):
     (name = "Garry M", salary = 260004)
     (name = "Anthony R", salary = 185364)
     (name = "Dana A", salary = 170112)
    =#


## Block vectors

Primitive `as_block()` wraps the elements of the input vector to one-element blocks.

    q = as_block()
    #-> as_block()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @VectorTree [String] ["GARRY M", "ANTHONY R", "DANA A"]

In the opposite direction, primitive `flat_block()` flattens a block vector
with block elements.

    q = flat_block()
    #-> flat_block()

    q(@VectorTree [[String]] [[["GARRY M"], ["ANTHONY R", "DANA A"]], [missing, ["JOSE S"], ["CHARLES S"]]])
    #-> @VectorTree [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]]

Finally, we can apply an arbitrary transformation to every element of a block vector.

    q = in_block(lift(titlecase))
    #-> in_block(lift(titlecase))

    q(@VectorTree [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]])
    #-> @VectorTree [String] [["Garry M", "Anthony R", "Dana A"], ["Jose S", "Charles S"]]

The `pull_block()` primitive converts a tuple vector with a block column to a
block vector of tuples.

    q = pull_block(1)
    #-> pull_block(1)

    q(@VectorTree ([Int], [Int]) [
        [260004, 185364, 170112]    200000
        missing                     200000
        [202728, 197736]            [200000, 200000]]
    ) |> display
    #=>
    BlockVector of 3 × [(Int, [Int])]:
     [(260004, 200000), (185364, 200000), (170112, 200000)]
     missing
     [(202728, [200000, 200000]), (197736, [200000, 200000])]
    =#

It is also possible to pull all block columns from a tuple vector.

    q = pull_every_block()
    #-> pull_every_block()

    q(@VectorTree ([Int], [Int]) [
        [260004, 185364, 170112]    200000
        missing                     200000
        [202728, 197736]            [200000, 200000]]
    ) |> display
    #=>
    BlockVector of 3 × [(Int, Int)]:
     [(260004, 200000), (185364, 200000), (170112, 200000)]
     missing
     [(202728, 200000), (202728, 200000), (197736, 200000), (197736, 200000)]
    =#


## Index vectors

An index vector could be dereferenced using the `dereference()` primitive.

    q = dereference()
    #-> dereference()

    q(@VectorTree &DEPT [1, 1, 1, 2] where {DEPT = ["POLICE", "FIRE"]})
    #-> ["POLICE", "POLICE", "POLICE", "FIRE"]


## Composition

We can compose a sequence of transformations using the `chain_of()` combinator.

    q = chain_of(
            column(:employee),
            in_block(lift(titlecase)))
    #-> chain_of(column(:employee), in_block(lift(titlecase)))

    q(@VectorTree (department = String, employee = [String]) [
        "POLICE"    ["GARRY M", "ANTHONY R", "DANA A"]
        "FIRE"      ["JOSE S", "CHARLES S"]])
    #-> @VectorTree [String] [["Garry M", "Anthony R", "Dana A"], ["Jose S", "Charles S"]]

The empty chain `chain_of()` has an alias `pass()`.

    q = pass()
    #-> pass()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> ["GARRY M", "ANTHONY R", "DANA A"]

