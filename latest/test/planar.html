<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Planar Vectors · QueryCombinators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>QueryCombinators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">QueryCombinators.jl Documentation</a></li><li><a class="toctext" href="../reference.html">API Reference</a></li><li><a class="toctext" href="index.html">Test Suite</a></li><li class="current"><a class="toctext" href="planar.html">Planar Vectors</a><ul class="internal"><li><a class="toctext" href="#TupleVector-1"><code>TupleVector</code></a></li><li><a class="toctext" href="#BlockVector-1"><code>BlockVector</code></a></li><li><a class="toctext" href="#IndexVector-1"><code>IndexVector</code></a></li><li><a class="toctext" href="#@Planar-1"><code>@Planar</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="planar.html">Planar Vectors</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/QueryCombinators.jl/blob/master/test/planar.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Planar Vectors</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Planar-Vectors-1" href="#Planar-Vectors-1">Planar Vectors</a></h1><p>For efficient data processing, the data can be stored in a planar (also known as columnar or SoA) form.</p><pre><code class="language-julia">using QueryCombinators.Planar</code></pre><h2><a class="nav-anchor" id="TupleVector-1" href="#TupleVector-1"><code>TupleVector</code></a></h2><p><code>TupleVector</code> is a vector of tuples stored as a tuple of vectors.</p><pre><code class="language-julia">tv = TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;],
                 :salary =&gt; [260004, 185364, 170112])
#-&gt; @Planar (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

display(tv)
#=&gt;
TupleVector of 3 × (name = String, salary = Int):
 (name = &quot;GARRY M&quot;, salary = 260004)
 (name = &quot;ANTHONY R&quot;, salary = 185364)
 (name = &quot;DANA A&quot;, salary = 170112)
=#</code></pre><p>It is possible to construct a <code>TupleVector</code> without labels.</p><pre><code class="language-julia">TupleVector(length(tv), columns(tv))
#-&gt; @Planar (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p>An error is reported in case of duplicate labels or columns of different height.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :name =&gt; [&quot;DANA A&quot;, &quot;JUAN R&quot;])
#-&gt; ERROR: duplicate column label :name

TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :salary =&gt; [260004, 185364, 170112])
#-&gt; ERROR: unexpected column height</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">labels(tv)
#-&gt; Symbol[:name, :salary]

width(tv)
#-&gt; 2

column(tv, 2)
#-&gt; [260004, 185364, 170112]

column(tv, :salary)
#-&gt; [260004, 185364, 170112]

columns(tv)
#-&gt; …[[&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;], [260004, 185364, 170112]]</code></pre><p>When indexed by another vector, we get a new instance of <code>TupleVector</code>.</p><pre><code class="language-julia">tv′ = tv[[3,1]]
display(tv′)
#=&gt;
TupleVector of 2 × (name = String, salary = Int):
 (name = &quot;DANA A&quot;, salary = 170112)
 (name = &quot;GARRY M&quot;, salary = 260004)
=#</code></pre><p>Note that the new instance keeps a reference to the index and the original column vectors.  Updated column vectors are generated on demand.</p><pre><code class="language-julia">column(tv′, 2)
#-&gt; [170112, 260004]</code></pre><h2><a class="nav-anchor" id="BlockVector-1" href="#BlockVector-1"><code>BlockVector</code></a></h2><p><code>BlockVector</code> is a vector of homogeneous vectors (blocks) stored as a vector of elements partitioned into individual blocks by a vector of offsets.</p><pre><code class="language-julia">bv = BlockVector([[&quot;HEALTH&quot;], [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], [], [&quot;POLICE&quot;, &quot;FIRE&quot;]])
#-&gt; @Planar [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]

display(bv)
#=&gt;
BlockVector of 4 × [String]:
 &quot;HEALTH&quot;
 [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;]
 missing
 [&quot;POLICE&quot;, &quot;FIRE&quot;]
=#</code></pre><p>We can omit brackets for singular blocks and use <code>missing</code> in place of empty blocks.</p><pre><code class="language-julia">BlockVector([&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]])
#-&gt; @Planar [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>It is possible to specify the offset and the element vectors separately.</p><pre><code class="language-julia">BlockVector([1, 2, 4, 4, 6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;])
#-&gt; @Planar [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>If each block contains exactly one element, we could use <code>:</code> in place of the offset vector.</p><pre><code class="language-julia">BlockVector(:, [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;])
#-&gt; @Planar [String] [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;]</code></pre><p>The <code>BlockVector</code> constructor verifies that the offset vector is well-formed.</p><pre><code class="language-julia">BlockVector(Base.OneTo(0), [])
#-&gt; ERROR: partition must be non-empty

BlockVector(Int[], [])
#-&gt; ERROR: partition must be non-empty

BlockVector([0], [])
#-&gt; ERROR: partition must start with 1

BlockVector([1,2,2,1], [&quot;HEALTH&quot;])
#-&gt; ERROR: partition must be monotone

BlockVector(Base.OneTo(4), [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements

BlockVector([1,2,3,6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">offsets(bv)
#-&gt; [1, 2, 4, 4, 6]

elements(bv)
#-&gt; [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;]

partition(bv)
#-&gt; ([1, 2, 4, 4, 6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;])</code></pre><p>When indexed by a vector of indexes, an instance of <code>BlockVector</code> is returned.</p><pre><code class="language-julia">elts = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

reg_bv = BlockVector(:, elts)
showcompact(reg_bv)
#-&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

opt_bv = BlockVector([1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7], elts)
showcompact(opt_bv)
#-&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]

plu_bv = BlockVector([1, 1, 1, 2, 2, 4, 4, 6, 7], elts)
showcompact(plu_bv)
#-&gt; [missing, missing, &quot;POLICE&quot;, missing, [&quot;FIRE&quot;, &quot;HEALTH&quot;], missing, [&quot;AVIATION&quot;, &quot;WATER MGMNT&quot;], &quot;FINANCE&quot;]

showcompact(reg_bv[[1,3,5,3]])
#-&gt; [&quot;POLICE&quot;, &quot;HEALTH&quot;, &quot;WATER MGMNT&quot;, &quot;HEALTH&quot;]

showcompact(plu_bv[[1,3,5,3]])
#-&gt; [missing, &quot;POLICE&quot;, [&quot;FIRE&quot;, &quot;HEALTH&quot;], &quot;POLICE&quot;]

showcompact(reg_bv[Base.OneTo(4)])
#-&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;]

showcompact(reg_bv[Base.OneTo(6)])
#-&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

showcompact(plu_bv[Base.OneTo(6)])
#-&gt; [missing, missing, &quot;POLICE&quot;, missing, [&quot;FIRE&quot;, &quot;HEALTH&quot;], missing]

showcompact(opt_bv[Base.OneTo(10)])
#-&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]</code></pre><h2><a class="nav-anchor" id="IndexVector-1" href="#IndexVector-1"><code>IndexVector</code></a></h2><p><code>IndexVector</code> is a vector of indexes in some named vector.</p><pre><code class="language-julia">iv = IndexVector(:REF, [1, 1, 1, 2])
#-&gt; @Planar &amp;REF [1, 1, 1, 2]

display(iv)
#=&gt;
IndexVector of 4 × &amp;REF:
 1
 1
 1
 2
=#</code></pre><p>We can obtain the components of the vector.</p><pre><code class="language-julia">identifier(iv)
#-&gt; :REF

indexes(iv)
#-&gt; [1, 1, 1, 2]</code></pre><p>Indexing an <code>IndexVector</code> by a vector produces another <code>IndexVector</code> instance.</p><pre><code class="language-julia">iv[[4,2]]
#-&gt; @Planar &amp;REF [2, 1]</code></pre><p><code>IndexVector</code> can be deferenced against a list of named vectors, which can be used to traverse self-referential data structures.</p><pre><code class="language-julia">refv = [&quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot;, &quot;ZONING ADMINISTRATOR&quot;, &quot;PROJECT MANAGER&quot;]

dereference(iv, [:REF =&gt; refv])
#-&gt; [&quot;COMISSIONER&quot;, &quot;COMISSIONER&quot;, &quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot;]</code></pre><p>Function <code>dereference()</code> has no effect on other types of vectors, or when the desired reference vector is not in the list.</p><pre><code class="language-julia">dereference(iv, [:REF′ =&gt; refv])
#-&gt; @Planar &amp;REF [1, 1, 1, 2]

dereference([1, 1, 1, 2], [:REF =&gt; refv])
#-&gt; [1, 1, 1, 2]</code></pre><h2><a class="nav-anchor" id="@Planar-1" href="#@Planar-1"><code>@Planar</code></a></h2><p>We can use <code>@Planar</code> macro to convert vector literals to a planar form.</p><p><code>TupleVector</code> is created from a matrix or a vector of (named) tuples.</p><pre><code class="language-julia">@Planar (name = String, salary = Int) [
    &quot;GARRY M&quot;   260004
    &quot;ANTHONY R&quot; 185364
    &quot;DANA A&quot;    170112
]
#-&gt; @Planar (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@Planar (name = String, salary = Int) [
    (&quot;GARRY M&quot;, 260004),
    (&quot;ANTHONY R&quot;, 185364),
    (&quot;DANA A&quot;, 170112),
]
#-&gt; @Planar (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@Planar (name = String, salary = Int) [
    (name = &quot;GARRY M&quot;, salary = 260004),
    (name = &quot;ANTHONY R&quot;, salary = 185364),
    (name = &quot;DANA A&quot;, salary = 170112),
]
#-&gt; @Planar (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]</code></pre><p>For <code>TupleVector</code>, column labels are optional.</p><pre><code class="language-julia">@Planar (String, Int) [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
#-&gt; @Planar (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p>Ill-formed <code>TupleVector</code> contructors are rejected.</p><pre><code class="language-julia">@Planar (String, Int) (&quot;GARRY M&quot;, 260004)
#=&gt;
ERROR: LoadError: expected a vector literal; got :((&quot;GARRY M&quot;, 260004))
in expression starting at none:2
=#

@Planar (String, Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected no label; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
in expression starting at none:2
=#

@Planar (name = String, salary = Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected label :name; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
in expression starting at none:2
=#

@Planar (name = String, salary = Int) [(&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004)]
#=&gt;
ERROR: LoadError: expected 2 column(s); got :((&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004))
in expression starting at none:2
=#

@Planar (name = String, salary = Int) [&quot;GARRY M&quot;]
#=&gt;
ERROR: LoadError: expected a tuple or a row literal; got &quot;GARRY M&quot;
in expression starting at none:2
=#</code></pre><p><code>BlockVector</code> and <code>IndexVector</code> can also be constructed.</p><pre><code class="language-julia">@Planar [String] [
    &quot;HEALTH&quot;,
    [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;],
    missing,
    [&quot;POLICE&quot;, &quot;FIRE&quot;],
]
#-&gt; @Planar [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]

@Planar &amp;REF [1, 1, 1, 2]
#-&gt; @Planar &amp;REF [1, 1, 1, 2]</code></pre><p>Using <code>@Planar</code>, we can easily construct hierarchical and self-referential data.</p><pre><code class="language-julia">ref_data = @Planar (position = [String], manager = [&amp;SELF]) [
    &quot;COMISSIONER&quot;           missing
    &quot;DEPUTY COMISSIONER&quot;    1
    &quot;ZONING ADMINISTRATOR&quot;  1
    &quot;PROJECT MANAGER&quot;       2
]
display(ref_data)
#=&gt;
TupleVector of 4 × (position = [String], manager = [&amp;SELF]):
 (position = &quot;COMISSIONER&quot;, manager = missing)
 (position = &quot;DEPUTY COMISSIONER&quot;, manager = 1)
 (position = &quot;ZONING ADMINISTRATOR&quot;, manager = 1)
 (position = &quot;PROJECT MANAGER&quot;, manager = 2)
=#

hier_data = @Planar (name = [String], employee = [(name = [String], salary = [Int])]) [
    &quot;POLICE&quot;    [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
    &quot;FIRE&quot;      [&quot;JOSE S&quot; 202728; &quot;CHARLES S&quot; 197736]
]
display(hier_data)
#=&gt;
TupleVector of 2 × (name = [String], employee = [(name = [String], salary = [Int])]):
 (name = &quot;POLICE&quot;, employee = [(name = &quot;GARRY M&quot;, salary = 260004) … ])
 (name = &quot;FIRE&quot;, employee = [(name = &quot;JOSE S&quot;, salary = 202728) … ])
=#</code></pre><footer><hr/><a class="previous" href="layouts.html"><span class="direction">Previous</span><span class="title">Optimal Layouts</span></a></footer></article></body></html>
