<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type System · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="install.html">Installation Instructions</a></li><li><a class="toctext" href="usage.html">Usage Guide</a></li><li><a class="toctext" href="implementation.html">Implementation Guide</a><ul><li class="current"><a class="toctext" href="shapes.html">Type System</a><ul class="internal"><li><a class="toctext" href="#Cardinality-1">Cardinality</a></li><li><a class="toctext" href="#Data-shapes-1">Data shapes</a></li><li><a class="toctext" href="#Shape-ordering-1">Shape ordering</a></li><li><a class="toctext" href="#Query-signature-1">Query signature</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="implementation.html">Implementation Guide</a></li><li><a href="shapes.html">Type System</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/shapes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Type System</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Type-System-1" href="#Type-System-1">Type System</a></h1><p>This module lets us describe the shape of the data.</p><pre><code class="language-julia">using DataKnots.Shapes</code></pre><h2><a class="nav-anchor" id="Cardinality-1" href="#Cardinality-1">Cardinality</a></h2><p>Enumerated type <code>Cardinality</code> is used to constrain the cardinality of a data block.  A block of data is called <em>regular</em> if it must contain exactly one element; <em>optional</em> if it may have no elements; and <em>plural</em> if it may have more than one element.  This gives us four different cardinality constraints.</p><pre><code class="language-julia">display(Cardinality)
#=&gt;
Enum Cardinality:
REG = 0
OPT = 1
PLU = 2
OPT|PLU = 3
=#</code></pre><p>Cardinality values support bitwise operations.</p><pre><code class="language-julia">REG|OPT|PLU             #-&gt; OPT|PLU
PLU&amp;~PLU                #-&gt; REG</code></pre><p>We can use predicates <code>isregular()</code>, <code>isoptional()</code>, <code>isplural()</code> to check cardinality values.</p><pre><code class="language-julia">isregular(REG)          #-&gt; true
isregular(OPT)          #-&gt; false
isregular(PLU)          #-&gt; false
isoptional(OPT)         #-&gt; true
isoptional(PLU)         #-&gt; false
isplural(PLU)           #-&gt; true
isplural(OPT)           #-&gt; false</code></pre><p><code>Cardinality</code> supports standard operations on enumerated types.</p><pre><code class="language-julia">typemin(Cardinality)    #-&gt; REG
typemax(Cardinality)    #-&gt; OPT|PLU
REG &lt; OPT|PLU           #-&gt; true

Cardinality(3)
#-&gt; OPT|PLU
read(IOBuffer(&quot;\x03&quot;), Cardinality)
#-&gt; OPT|PLU</code></pre><p>There is a partial ordering defined on <code>Cardinality</code> values.  We can determine the greatest and the least cardinality; the least upper bound and the greatest lower bound of a collection of <code>Cardinality</code> values; and, for two <code>Cardinality</code> values, determine whether one of the values is smaller than the other.</p><pre><code class="language-julia">bound(Cardinality)      #-&gt; REG
ibound(Cardinality)     #-&gt; OPT|PLU

bound(OPT, PLU)         #-&gt; OPT|PLU
ibound(PLU, OPT)        #-&gt; REG

fits(OPT, PLU)          #-&gt; false
fits(REG, OPT|PLU)      #-&gt; true</code></pre><h2><a class="nav-anchor" id="Data-shapes-1" href="#Data-shapes-1">Data shapes</a></h2><p>The structure of composite data is specified with <em>shape</em> objects.</p><p><code>NativeShape</code> specifies the type of a regular Julia value.</p><pre><code class="language-julia">str_shp = NativeShape(String)
#-&gt; NativeShape(String)

eltype(str_shp)
#-&gt; String</code></pre><p><code>ClassShape</code> refers to a shape with a name.</p><pre><code class="language-julia">cls_shp = ClassShape(:Emp)
#-&gt; ClassShape(:Emp)

class(cls_shp)
#-&gt; :Emp</code></pre><p>We can provide a definition for a class name using <code>rebind()</code> method.</p><pre><code class="language-julia">clos_shp = cls_shp |&gt; rebind(:Emp =&gt; str_shp)
#-&gt; ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(String))</code></pre><p>Now we can obtain the actual shape of the class.</p><pre><code class="language-julia">clos_shp[]
#-&gt; NativeShape(String)</code></pre><p>A shape which does not contain any nested undefined classes is called closed.</p><pre><code class="language-julia">isclosed(str_shp)
#-&gt; true

isclosed(cls_shp)
#-&gt; false

isclosed(clos_shp)
#-&gt; true</code></pre><p><code>TupleShape</code> lets us specify the field types of a tuple value.</p><pre><code class="language-julia">tpl_shp = TupleShape(NativeShape(String),
                     BlockShape(ClassShape(:Emp)))
#-&gt; TupleShape(NativeShape(String), BlockShape(ClassShape(:Emp)))

foreach(println, tpl_shp[:])
#=&gt;
NativeShape(String)
BlockShape(ClassShape(:Emp))
=#</code></pre><p>Two special shape types are used to indicate that the value may have any shape, or cannot exist.</p><pre><code class="language-julia">any_shp = AnyShape()
#-&gt; AnyShape()

none_shp = NoneShape()
#-&gt; NoneShape()</code></pre><p>To any shape, we can attach an arbitrary set of attributes, which are called <em>decorations</em>.  In particular, we can label the values.</p><pre><code class="language-julia">decor_shp = str_shp |&gt; decorate(:tag =&gt; :position)
#-&gt; NativeShape(String) |&gt; decorate(:tag =&gt; :position)</code></pre><p>The value of a decoration could be extracted.</p><pre><code class="language-julia">decoration(decor_shp, :tag)</code></pre><p>We can enforce the type and the default value of the decoration.</p><pre><code class="language-julia">decoration(decor_shp, :tag, Symbol, Symbol(&quot;&quot;))
#-&gt; :position
decoration(decor_shp, :tag, String, &quot;&quot;)
#-&gt; &quot;&quot;
decoration(str_shp, :tag, String, &quot;&quot;)
#-&gt; &quot;&quot;</code></pre><p><code>InputShape</code> and <code>OutputShape</code> are derived shapes that describe the structure of the query input and the query output.</p><p>To describe the query input, we specify the shape of the input elements, the shapes of the parameters, and whether or not the input is framed.</p><pre><code class="language-julia">i_shp = InputShape(ClassShape(:Emp),
                   [:D =&gt; OutputShape(NativeShape(String))],
                   true)
#-&gt; InputShape(ClassShape(:Emp), [:D =&gt; OutputShape(NativeShape(String))], true)

i_shp[]
#-&gt; ClassShape(:Emp)

domain(i_shp)
#-&gt; ClassShape(:Emp)

mode(i_shp)
#-&gt; InputMode([:D =&gt; OutputShape(NativeShape(String))], true)</code></pre><p>To describe the query output, we specify the shape and the cardinality of the output elements.</p><pre><code class="language-julia">o_shp = OutputShape(NativeShape(Int), OPT|PLU)
#-&gt; OutputShape(NativeShape(Int), OPT|PLU)

o_shp[]
#-&gt; NativeShape(Int)

cardinality(o_shp)
#-&gt; OPT|PLU

domain(o_shp)
#-&gt; NativeShape(Int)

mode(o_shp)
#-&gt; OutputMode(OPT|PLU)</code></pre><p>RecordShape` specifies the shape of a record value where each field has a certain shape and cardinality.</p><pre><code class="language-julia">dept_shp = RecordShape(OutputShape(String) |&gt; decorate(:tag =&gt; :name),
                       OutputShape(:Emp, OPT|PLU) |&gt; decorate(:tag =&gt; :employee))
#=&gt;
RecordShape(OutputShape(NativeShape(String) |&gt; decorate(:tag =&gt; :name)),
            OutputShape(ClassShape(:Emp) |&gt; decorate(:tag =&gt; :employee),
                        OPT|PLU))
=#

emp_shp = RecordShape(OutputShape(String) |&gt; decorate(:tag =&gt; :name),
                      OutputShape(:Dept) |&gt; decorate(:tag =&gt; :department),
                      OutputShape(String) |&gt; decorate(:tag =&gt; :position),
                      OutputShape(Int) |&gt; decorate(:tag =&gt; :salary),
                      OutputShape(:Emp, OPT) |&gt; decorate(:tag =&gt; :manager),
                      OutputShape(:Emp, OPT|PLU) |&gt; decorate(:tag =&gt; :subordinate))
#=&gt;
RecordShape(OutputShape(NativeShape(String) |&gt; decorate(:tag =&gt; :name)),
            OutputShape(ClassShape(:Dept) |&gt; decorate(:tag =&gt; :department)),
            OutputShape(NativeShape(String) |&gt; decorate(:tag =&gt; :position)),
            OutputShape(NativeShape(Int) |&gt; decorate(:tag =&gt; :salary)),
            OutputShape(ClassShape(:Emp) |&gt; decorate(:tag =&gt; :manager), OPT),
            OutputShape(ClassShape(:Emp) |&gt; decorate(:tag =&gt; :subordinate),
                        OPT|PLU))
=#</code></pre><p>Using the combination of different shapes we can describe the structure of any data source.</p><pre><code class="language-julia">db_shp = RecordShape(OutputShape(:Dept, OPT|PLU) |&gt; decorate(:tag =&gt; :department),
                     OutputShape(:Emp, OPT|PLU) |&gt; decorate(:tag =&gt; :employee))

db_shp |&gt; rebind(:Dept =&gt; dept_shp, :Emp =&gt; emp_shp)
#=&gt;
RecordShape(
    OutputShape(
        ClassShape(:Dept)
        |&gt; rebind(:Dept =&gt; RecordShape(
                               OutputShape(NativeShape(String)
                                           |&gt; decorate(:tag =&gt; :name)),
                               OutputShape(ClassShape(:Emp)
                                           |&gt; decorate(:tag =&gt; :employee),
                                           OPT|PLU))
                           |&gt; decorate(:tag =&gt; :department),
                  :Emp =&gt; RecordShape(
                              OutputShape(NativeShape(String)
                                          |&gt; decorate(:tag =&gt; :name)),
                              ⋮
                              OutputShape(ClassShape(:Emp)
                                          |&gt; decorate(:tag =&gt; :subordinate),
                                          OPT|PLU))),
        OPT|PLU),
    OutputShape(
        ClassShape(:Emp)
        |&gt; rebind(:Dept =&gt; RecordShape(
                               OutputShape(NativeShape(String)
                                           |&gt; decorate(:tag =&gt; :name)),
                               OutputShape(ClassShape(:Emp)
                                           |&gt; decorate(:tag =&gt; :employee),
                                           OPT|PLU)),
                  :Emp =&gt; RecordShape(
                              OutputShape(NativeShape(String)
                                          |&gt; decorate(:tag =&gt; :name)),
                              ⋮
                              OutputShape(ClassShape(:Emp)
                                          |&gt; decorate(:tag =&gt; :subordinate),
                                          OPT|PLU))
                          |&gt; decorate(:tag =&gt; :employee)),
        OPT|PLU))
=#</code></pre><h2><a class="nav-anchor" id="Shape-ordering-1" href="#Shape-ordering-1">Shape ordering</a></h2><p>The same data can satisfy many different shape constraints.  For example, a vector <code>BlockVector([Chicago])</code> can be said to have, among others, the shape <code>BlockShape(String)</code>, the shape <code>OutputShape(String, OPT|PLU)</code> or the shape <code>AnyShape()</code>.  We can tell, for any two shapes, if one of them is more specific than the other.</p><pre><code class="language-julia">fits(NativeShape(Int), NativeShape(Number))     #-&gt; true
fits(NativeShape(Int), NativeShape(String))     #-&gt; false

fits(ClassShape(:Emp), ClassShape(:Emp))        #-&gt; true
fits(ClassShape(:Emp), ClassShape(:Dept))       #-&gt; false

fits(ClassShape(:Emp),
     ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(String)))    #-&gt; false

fits(ClassShape(:Emp),
     ClassShape(:Dept)
     |&gt; rebind(:Emp =&gt; NativeShape(String)))    #-&gt; false

fits(ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(String)),
     ClassShape(:Emp))                          #-&gt; true

fits(ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(String)),
     ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(String)))    #-&gt; true

fits(ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(String)),
     ClassShape(:Dept)
     |&gt; rebind(:Dept =&gt; NativeShape(String)))   #-&gt; false

fits(ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(String)),
     ClassShape(:Emp)
     |&gt; rebind(:Emp =&gt; NativeShape(Number)))    #-&gt; false

fits(BlockShape(Int), BlockShape(Number))       #-&gt; true
fits(BlockShape(Int), BlockShape(String))       #-&gt; false

fits(TupleShape(Int, BlockShape(String)),
     TupleShape(Number, BlockShape(String)))    #-&gt; true
fits(TupleShape(Int, BlockShape(String)),
     TupleShape(String, BlockShape(String)))    #-&gt; false
fits(TupleShape(Int),
     TupleShape(Number, BlockShape(String)))    #-&gt; false

fits(InputShape(Int,
                [:X =&gt; OutputShape(Int),
                 :Y =&gt; OutputShape(String)],
                true),
     InputShape(Number,
                [:X =&gt; OutputShape(Int, OPT)])) #-&gt; true
fits(InputShape(Int),
     InputShape(Number, true))                  #-&gt; false
fits(InputShape(Int,
                [:X =&gt; OutputShape(Int, OPT)]),
     InputShape(Number,
                [:X =&gt; OutputShape(Int)]))      #-&gt; false

fits(OutputShape(Int),
     OutputShape(Number, OPT))                  #-&gt; true
fits(OutputShape(Int, PLU),
     OutputShape(Number, OPT))                  #-&gt; false
fits(OutputShape(Int),
     OutputShape(String, OPT))                  #-&gt; false

fits(RecordShape(OutputShape(Int),
                 OutputShape(String, OPT)),
     RecordShape(OutputShape(Number),
                 OutputShape(String, OPT|PLU)))     #-&gt; true
fits(RecordShape(OutputShape(Int, OPT),
                 OutputShape(String)),
     RecordShape(OutputShape(Number),
                 OutputShape(String, OPT|PLU)))     #-&gt; false
fits(RecordShape(OutputShape(Int)),
     RecordShape(OutputShape(Number),
                 OutputShape(String, OPT|PLU)))     #-&gt; false</code></pre><p>Shapes of different kinds are typically not compatible with each other.  The exceptions are <code>AnyShape</code> and <code>NullShape</code>.</p><pre><code class="language-julia">fits(NativeShape(Int), ClassShape(:Emp))    #-&gt; false
fits(NativeShape(Int), AnyShape())          #-&gt; true
fits(NoneShape(), ClassShape(:Emp))         #-&gt; true</code></pre><p>Shape decorations are treated as additional shape constraints.</p><pre><code class="language-julia">fits(NativeShape(String) |&gt; decorate(:tag =&gt; :name),
     NativeShape(String) |&gt; decorate(:tag =&gt; :name))        #-&gt; true
fits(NativeShape(String),
     NativeShape(String) |&gt; decorate(:tag =&gt; :name))        #-&gt; false
fits(NativeShape(String) |&gt; decorate(:tag =&gt; :position),
     NativeShape(String))                                   #-&gt; true
fits(NativeShape(String) |&gt; decorate(:tag =&gt; :position),
     NativeShape(String) |&gt; decorate(:tag =&gt; :name))        #-&gt; false</code></pre><p>For any given number of shapes, we can find their upper bound, the shape that is more general than each of them.  We can also find their lower bound.</p><pre><code class="language-julia">bound(NativeShape(Int), NativeShape(Number))
#-&gt; NativeShape(Number)
ibound(NativeShape(Int), NativeShape(Number))
#-&gt; NativeShape(Int)

bound(ClassShape(:Emp), ClassShape(:Emp))
#-&gt; ClassShape(:Emp)
ibound(ClassShape(:Emp), ClassShape(:Emp))
#-&gt; ClassShape(:Emp)
bound(ClassShape(:Emp), ClassShape(:Dept))
#-&gt; AnyShape()
ibound(ClassShape(:Emp), ClassShape(:Dept))
#-&gt; NoneShape()
bound(ClassShape(:Emp),
      ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(String)))
#-&gt; ClassShape(:Emp)
ibound(ClassShape(:Emp),
       ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(String)))
#-&gt; ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(String))
bound(ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(Number)),
      ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(String)))
#-&gt; ClassShape(:Emp) |&gt; rebind(:Emp =&gt; AnyShape())
ibound(ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(Number)),
       ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NativeShape(String)))
#-&gt; ClassShape(:Emp) |&gt; rebind(:Emp =&gt; NoneShape())

bound(BlockShape(Int), BlockShape(Number))
#-&gt; BlockShape(NativeShape(Number))
ibound(BlockShape(Int), BlockShape(Number))
#-&gt; BlockShape(NativeShape(Int))

bound(TupleShape(:Emp, BlockShape(String)),
      TupleShape(:Dept, BlockShape(String)))
#-&gt; TupleShape(AnyShape(), BlockShape(NativeShape(String)))
ibound(TupleShape(:Emp, BlockShape(String)),
       TupleShape(:Dept, BlockShape(String)))
#-&gt; TupleShape(NoneShape(), BlockShape(NativeShape(String)))

bound(InputShape(Int, [:X =&gt; OutputShape(Int, OPT), :Y =&gt; OutputShape(String)], true),
      InputShape(Number, [:X =&gt; OutputShape(Int)]))
#=&gt;
InputShape(NativeShape(Number), [:X =&gt; OutputShape(NativeShape(Int), OPT)])
=#
ibound(InputShape(Int, [:X =&gt; OutputShape(Int, OPT), :Y =&gt; OutputShape(String)], true),
       InputShape(Number, [:X =&gt; OutputShape(Int)]))
#=&gt;
InputShape(NativeShape(Int),
           [:X =&gt; OutputShape(NativeShape(Int)),
            :Y =&gt; OutputShape(NativeShape(String))],
           true)
=#

bound(OutputShape(String, OPT), OutputShape(String, PLU))
#-&gt; OutputShape(NativeShape(String), OPT|PLU)
ibound(OutputShape(String, OPT), OutputShape(String, PLU))
#-&gt; OutputShape(NativeShape(String))

bound(RecordShape(OutputShape(Int, PLU),
                  OutputShape(String, OPT)),
      RecordShape(OutputShape(Number),
                  OutputShape(:Emp, OPT|PLU)))
#=&gt;
RecordShape(OutputShape(NativeShape(Number), PLU),
            OutputShape(AnyShape(), OPT|PLU))
=#
ibound(RecordShape(OutputShape(Int, PLU),
                   OutputShape(String, OPT)),
       RecordShape(OutputShape(Number),
                   OutputShape(:Emp, OPT|PLU)))
#=&gt;
RecordShape(OutputShape(NativeShape(Int)), OutputShape(NoneShape(), OPT))
=#</code></pre><p>For decorated shapes, incompatible decoration constraints are replaced with <code>nothing</code>.</p><pre><code class="language-julia">bound(NativeShape(String) |&gt; decorate(:show =&gt; false, :tag =&gt; :name),
      NativeShape(String) |&gt; decorate(:hide =&gt; true, :tag =&gt; :name))
#-&gt; NativeShape(String) |&gt; decorate(:tag =&gt; :name)

ibound(NativeShape(String) |&gt; decorate(:show =&gt; false, :tag =&gt; :name),
       NativeShape(String) |&gt; decorate(:hide =&gt; true, :tag =&gt; :name))
#-&gt; NativeShape(String) |&gt; decorate(:hide =&gt; true, :show =&gt; false, :tag =&gt; :name)

bound(NativeShape(String) |&gt; decorate(:tag =&gt; :position),
      NativeShape(Number) |&gt; decorate(:tag =&gt; :salary))
#-&gt; AnyShape()

ibound(NativeShape(String) |&gt; decorate(:tag =&gt; :position),
       NativeShape(Number) |&gt; decorate(:tag =&gt; :salary))
#-&gt; NoneShape() |&gt; decorate(:tag =&gt; nothing)

bound(NativeShape(Int),
      NativeShape(Number) |&gt; decorate(:tag =&gt; :salary))
#-&gt; NativeShape(Number)

ibound(NativeShape(Int),
       NativeShape(Number) |&gt; decorate(:tag =&gt; :salary))
#-&gt; NativeShape(Int) |&gt; decorate(:tag =&gt; :salary)</code></pre><h2><a class="nav-anchor" id="Query-signature-1" href="#Query-signature-1">Query signature</a></h2><p>The signature of a query is a pair of an <code>InputShape</code> object and an <code>OutputShape</code> object.</p><pre><code class="language-julia">sig = Signature(InputShape(:Dept),
                OutputShape(RecordShape(OutputShape(String) |&gt; decorate(:tag =&gt; :name),
                                        OutputShape(:Emp, OPT|PLU) |&gt; decorate(:tag =&gt; :employee))))
#-&gt; Dept -&gt; (name =&gt; String[1 .. 1], employee =&gt; Emp[0 .. ∞])[1 .. 1]</code></pre><p>Different components of the signature can be easily extracted.</p><pre><code class="language-julia">shape(sig)
#=&gt;
OutputShape(RecordShape(
                OutputShape(NativeShape(String) |&gt; decorate(:tag =&gt; :name)),
                OutputShape(ClassShape(:Emp) |&gt; decorate(:tag =&gt; :employee),
                            OPT|PLU)))
=#

ishape(sig)
#-&gt; InputShape(ClassShape(:Dept))

domain(sig)
#=&gt;
RecordShape(OutputShape(NativeShape(String) |&gt; decorate(:tag =&gt; :name)),
            OutputShape(ClassShape(:Emp) |&gt; decorate(:tag =&gt; :employee),
                        OPT|PLU))
=#

mode(sig)
#-&gt; OutputMode()

idomain(sig)
#-&gt; ClassShape(:Dept)

imode(sig)
#-&gt; InputMode()</code></pre><footer><hr/><a class="previous" href="vectors.html"><span class="direction">Previous</span><span class="title">Column Store</span></a><a class="next" href="queries.html"><span class="direction">Next</span><span class="title">Query Backend</span></a></footer></article></body></html>
