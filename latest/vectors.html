<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Column Store · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="install.html">Installation Instructions</a></li><li><a class="toctext" href="usage.html">Usage Guide</a></li><li><a class="toctext" href="implementation.html">Implementation Guide</a><ul><li class="current"><a class="toctext" href="vectors.html">Column Store</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#API-Reference-1">API Reference</a></li><li><a class="toctext" href="#Test-Suite-1">Test Suite</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="implementation.html">Implementation Guide</a></li><li><a href="vectors.html">Column Store</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/vectors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Column Store</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Column-Store-1" href="#Column-Store-1">Column Store</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>Module <code>DataKnots.Vectors</code> implements an in-memory column store.</p><pre><code class="language-julia">using DataKnots.Vectors</code></pre><h3><a class="nav-anchor" id="Tabular-data-1" href="#Tabular-data-1">Tabular data</a></h3><p>Consider a tabular structure, like in the following example.</p><table><tr><th>name</th><th>position</th><th>salary</th></tr><tr><td>JEFFERY A</td><td>SERGEANT</td><td>101442</td></tr><tr><td>JAMES A</td><td>FIRE ENGINEER-EMT</td><td>103350</td></tr><tr><td>TERRY A</td><td>POLICE OFFICER</td><td>93354</td></tr></table><p>How can a database engine store the data in this table?</p><p>In general, there are two ways to assemble composite data structures.  We can make a fixed-size collection of heterogeneous values called a <em>tuple</em>.  We can also make a variable-size collection of homogeneous values called a <em>vector</em>.</p><p>A tuple can represent a row in the table above.</p><pre><code class="language-julia">(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442)</code></pre><p>A vector can be used to store a table column.</p><pre><code class="language-julia">[&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;]</code></pre><p>When it comes to the table as a whole, we have a choice: either store it as a vector of tuples, or, alternatively, as a tuple of vectors.  The former leads to a <em>row-oriented</em> format, commonly used in programming and traditional database engines.</p><pre><code class="language-julia">[(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442),
 (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350),
 (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354)]</code></pre><p>Data layout in which values are stored in a set of homogeneous vectors is called a <em>column-oriented</em> format.  It is often used by analytical databases as it is more suitable for processing complex analytical queries.</p><p>The module <code>DataKnots.Vectors</code> implements necessary data structures to support column-oriented data layout.  In particular, tabular data is represented using <code>TupleVector</code> objects.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;],
            :position =&gt; [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;],
            :salary =&gt; [101442, 103350, 93354])</code></pre><h3><a class="nav-anchor" id="Missing-cells-1" href="#Missing-cells-1">Missing cells</a></h3><p>When we discussed tabular format, we assumed that each table cell contains exactly one value.  But in some cases, to present data in tabular format, we need to leave some cells blank.</p><p>Continuing with the previous example, consider that an employee could be compensated either with salary or with hourly pay.  To display the compensation data, we use separate columns for annual salary and for hourly rate, but only one the columns per each row is filled.</p><table><tr><th>name</th><th>position</th><th>salary</th><th>rate</th></tr><tr><td>JEFFERY A</td><td>SERGEANT</td><td>101442</td><td></td></tr><tr><td>JAMES A</td><td>FIRE ENGINEER-EMT</td><td>103350</td><td></td></tr><tr><td>TERRY A</td><td>POLICE OFFICER</td><td>93354</td><td></td></tr><tr><td>LAKENYA A</td><td>CROSSING GUARD</td><td></td><td>17.68</td></tr></table><p>How could this data be represented in column-oriented form?  To retain the advantages of the format, we&#39;d like to keep the data in tightly packed <em>element</em> vectors.</p><pre><code class="language-julia">[&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;, &quot;LAKENYA A&quot;]
[&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;, &quot;CROSSING GUARD&quot;]
[101442, 103350, 93354]
[17.68]</code></pre><p>But since the vector indexes no longer correspond to row numbers, we don&#39;t know how to map vector elements to the table cells.  This mapping could be restored with an <em>offset</em> vector, a vector of indexes in the element vector specifying the boundaries of the respective cells.</p><pre><code class="language-julia">[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 4]
[1, 1, 1, 1, 2]</code></pre><p>A <code>BlockVector</code> object encapsulates a pair of the offset and the element vectors.  Here, the symbol <code>:</code> is used as a shortcut for a unit range vector.</p><pre><code class="language-julia">BlockVector(:, [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;, &quot;LAKENYA A&quot;])
BlockVector(:, [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;, &quot;CROSSING GUARD&quot;])
BlockVector([1, 2, 3, 4, 4], [101442, 103350, 93354])
BlockVector([1, 1, 1, 1, 2], [17.68])</code></pre><p>Now that the correspondence between rows and columns is restored, we could wrap the columns with a <code>TupleVector</code>.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; BlockVector(:, [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;, &quot;LAKENYA A&quot;]),
    :position =&gt; BlockVector(:, [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;, &quot;CROSSING GUARD&quot;]),
    :salary =&gt; BlockVector([1, 2, 3, 4, 4], [101442, 103350, 93354]),
    :rate =&gt; BlockVector([1, 1, 1, 1, 2], [17.68]))</code></pre><h3><a class="nav-anchor" id="Nested-data-1" href="#Nested-data-1">Nested data</a></h3><h3><a class="nav-anchor" id="Circular-data-1" href="#Circular-data-1">Circular data</a></h3><h2><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Vectors.TupleVector" href="#DataKnots.Vectors.TupleVector"><code>DataKnots.Vectors.TupleVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TupleVector([lbls::Vector{Symbol}], len::Int, cols::Vector{AbstractVector})
TupleVector(cols::Pair{Symbol,&lt;:AbstractVector}...)</code></pre><p>Vector of tuples stored as a collection of column vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/4f2dc6d776f9d8931387f439d321aabdb8ee80dc/src/vectors/tuple.jl#L13-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Vectors.BlockVector" href="#DataKnots.Vectors.BlockVector"><code>DataKnots.Vectors.BlockVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BlockVector(offs::AbstractVector{Int}, elts::AbstractVector)
BlockVector(blks::AbstractVector)</code></pre><p>Vector of vectors (blocks) stored as a vector of elements partitioned by a vector of offsets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/4f2dc6d776f9d8931387f439d321aabdb8ee80dc/src/vectors/block.jl#L13-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Vectors.IndexVector" href="#DataKnots.Vectors.IndexVector"><code>DataKnots.Vectors.IndexVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IndexVector(ident::Symbol, idxs::AbstractVector{Int})</code></pre><p>Vector of indexes in some named vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/4f2dc6d776f9d8931387f439d321aabdb8ee80dc/src/vectors/index.jl#L13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Vectors.CapsuleVector" href="#DataKnots.Vectors.CapsuleVector"><code>DataKnots.Vectors.CapsuleVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CapsuleVector(vals::AbstractVector, refs::Pair{Symbol,&lt;:AbstractVector}...)</code></pre><p>Encapsulates reference vectors to dereference any nested indexes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/4f2dc6d776f9d8931387f439d321aabdb8ee80dc/src/vectors/capsule.jl#L5-L9">source</a></section><h2><a class="nav-anchor" id="Test-Suite-1" href="#Test-Suite-1">Test Suite</a></h2><h3><a class="nav-anchor" id="TupleVector-1" href="#TupleVector-1"><code>TupleVector</code></a></h3><p><code>TupleVector</code> is a vector of tuples stored as a collection of parallel vectors.</p><pre><code class="language-julia">tv = TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;],
                 :salary =&gt; [260004, 185364, 170112])
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

display(tv)
#=&gt;
TupleVector of 3 × (name = String, salary = Int):
 (name = &quot;GARRY M&quot;, salary = 260004)
 (name = &quot;ANTHONY R&quot;, salary = 185364)
 (name = &quot;DANA A&quot;, salary = 170112)
=#</code></pre><p>It is possible to construct a <code>TupleVector</code> without labels.</p><pre><code class="language-julia">TupleVector(length(tv), columns(tv))
#-&gt; @VectorTree (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p>An error is reported in case of duplicate labels or columns of different height.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :name =&gt; [&quot;DANA A&quot;, &quot;JUAN R&quot;])
#-&gt; ERROR: duplicate column label :name

TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :salary =&gt; [260004, 185364, 170112])
#-&gt; ERROR: unexpected column height</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">labels(tv)
#-&gt; Symbol[:name, :salary]

width(tv)
#-&gt; 2

column(tv, 2)
#-&gt; [260004, 185364, 170112]

column(tv, :salary)
#-&gt; [260004, 185364, 170112]

columns(tv)
#-&gt; …[[&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;], [260004, 185364, 170112]]</code></pre><p>When indexed by another vector, we get a new instance of <code>TupleVector</code>.</p><pre><code class="language-julia">tv′ = tv[[3,1]]
display(tv′)
#=&gt;
TupleVector of 2 × (name = String, salary = Int):
 (name = &quot;DANA A&quot;, salary = 170112)
 (name = &quot;GARRY M&quot;, salary = 260004)
=#</code></pre><p>Note that the new instance keeps a reference to the index and the original column vectors.  Updated column vectors are generated on demand.</p><pre><code class="language-julia">column(tv′, 2)
#-&gt; [170112, 260004]</code></pre><h3><a class="nav-anchor" id="BlockVector-1" href="#BlockVector-1"><code>BlockVector</code></a></h3><p><code>BlockVector</code> is a vector of homogeneous vectors (blocks) stored as a vector of elements partitioned into individual blocks by a vector of offsets.</p><pre><code class="language-julia">bv = BlockVector([[&quot;HEALTH&quot;], [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], [], [&quot;POLICE&quot;, &quot;FIRE&quot;]])
#-&gt; @VectorTree [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]

display(bv)
#=&gt;
BlockVector of 4 × [String]:
 &quot;HEALTH&quot;
 [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;]
 missing
 [&quot;POLICE&quot;, &quot;FIRE&quot;]
=#</code></pre><p>We can omit brackets for singular blocks and use <code>missing</code> in place of empty blocks.</p><pre><code class="language-julia">BlockVector([&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]])
#-&gt; @VectorTree [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>It is possible to specify the offset and the element vectors separately.</p><pre><code class="language-julia">BlockVector([1, 2, 4, 4, 6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;])
#-&gt; @VectorTree [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>If each block contains exactly one element, we could use <code>:</code> in place of the offset vector.</p><pre><code class="language-julia">BlockVector(:, [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;])
#-&gt; @VectorTree [String] [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;]</code></pre><p>The <code>BlockVector</code> constructor verifies that the offset vector is well-formed.</p><pre><code class="language-julia">BlockVector(Base.OneTo(0), [])
#-&gt; ERROR: partition must be non-empty

BlockVector(Int[], [])
#-&gt; ERROR: partition must be non-empty

BlockVector([0], [])
#-&gt; ERROR: partition must start with 1

BlockVector([1,2,2,1], [&quot;HEALTH&quot;])
#-&gt; ERROR: partition must be monotone

BlockVector(Base.OneTo(4), [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements

BlockVector([1,2,3,6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">offsets(bv)
#-&gt; [1, 2, 4, 4, 6]

elements(bv)
#-&gt; [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;]

partition(bv)
#-&gt; ([1, 2, 4, 4, 6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;, &quot;POLICE&quot;, &quot;FIRE&quot;])</code></pre><p>When indexed by a vector of indexes, an instance of <code>BlockVector</code> is returned.</p><pre><code class="language-julia">elts = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

reg_bv = BlockVector(:, elts)
#-&gt; @VectorTree [String] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

opt_bv = BlockVector([1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7], elts)
#-&gt; @VectorTree [String] [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]

plu_bv = BlockVector([1, 1, 1, 2, 2, 4, 4, 6, 7], elts)
#-&gt; @VectorTree [String] [missing, missing, &quot;POLICE&quot;, missing, [&quot;FIRE&quot;, &quot;HEALTH&quot;], missing, [&quot;AVIATION&quot;, &quot;WATER MGMNT&quot;], &quot;FINANCE&quot;]

reg_bv[[1,3,5,3]]
#-&gt; @VectorTree [String] [&quot;POLICE&quot;, &quot;HEALTH&quot;, &quot;WATER MGMNT&quot;, &quot;HEALTH&quot;]

plu_bv[[1,3,5,3]]
#-&gt; @VectorTree [String] [missing, &quot;POLICE&quot;, [&quot;FIRE&quot;, &quot;HEALTH&quot;], &quot;POLICE&quot;]

reg_bv[Base.OneTo(4)]
#-&gt; @VectorTree [String] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;]

reg_bv[Base.OneTo(6)]
#-&gt; @VectorTree [String] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

plu_bv[Base.OneTo(6)]
#-&gt; @VectorTree [String] [missing, missing, &quot;POLICE&quot;, missing, [&quot;FIRE&quot;, &quot;HEALTH&quot;], missing]

opt_bv[Base.OneTo(10)]
#-&gt; @VectorTree [String] [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]</code></pre><h3><a class="nav-anchor" id="IndexVector-1" href="#IndexVector-1"><code>IndexVector</code></a></h3><p><code>IndexVector</code> is a vector of indexes in some named vector.</p><pre><code class="language-julia">iv = IndexVector(:REF, [1, 1, 1, 2])
#-&gt; @VectorTree &amp;REF [1, 1, 1, 2]

display(iv)
#=&gt;
IndexVector of 4 × &amp;REF:
 1
 1
 1
 2
=#</code></pre><p>We can obtain the components of the vector.</p><pre><code class="language-julia">identifier(iv)
#-&gt; :REF

indexes(iv)
#-&gt; [1, 1, 1, 2]</code></pre><p>Indexing an <code>IndexVector</code> by a vector produces another <code>IndexVector</code> instance.</p><pre><code class="language-julia">iv[[4,2]]
#-&gt; @VectorTree &amp;REF [2, 1]</code></pre><p><code>IndexVector</code> can be deferenced against a list of named vectors.</p><pre><code class="language-julia">refv = [&quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot;, &quot;ZONING ADMINISTRATOR&quot;, &quot;PROJECT MANAGER&quot;]

dereference(iv, [:REF =&gt; refv])
#-&gt; [&quot;COMISSIONER&quot;, &quot;COMISSIONER&quot;, &quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot;]</code></pre><p>Function <code>dereference()</code> has no effect on other types of vectors, or when the desired reference vector is not in the list.</p><pre><code class="language-julia">dereference(iv, [:REF′ =&gt; refv])
#-&gt; @VectorTree &amp;REF [1, 1, 1, 2]

dereference([1, 1, 1, 2], [:REF =&gt; refv])
#-&gt; [1, 1, 1, 2]</code></pre><h3><a class="nav-anchor" id="CapsuleVector-1" href="#CapsuleVector-1"><code>CapsuleVector</code></a></h3><p><code>CapsuleVector</code> provides references for a composite vector with nested indexes. We use <code>CapsuleVector</code> to represent self-referential and mutually referential data.</p><pre><code class="language-julia">cv = CapsuleVector(TupleVector(:ref =&gt; iv), :REF =&gt; refv)
#-&gt; @VectorTree (ref = &amp;REF,) [(ref = 1,), (ref = 1,), (ref = 1,), (ref = 2,)] where {REF = [ … ]}

display(cv)
#=&gt;
CapsuleVector of 4 × (ref = &amp;REF,):
 (ref = 1,)
 (ref = 1,)
 (ref = 1,)
 (ref = 2,)
where
 REF = [&quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot; … ]
=#</code></pre><p>Function <code>decapsulate()</code> decomposes a capsule into the underlying vector and a list of references.</p><pre><code class="language-julia">decapsulate(cv)
#-&gt; (@VectorTree (ref = &amp;REF,) [ … ], Pair{Symbol,AbstractArray{T,1} where T}[ … ])</code></pre><p>Function <code>recapsulate()</code> applies the given function to the underlying vector and encapsulates the output of the function.</p><pre><code class="language-julia">cv′ = recapsulate(v -&gt; v[:, :ref], cv)
#-&gt; @VectorTree &amp;REF [1, 1, 1, 2] where {REF = [ … ]}</code></pre><p>We could dereference <code>CapsuleVector</code> if it wraps an <code>IndexVector</code> instance. Function <code>dereference()</code> has no effect otherwise.</p><pre><code class="language-julia">dereference(cv′)
#-&gt; [&quot;COMISSIONER&quot;, &quot;COMISSIONER&quot;, &quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot;]

dereference(cv)
#-&gt; @VectorTree (ref = &amp;REF,) [(ref = 1,), (ref = 1,), (ref = 1,), (ref = 2,)] where {REF = [ … ]}</code></pre><p>Indexing <code>CapsuleVector</code> by a vector produces another instance of <code>CapsuleVector</code>.</p><pre><code class="language-julia">cv[[4,2]]
#-&gt; @VectorTree (ref = &amp;REF,) [(ref = 2,), (ref = 1,)] where {REF = [ … ]}</code></pre><h3><a class="nav-anchor" id="@VectorTree-1" href="#@VectorTree-1"><code>@VectorTree</code></a></h3><p>We can use <code>@VectorTree</code> macro to convert vector literals to the columnar form assembled with <code>TupleVector</code>, <code>BlockVector</code>, <code>IndexVector</code>, and <code>CapsuleVector</code>.</p><p><code>TupleVector</code> is created from a matrix or a vector of (named) tuples.</p><pre><code class="language-julia">@VectorTree (name = String, salary = Int) [
    &quot;GARRY M&quot;   260004
    &quot;ANTHONY R&quot; 185364
    &quot;DANA A&quot;    170112
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (&quot;GARRY M&quot;, 260004),
    (&quot;ANTHONY R&quot;, 185364),
    (&quot;DANA A&quot;, 170112),
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (name = &quot;GARRY M&quot;, salary = 260004),
    (name = &quot;ANTHONY R&quot;, salary = 185364),
    (name = &quot;DANA A&quot;, salary = 170112),
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]</code></pre><p>Column labels are optional.</p><pre><code class="language-julia">@VectorTree (String, Int) [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
#-&gt; @VectorTree (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p><code>BlockVector</code> and <code>IndexVector</code> can also be constructed.</p><pre><code class="language-julia">@VectorTree [String] [
    &quot;HEALTH&quot;,
    [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;],
    missing,
    [&quot;POLICE&quot;, &quot;FIRE&quot;],
]
#-&gt; @VectorTree [String] [&quot;HEALTH&quot;, [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], missing, [&quot;POLICE&quot;, &quot;FIRE&quot;]]

@VectorTree &amp;REF [1, 1, 1, 2]
#-&gt; @VectorTree &amp;REF [1, 1, 1, 2]</code></pre><p>A <code>CapsuleVector</code> could be constructed using <code>where</code> syntax.</p><pre><code class="language-julia">@VectorTree &amp;REF [1, 1, 1, 2] where {REF = refv}
#-&gt; @VectorTree &amp;REF [1, 1, 1, 2] where {REF = [&quot;COMISSIONER&quot;, &quot;DEPUTY COMISSIONER&quot;  … ]}</code></pre><p>Ill-formed <code>@VectorTree</code> contructors are rejected.</p><pre><code class="language-julia">@VectorTree (String, Int) (&quot;GARRY M&quot;, 260004)
#=&gt;
ERROR: LoadError: expected a vector literal; got :((&quot;GARRY M&quot;, 260004))
⋮
=#

@VectorTree (String, Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected no label; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected label :name; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004)]
#=&gt;
ERROR: LoadError: expected 2 column(s); got :((&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004))
⋮
=#

@VectorTree (name = String, salary = Int) [&quot;GARRY M&quot;]
#=&gt;
ERROR: LoadError: expected a tuple or a row literal; got &quot;GARRY M&quot;
⋮
=#

@VectorTree &amp;REF [[]] where (:REF =&gt; [])
#=&gt;
ERROR: LoadError: expected an assignment; got :(:REF =&gt; [])
⋮
=#</code></pre><p>Using <code>@VectorTree</code>, we can easily construct hierarchical and mutually referential data.</p><pre><code class="language-julia">hier_data = @VectorTree (name = [String], employee = [(name = [String], salary = [Int])]) [
    &quot;POLICE&quot;    [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
    &quot;FIRE&quot;      [&quot;JOSE S&quot; 202728; &quot;CHARLES S&quot; 197736]
]
display(hier_data)
#=&gt;
TupleVector of 2 × (name = [String], employee = [(name = [String], salary = [Int])]):
 (name = &quot;POLICE&quot;, employee = [(name = &quot;GARRY M&quot;, salary = 260004) … ])
 (name = &quot;FIRE&quot;, employee = [(name = &quot;JOSE S&quot;, salary = 202728) … ])
=#

mref_data = @VectorTree (department = [&amp;DEPT], employee = [&amp;EMP]) [
    [1, 2]  [1, 2, 3, 4, 5]
] where {
    DEPT = @VectorTree (name = [String], employee = [&amp;EMP]) [
        &quot;POLICE&quot;    [1, 2, 3]
        &quot;FIRE&quot;      [4, 5]
    ]
    ,
    EMP = @VectorTree (name = [String], department = [&amp;DEPT], salary = [Int]) [
        &quot;GARRY M&quot;   1   260004
        &quot;ANTHONY R&quot; 1   185364
        &quot;DANA A&quot;    1   170112
        &quot;JOSE S&quot;    2   202728
        &quot;CHARLES S&quot; 2   197736
    ]
}
display(mref_data)
#=&gt;
CapsuleVector of 1 × (department = [&amp;DEPT], employee = [&amp;EMP]):
 (department = [1, 2], employee = [1, 2, 3, 4, 5])
where
 DEPT = @VectorTree (name = [String], employee = [&amp;EMP]) [(name = &quot;POLICE&quot;, employee = [1, 2, 3]) … ]
 EMP = @VectorTree (name = [String], department = [&amp;DEPT], salary = [Int]) [(name = &quot;GARRY M&quot;, department = 1, salary = 260004) … ]
=#</code></pre><footer><hr/><a class="previous" href="layouts.html"><span class="direction">Previous</span><span class="title">Optimal Layouts</span></a><a class="next" href="shapes.html"><span class="direction">Next</span><span class="title">Type System</span></a></footer></article></body></html>
