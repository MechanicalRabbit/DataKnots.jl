<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pipeline Algebra · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../install/">Installation Instructions</a></li><li><a class="toctext" href="../thinking/">Thinking in Combinators</a></li><li><a class="toctext" href="../reference/">Reference</a></li><li><a class="toctext" href="../implementation/">Implementation Guide</a><ul><li class="current"><a class="toctext" href>Pipeline Algebra</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#API-Reference-1">API Reference</a></li><li><a class="toctext" href="#Test-Suite-1">Test Suite</a></li></ul></li></ul></li><li><a class="toctext" href="../simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="../implementation/">Implementation Guide</a></li><li><a href>Pipeline Algebra</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/pipelines.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Pipeline Algebra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Pipeline-Algebra-1" href="#Pipeline-Algebra-1">Pipeline Algebra</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>In this section, we describe the design and implementation of the pipeline algebra.  We will need the following definitions.</p><pre><code class="language-julia">using DataKnots:
    @VectorTree,
    OPT,
    REG,
    Count,
    DataKnot,
    Drop,
    Environment,
    Filter,
    Given,
    It,
    Lift,
    Lookup,
    Max,
    Min,
    Record,
    Take,
    apply,
    elements,
    optimize,
    stub</code></pre><p>As a running example, we will use the following dataset of city departments with associated employees.  This dataset is serialized as a nested structure with a singleton root record, which holds all department records, each of which holds associated employee records.</p><pre><code class="language-julia">elts =
    @VectorTree (department = [(name     = [String, REG],
                                employee = [(name     = [String, REG],
                                             position = [String, REG],
                                             salary   = [Int, OPT],
                                             rate     = [Float64, OPT])])],) [
        (department = [
            (name     = &quot;POLICE&quot;,
             employee = [&quot;JEFFERY A&quot;  &quot;SERGEANT&quot;           101442   missing
                         &quot;NANCY A&quot;    &quot;POLICE OFFICER&quot;     80016    missing]),
            (name     = &quot;FIRE&quot;,
             employee = [&quot;JAMES A&quot;    &quot;FIRE ENGINEER-EMT&quot;  103350   missing
                         &quot;DANIEL A&quot;   &quot;FIRE FIGHTER-EMT&quot;   95484    missing]),
            (name     = &quot;OEMC&quot;,
             employee = [&quot;LAKENYA A&quot;  &quot;CROSSING GUARD&quot;     missing  17.68
                         &quot;DORIS A&quot;    &quot;CROSSING GUARD&quot;     missing  19.38])],
        )
    ]

db = DataKnot(elts, REG)
#=&gt;
│ DataKnot                                                                     …
│ department                                                                   …
├──────────────────────────────────────────────────────────────────────────────…
│ POLICE, JEFFERY A, SERGEANT, 101442, ; NANCY A, POLICE OFFICER, 80016, ; FIRE…
=#</code></pre><h3><a class="nav-anchor" id="Assembling-pipelines-1" href="#Assembling-pipelines-1">Assembling pipelines</a></h3><p>In DataKnots, we query data by assembling and running query <em>pipelines</em>. Pipeline are assembled algebraically: they either come a set of atomic <em>primitive</em> pipelines, or are built from other pipelines using pipeline <em>combinators</em>.</p><p>For example, consider the pipeline:</p><pre><code class="language-julia">Employees = Lookup(:department) &gt;&gt; Lookup(:employee)
#-&gt; Lookup(:department) &gt;&gt; Lookup(:employee)</code></pre><p>This pipeline traverses the dataset through fields <em>department</em> and <em>employee</em>. It is assembled from two primitive pipelines <code>Lookup(:department)</code> and <code>Lookup(:employee)</code> connected using the pipeline composition combinator <code>&gt;&gt;</code>.</p><p>Since attribute traversal is very common, DataKnots provides a shorthand notation.</p><pre><code class="language-julia">Employees = It.department.employee
#-&gt; It.department.employee</code></pre><p>To get the data from a pipeline, we use function <code>run()</code>.  This function takes the input dataset and a pipeline object, and produces the output dataset.</p><pre><code class="language-julia">run(db, Employees)
#=&gt;
  │ employee                                    │
  │ name       position           salary  rate  │
──┼─────────────────────────────────────────────┤
1 │ JEFFERY A  SERGEANT           101442        │
2 │ NANCY A    POLICE OFFICER      80016        │
3 │ JAMES A    FIRE ENGINEER-EMT  103350        │
4 │ DANIEL A   FIRE FIGHTER-EMT    95484        │
5 │ LAKENYA A  CROSSING GUARD             17.68 │
6 │ DORIS A    CROSSING GUARD             19.38 │
=#</code></pre><p>Regular Julia values and functions could be used to create pipeline components. Specifically, any Julia value could be converted to a pipeline primitive, and any Julia function could be converted to a pipeline combinator.</p><p>For example, let us find find employees whose salary is greater than $100k. For this purpose, we need to construct a predicate pipeline that compares the <em>salary</em> field with a specific number.</p><p>If we were constructing an ordinary predicate function, we would write:</p><pre><code class="language-julia">emp -&gt; emp.salary &gt; 100000</code></pre><p>An equivalent pipeline is constructed as follows:</p><pre><code class="language-julia">SalaryOver100K = Lift(&gt;, (Lookup(:salary), Lift(100000)))
#-&gt; Lift(&gt;, (Lookup(:salary), Lift(100000)))</code></pre><p>This pipeline expression is assembled from two primitive components: <code>Lookup(:salary)</code> and <code>Lift(100000)</code>, which serve as parameters of the <code>Lift(&gt;)</code> combinator.  Here, <code>Lift</code> is used twice.  <code>Lift</code> applied to a regular Julia value converts it to a <em>constant</em> pipeline primitive while <code>Lift</code> applied to a function <em>lifts</em> it to a pipeline combinator.</p><p>As a shorthand notation for lifting functions and operators, DataKnots supports broadcasting syntax:</p><pre><code class="language-julia">SalaryOver100K = It.salary .&gt; 100000
#-&gt; It.salary .&gt; 100000</code></pre><p>To test this pipeline, we can append it to the <code>Employees</code> pipeline using the composition combinator.</p><pre><code class="language-julia">run(db, Employees &gt;&gt; SalaryOver100K)
#=&gt;
  │ DataKnot │
──┼──────────┤
1 │     true │
2 │    false │
3 │     true │
4 │    false │
=#</code></pre><p>However, this only gives us a list of bare Boolean values disconnected from the respective employees.  To improve this output, we can use the <code>Record</code> combinator.</p><pre><code class="language-julia">run(db, Employees &gt;&gt; Record(It.name,
                            It.salary,
                            :salary_over_100k =&gt; SalaryOver100K))
#=&gt;
  │ employee                            │
  │ name       salary  salary_over_100k │
──┼─────────────────────────────────────┤
1 │ JEFFERY A  101442              true │
2 │ NANCY A     80016             false │
3 │ JAMES A    103350              true │
4 │ DANIEL A    95484             false │
5 │ LAKENYA A                           │
6 │ DORIS A                             │
=#</code></pre><p>To actually filter the data using this predicate pipeline, we need to use the <code>Filter</code> combinator.</p><pre><code class="language-julia">EmployeesWithSalaryOver100K = Employees &gt;&gt; Filter(SalaryOver100K)
#-&gt; It.department.employee &gt;&gt; Filter(It.salary .&gt; 100000)

run(db, EmployeesWithSalaryOver100K)
#=&gt;
  │ employee                                   │
  │ name       position           salary  rate │
──┼────────────────────────────────────────────┤
1 │ JEFFERY A  SERGEANT           101442       │
2 │ JAMES A    FIRE ENGINEER-EMT  103350       │
=#</code></pre><p>DataKnots provides a number of useful pipeline constructors.  For example, to find the number of items produced by a pipeline, we can use the <code>Count</code> combinator.</p><pre><code class="language-julia">run(db, Count(EmployeesWithSalaryOver100K))
#=&gt;
│ DataKnot │
├──────────┤
│        2 │
=#</code></pre><p>In general, pipeline algebra forms an XPath-like domain-specific language.  It is designed to let the user construct pipelines incrementally, with each step being individually crafted and tested.  It also encourages the user to create reusable pipeline components and remix them in creative ways.</p><h3><a class="nav-anchor" id="Principal-queries-1" href="#Principal-queries-1">Principal queries</a></h3><p>In DataKnots, running a pipeline is a two-phase process.  First, the pipeline generates its <em>principal</em> query.  Second, the principal query transforms the input data to the output data.</p><p>Let us elaborate on the role of queries and pipelines.  In DataKnots, queries are used to transform data, and pipelines are used to transform monadic queries.  That is, just as a query can be applied to some dataset to produce a new dataset, a pipeline can be applied to a monadic query to produce a new monadic query.</p><p>Among all queries produced by a pipeline, we distinguish its principal query, which is obtained when the pipeline is applied to a <em>trivial</em> monadic query.</p><p>To demonstrate how the principal query is constructed, let us use the pipeline <code>EmployeesWithSalaryOver100K</code> from the previous section.  Recall that it could be represented as follows:</p><pre><code class="language-julia">Lookup(:department) &gt;&gt; Lookup(:employee) &gt;&gt; Filter(Lookup(:salary) .&gt; 100000)
#-&gt; Lookup(:department) &gt;&gt; Lookup(:employee) &gt;&gt; Filter(Lookup(:salary) .&gt; 100000)</code></pre><p>The pipeline <code>P</code> is constructed using a composition combinator.  A composition transforms a query by sequentially applying its components.  Therefore, to find the principal query of <code>P</code>, we need to start with a trivial query and sequentially tranfrorm it with the pipelines <code>Lookup(:department)</code>, <code>Lookup(:employee)</code> and <code>Filter(SalaryOver100K)</code>.</p><p>The trivial query is a monadic identity on the input dataset.</p><pre><code class="language-julia">q0 = stub(db)
#-&gt; wrap()</code></pre><p>To apply a pipeline to a query, we need to create application <em>environment</em>. Then we use the function <code>apply()</code>.</p><pre><code class="language-julia">env = Environment()

q1 = apply(Lookup(:department), env, q0)
#-&gt; chain_of(wrap(), with_elements(column(:department)), flatten())</code></pre><p>Here, the query <code>q1</code> is a monadic composition of <code>q0</code> with <code>column(:department)</code>.  Since <code>q0</code> is a monadic identity, this query is actually equivalent to <code>column(:department)</code>.</p><p>In general, <code>Lookup(name)</code> maps a query to its monadic composition with <code>column(name)</code>.  For example, when we apply <code>Lookup(:employee)</code> to <code>q1</code>, we get <code>compose(q1, column(:employee))</code>.</p><pre><code class="language-julia">q2 = apply(Lookup(:employee), env, q1)
#=&gt;
chain_of(chain_of(wrap(), with_elements(column(:department)), flatten()),
         with_elements(column(:employee)),
         flatten())
=#</code></pre><p>We conclude assembling the principal query by applying <code>Filter(SalaryOver100K)</code> to <code>q2</code>.  <code>Filter</code> acts on the input query as follows. First, it finds the principal query of the condition pipeline.  For that, we need a trivial monadic query on the output of <code>q2</code>.</p><pre><code class="language-julia">qc0 = stub(q2)
#-&gt; wrap()</code></pre><p>Passing <code>qc0</code> through <code>SalaryOver100K</code> gives us a query that generates the result of the condition.</p><pre><code class="language-julia">qc1 = apply(SalaryOver100K, env, qc0)
#=&gt;
chain_of(wrap(),
         with_elements(chain_of(tuple_of(
                                    chain_of(wrap(),
                                             with_elements(column(:salary)),
                                             flatten()),
                                    chain_of(wrap(),
                                             with_elements(
                                                 block_filler([100000], REG)),
                                             flatten())),
                                tuple_lift(&gt;),
                                adapt_missing())),
         flatten())
=#</code></pre><p><code>Filter(SalaryOver100K)</code> then combines the outputs of <code>q2</code> and <code>qc1</code> using <code>sieve()</code>.</p><pre><code class="language-julia">q3 = apply(Filter(SalaryOver100K), env, q2)
#=&gt;
chain_of(
    chain_of(chain_of(wrap(), with_elements(column(:department)), flatten()),
             with_elements(column(:employee)),
             flatten()),
    with_elements(
        chain_of(
            tuple_of(
                pass(),
                chain_of(
                    chain_of(
                        wrap(),
                        with_elements(
                            chain_of(
                                tuple_of(
                                    chain_of(wrap(),
                                             with_elements(column(:salary)),
                                             flatten()),
                                    chain_of(wrap(),
                                             with_elements(
                                                 block_filler([100000], REG)),
                                             flatten())),
                                tuple_lift(&gt;),
                                adapt_missing())),
                        flatten()),
                    block_any())),
            sieve())),
    flatten())
=#</code></pre><p>The resulting query could be compacted by simplifying the query expression.</p><pre><code class="language-julia">q = optimize(q3)
#=&gt;
chain_of(column(:department),
         with_elements(column(:employee)),
         flatten(),
         with_elements(
             chain_of(tuple_of(pass(),
                               chain_of(tuple_of(column(:salary),
                                                 block_filler([100000], REG)),
                                        tuple_lift(&gt;),
                                        adapt_missing(),
                                        block_any())),
                      sieve())),
         flatten())
=#</code></pre><p>Applying the principal query to the input data gives us the output of the pipeline.</p><pre><code class="language-julia">input = elements(db)
output = q(input)

display(elements(output))
#=&gt;
TupleVector of 2 × (name = [String, REG], position = [String, REG], salary = [Int, OPT], rate = [Float64, OPT]):
 (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing)
 (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing)
=#</code></pre><h2><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Count-Tuple{Any}" href="#DataKnots.Count-Tuple{Any}"><code>DataKnots.Count</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Count(X)
X &gt;&gt; Count</code></pre><p>Counts the number of elements produced by <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L655-L660">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Drop-Tuple{Any}" href="#DataKnots.Drop-Tuple{Any}"><code>DataKnots.Drop</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Drop(N)</code></pre><p>Drops the first <code>N</code> elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L804-L808">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Each-Tuple{Any}" href="#DataKnots.Each-Tuple{Any}"><code>DataKnots.Each</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Each(X)</code></pre><p>Makes <code>X</code> process its input elementwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L415-L419">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Filter-Tuple{Any}" href="#DataKnots.Filter-Tuple{Any}"><code>DataKnots.Filter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Filter(X)</code></pre><p>Filters the input by condition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L758-L762">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Given-Tuple{Any,Any}" href="#DataKnots.Given-Tuple{Any,Any}"><code>DataKnots.Given</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Given(P, X)</code></pre><p>Specifies the parameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L595-L599">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Label-Tuple{Symbol}" href="#DataKnots.Label-Tuple{Symbol}"><code>DataKnots.Label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Label(lbl::Symbol)</code></pre><p>Assigns a label.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L430-L434">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Lift-Tuple{Any,Tuple}" href="#DataKnots.Lift-Tuple{Any,Tuple}"><code>DataKnots.Lift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Lift(f, Xs)</code></pre><p>Converts a Julia function to a pipeline combinator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L356-L360">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Lift-Tuple{Any}" href="#DataKnots.Lift-Tuple{Any}"><code>DataKnots.Lift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Lift(val)</code></pre><p>Converts a Julia value to a pipeline primitive.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L348-L352">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Lookup-Tuple{Any}" href="#DataKnots.Lookup-Tuple{Any}"><code>DataKnots.Lookup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Lookup(name)</code></pre><p>Finds an attribute or a parameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L483-L487">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Max-Tuple{Any}" href="#DataKnots.Max-Tuple{Any}"><code>DataKnots.Max</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Max(X)
X &gt;&gt; Max</code></pre><p>Finds the maximum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L703-L708">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Min-Tuple{Any}" href="#DataKnots.Min-Tuple{Any}"><code>DataKnots.Min</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Min(X)
X &gt;&gt; Min</code></pre><p>Finds the minimum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L715-L720">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Record-Tuple" href="#DataKnots.Record-Tuple"><code>DataKnots.Record</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Record(Xs...)</code></pre><p>Creates a pipeline component for building a record.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L300-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Sum-Tuple{Any}" href="#DataKnots.Sum-Tuple{Any}"><code>DataKnots.Sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Sum(X)
X &gt;&gt; Sum</code></pre><p>Sums the elements produced by <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L691-L696">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Tag-Tuple{Symbol,Any}" href="#DataKnots.Tag-Tuple{Symbol,Any}"><code>DataKnots.Tag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Tag(name::Symbol, X)</code></pre><p>Assigns a name to a pipeline.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L449-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Take-Tuple{Any}" href="#DataKnots.Take-Tuple{Any}"><code>DataKnots.Take</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Take(N)</code></pre><p>Takes the first <code>N</code> elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L796-L800">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Environment" href="#DataKnots.Environment"><code>DataKnots.Environment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Environment()</code></pre><p>Pipeline execution state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L143-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Navigation" href="#DataKnots.Navigation"><code>DataKnots.Navigation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">It</code></pre><p>Identity pipeline with respect to pipeline composition.</p><pre><code class="language-julia">It.a.b.c</code></pre><p>Equivalent to <code>Lookup(:a) &gt;&gt; Lookup(:b) &gt;&gt; Lookup(:c)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L53-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Pipeline" href="#DataKnots.Pipeline"><code>DataKnots.Pipeline</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Pipeline(op, args...)</code></pre><p>A pipeline is a transformation of monadic queries.</p><p>Parameter <code>op</code> is a function that performs the transformation; <code>args</code> are extra arguments passed to the function.</p><p>The pipeline transforms an input monadic query <code>q</code> by invoking <code>op</code> with the following arguments:</p><pre><code class="language-julia">op(env::Environment, q::Query, args...)</code></pre><p>The result of <code>op</code> must again be a monadic query.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L16-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.run-Tuple{DataKnots.AbstractPipeline}" href="#Base.run-Tuple{DataKnots.AbstractPipeline}"><code>Base.run</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">run(F::AbstractPipeline; params...)</code></pre><p>Runs the pipeline with the given parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/754eb7bec8d3bad805ccb80212e7651f19a2ba10/src/pipelines.jl#L83-L87">source</a></section><h2><a class="nav-anchor" id="Test-Suite-1" href="#Test-Suite-1">Test Suite</a></h2><footer><hr/><a class="previous" href="../lifting/"><span class="direction">Previous</span><span class="title">Lifting Scalar Functions to Combinators</span></a><a class="next" href="../simulation/"><span class="direction">Next</span><span class="title">Tutorial: Simulated Data</span></a></footer></article></body></html>
