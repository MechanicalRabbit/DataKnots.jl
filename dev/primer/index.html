<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Primer · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></li><li><span class="toctext">Concepts</span><ul><li class="current"><a class="toctext" href>Primer</a><ul class="internal"><li><a class="toctext" href="#The-Unit-Knot-1">The Unit Knot</a></li><li><a class="toctext" href="#Constant-Queries-1">Constant Queries</a></li><li><a class="toctext" href="#Composition-and-Identity-1">Composition &amp; Identity</a></li><li><a class="toctext" href="#Lifting-Functions-1">Lifting Functions</a></li><li><a class="toctext" href="#Structuring-Data-1">Structuring Data</a></li><li><a class="toctext" href="#Aggregate-Queries-1">Aggregate Queries</a></li><li><a class="toctext" href="#Input-Source-1">Input Source</a></li><li><a class="toctext" href="#Group-1">Group</a></li><li><a class="toctext" href="#Query-Parameters-1">Query Parameters</a></li><li><a class="toctext" href="#Julia-Integration-1">Julia Integration</a></li></ul></li><li><a class="toctext" href="../vectors/">Column Store</a></li><li><a class="toctext" href="../pipelines/">Pipeline Algebra</a></li><li><a class="toctext" href="../shapes/">Shapes and Signatures</a></li><li><a class="toctext" href="../knots/">Data Knots</a></li><li><a class="toctext" href="../queries/">Query Algebra</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Concepts</li><li><a href>Primer</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/primer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Primer</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Primer-1" href="#Primer-1">Primer</a></h1><p>DataKnots is a Julia library for building database queries. In DataKnots, queries are assembled algebraically: they either come from a set of atomic <em>primitives</em> or are built from other queries using <em>combinators</em>.</p><p>To start working with DataKnots, we import the package:</p><pre><code class="language-julia">using DataKnots</code></pre><h2><a class="nav-anchor" id="The-Unit-Knot-1" href="#The-Unit-Knot-1">The Unit Knot</a></h2><p>A <code>DataKnot</code>, or just <em>knot</em>, is a container for structured, vectorized data. The <code>unitknot</code> is a trivial knot used as the starting point for constructing other knots.</p><pre><code class="language-julia">unitknot
#=&gt;
│ It │
┼────┼
│    │
=#</code></pre><p>The unit knot has a single value, an empty tuple. You could get the value of any knot using Julia&#39;s <code>get</code> function.</p><pre><code class="language-julia">get(unitknot)
#-&gt; ()</code></pre><h2><a class="nav-anchor" id="Constant-Queries-1" href="#Constant-Queries-1">Constant Queries</a></h2><p>Any Julia value could be converted to a <em>query</em> using the <code>Lift</code> constructor. Queries constructed this way are constant: for each input element they receive, they output the given value. Consider the query <code>Hello</code>, lifted from the string value <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">Hello = Lift(&quot;Hello World&quot;)</code></pre><p>To query <code>unitknot</code> with <code>Hello</code>, we use indexing notation <code>unitknot[Hello]</code>. In this case, <code>Hello</code> receives <code>nothing</code> from <code>unitknot</code> and produces the value, <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">unitknot[Hello]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>A <code>Tuple</code> lifted to a constant query is displayed as a table.</p><pre><code class="language-julia">unitknot[Lift((name=&quot;DataKnots&quot;, version=&quot;0.1&quot;))]
#=&gt;
│ name       version │
┼────────────────────┼
│ DataKnots  0.1     │
=#</code></pre><p>A <code>missing</code> value lifted to a constant query produces no output.</p><pre><code class="language-julia">unitknot[Lift(missing)]
#=&gt;
│ It │
┼────┼
=#</code></pre><p>A <code>Vector</code> lifted to a constant query will produce plural output.</p><pre><code class="language-julia">unitknot[Lift(&#39;a&#39;:&#39;c&#39;)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p>We call queries constructed this way primitives, as they do not rely upon any other query. There are also combinators, which build new queries from existing ones.</p><h2><a class="nav-anchor" id="Composition-and-Identity-1" href="#Composition-and-Identity-1">Composition &amp; Identity</a></h2><p>Two queries can be connected sequentially using the <em>composition</em> combinator (<code>&gt;&gt;</code>). Consider the composition <code>Lift(1:3) &gt;&gt; Hello</code>. Since <code>Hello</code> produces a value for each input element, preceding it with <code>Lift(1:3)</code> generates three copies of <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Hello]
#=&gt;
  │ It          │
──┼─────────────┼
1 │ Hello World │
2 │ Hello World │
3 │ Hello World │
=#</code></pre><p>If we compose two plural queries, <code>Lift(1:2)</code> and <code>Lift(&#39;a&#39;:&#39;c&#39;)</code>, the output will contain the elements of <code>&#39;a&#39;:&#39;c&#39;</code> repeated twice.</p><pre><code class="language-julia">unitknot[Lift(1:2) &gt;&gt; Lift(&#39;a&#39;:&#39;c&#39;)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>The <em>identity</em> with respect to query composition is called <code>It</code>. This primitive can be composed with any query without changing the query&#39;s output.</p><pre><code class="language-julia">unitknot[Hello &gt;&gt; It]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>The identity primitive, <code>It</code>, can be used to construct queries which rely upon the output from previous processing.</p><pre><code class="language-julia">Increment = It .+ 1
unitknot[Lift(1:3) &gt;&gt; Increment]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  3 │
3 │  4 │
=#</code></pre><p>In DataKnots, queries are built algebraically, starting with query primitives, such as constants (<code>Lift</code>) or the identity (<code>It</code>), and then arranged with with combinators, such as composition (<code>&gt;&gt;</code>). This lets us define sophisticated query components and remix them in creative ways.</p><h2><a class="nav-anchor" id="Lifting-Functions-1" href="#Lifting-Functions-1">Lifting Functions</a></h2><p>Any function could be used in a query. Consider the function <code>double(x)</code> that, when applied to a <code>Number</code>, produces a <code>Number</code>:</p><pre><code class="language-julia">double(x) = 2x
double(3) #-&gt; 6</code></pre><p>What we want is an analogue to <code>double</code> which, instead of operating on numbers, operates on queries. Such functions are called query combinators. We can convert any function to a combinator by passing the function and its arguments to <code>Lift</code>.</p><pre><code class="language-julia">Double(X) = Lift(double, (X,))</code></pre><p>For a given query <code>X</code>, the combinator <code>Double(X)</code> evaluates <code>X</code> and then runs each output element though the <code>double</code> function.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Double(It)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  4 │
3 │  6 │
=#</code></pre><p>Alternatively, instead of <code>Lift</code> we could use broadcasting. For example, <code>double.(It)</code> is equivalent to <code>Lift(double, (It,))</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; double.(It)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  4 │
3 │  6 │
=#</code></pre><p>Broadcasting also works with operators.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (It .+ 1)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  3 │
3 │  4 │
=#</code></pre><p>Unary operators can be broadcast as well.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (√).(It)]
#=&gt;
  │ It      │
──┼─────────┼
1 │ 1.0     │
2 │ 1.41421 │
3 │ 1.73205 │
=#</code></pre><p>Broadcasting could only be used when at least one argument is a query. For this reason, when defining a combinator, it is recommended to use <code>Lift</code> over broadcasting.</p><pre><code class="language-julia">Sqrt(X) = Lift(√, (X,))

unitknot[Sqrt(2)]
#=&gt;
│ It      │
┼─────────┼
│ 1.41421 │
=#</code></pre><p>Vector-valued functions give rise to plural queries. Here, the unit range constructor is lifted to a query combinator that builds plural queries.</p><pre><code class="language-julia">OneTo(X) = Lift(:, (1, X))

unitknot[OneTo(3)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  2 │
3 │  3 │
=#</code></pre><p>Since later in this guide we&#39;ll want to enumerate the alphabet, let&#39;s define a combinator for that as well. In this definition, anonymous function syntax (<code>-&gt;</code>) is used to build an expression that is then lifted to queries.</p><pre><code class="language-julia">Chars(N) = Lift(n -&gt; &#39;a&#39;:&#39;a&#39;+n-1, (N,))

unitknot[Chars(3)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p>Lifting lets us use rich statistical and data processing functions from within our queries.</p><h2><a class="nav-anchor" id="Structuring-Data-1" href="#Structuring-Data-1">Structuring Data</a></h2><p>Thus far we&#39;ve seen query results that are consist of a single output flow. Using the <code>Record</code> combinator, we could construct outputs with parallel, subordinate query flows.</p><pre><code class="language-julia">unitknot[Record(&quot;Hello World&quot;, Lift(1:3), Chars(3))]
#=&gt;
│ #A           #B       #C      │
┼───────────────────────────────┼
│ Hello World  1; 2; 3  a; b; c │
=#</code></pre><p>To help navigate these structures, each field of a record could be optionally named using the <code>Label</code> primitive. Alternatively, the <code>Pair</code> syntax could be used to provide labels. If a field label is omitted, one generated based upon column position is provided.</p><pre><code class="language-julia">ExampleRecord = Record(:greeting =&gt; &quot;Hello World&quot;,
                       Lift(1:3) &gt;&gt; Label(:numbers),
                       Chars(3))

unitknot[ExampleRecord]
#=&gt;
│ greeting     numbers  #C      │
┼───────────────────────────────┼
│ Hello World  1; 2; 3  a; b; c │
=#</code></pre><p>The <code>Get</code> constructor builds a query that, given a particular label, extracts the corresponding flow from an underlying record. Attribute access on the identity constant, <code>It</code>, is syntax sugar for this same operation.</p><pre><code class="language-julia">unitknot[ExampleRecord &gt;&gt; Get(:greeting)]
#=&gt;
│ greeting    │
┼─────────────┼
│ Hello World │
=#

unitknot[ExampleRecord &gt;&gt; It.numbers]
#=&gt;
  │ numbers │
──┼─────────┼
1 │       1 │
2 │       2 │
3 │       3 │
=#

unitknot[ExampleRecord &gt;&gt; It.C]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p>Records can be used to construct arbitrary hierarchies, including tables with plural and nested columns. The display of records uses the colon (<code>,</code>) for nested record fields and the semi-colon (<code>;</code>) to separate elements in a plural flow.</p><pre><code class="language-julia">Q = Record(:n² =&gt; It .* It,
           :n³ =&gt; It .* It .* It,
           :letters =&gt; Chars(It),
           :nested =&gt; Record(It, Chars(It)))

unitknot[Lift(1:3) &gt;&gt; Q]
#=&gt;
  │ n²  n³  letters  nested       │
──┼───────────────────────────────┼
1 │  1   1  a        1, [a]       │
2 │  4   8  a; b     2, [a; b]    │
3 │  9  27  a; b; c  3, [a; b; c] │
=#</code></pre><p>Previously we&#39;ve seen how the composition of two plural queries doesn&#39;t produce a nested result, but instead a flattened stream. Let&#39;s take a look at this case again.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Chars(It)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ a  │
3 │ b  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>In this example, as the outer query goes from <code>1</code> to <code>3</code>, the inner query goes from producing <code>a</code> to producing <code>a</code>, <code>b</code>, <code>c</code>. With an intermediate <code>Record</code>, we might better see this progression.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Record(It, Chars(It))]
#=&gt;
  │ #A  #B      │
──┼─────────────┼
1 │  1  a       │
2 │  2  a; b    │
3 │  3  a; b; c │
=#</code></pre><p>In DataKnots, flows are automatically flattened as part of query composition. If nested lists are needed, they could be easily modeled with an intermediate record. Together, flows and records are used to represent and process a wide variety of structures.</p><h2><a class="nav-anchor" id="Aggregate-Queries-1" href="#Aggregate-Queries-1">Aggregate Queries</a></h2><p>So far queries have been <em>elementwise</em>; that is, for each input element, they produce zero or more output elements. Consider the <code>Count</code> primitive; it returns the number of its input elements.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Count]
#=&gt;
│ It │
┼────┼
│  3 │
=#</code></pre><p>An <em>aggregate</em> query such as <code>Count</code> is computed over the input as a whole, and not for each individual element. The semantics of aggregates require discussion. Consider <code>Lift(1:3) &gt;&gt; OneTo(It)</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; OneTo(It)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  1 │
3 │  2 │
4 │  1 │
5 │  2 │
6 │  3 │
=#</code></pre><p>By appending <code>&gt;&gt; Sum</code> we could aggregate the entire input flow, producing a single output element.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; OneTo(It) &gt;&gt; Sum]
#=&gt;
│ It │
┼────┼
│ 10 │
=#</code></pre><p>What if we wanted to produce sums by the outer query, <code>Lift(1:3)</code>? Since query composition (<code>&gt;&gt;</code>) is associative, adding parenthesis around <code>OneTo(It) &gt;&gt; Sum</code> will not change the result.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (OneTo(It) &gt;&gt; Sum)]
#=&gt;
│ It │
┼────┼
│ 10 │
=#</code></pre><p>We need the <code>Each</code> combinator, which acts as an elementwise barrier. For each input element, <code>Each</code> evaluates its argument, and then collects the outputs.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Each(OneTo(It) &gt;&gt; Sum)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  3 │
3 │  6 │
=#</code></pre><p>Following is an equivalent query, using the <code>Sum</code> combinator. Here, <code>Sum(X)</code> produces the same output as <code>Each(X &gt;&gt; Sum)</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Sum(OneTo(It))]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  3 │
3 │  6 │
=#</code></pre><p>Julia functions taking a vector argument, such as <code>mean</code>, can be lifted to a combinator taking a plural query. When performed, the plural output is converted into the function&#39;s vector argument.</p><pre><code class="language-julia">using Statistics
Mean(X) = mean.(X)

unitknot[Mean(Lift(1:3) &gt;&gt; Sum(OneTo(It)))]
#=&gt;
│ It      │
┼─────────┼
│ 3.33333 │
=#</code></pre><p>To use <code>Mean</code> as a query primitive, we use <code>Then</code> to build a query that aggregates elements from its input. Next, we register this query so it is used when <code>Mean</code> is treated as a query.</p><pre><code class="language-julia">DataKnots.Lift(::typeof(Mean)) = DataKnots.Then(Mean)</code></pre><p>Once these are done, one could take an average of sums as follows:</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Sum(OneTo(It)) &gt;&gt; Mean]
#=&gt;
│ It      │
┼─────────┼
│ 3.33333 │
=#</code></pre><p>In DataKnots, summary operations are expressed as aggregate query primitives or as query combinators taking a plural query argument. Moreover, custom aggregates can be constructed from native Julia functions and lifted into the query algebra.</p><h2><a class="nav-anchor" id="Input-Source-1" href="#Input-Source-1">Input Source</a></h2><p>We&#39;ve seen how aggregates, such as <code>Sum</code>, operate on the input as a whole to produce an output. We&#39;ve also seen how <code>Each</code> creates an aggregation barrier by changing the input <em>source</em>.  But what exactly does this mean?  Let&#39;s recall a previous example.</p><pre><code class="language-julia">Chars(X) = Lift(x -&gt; &#39;a&#39;:&#39;a&#39;+x-1, (X,))

unitknot[Lift(1:3) &gt;&gt; Chars(It)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ a  │
3 │ b  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>Let&#39;s use the <code>Max</code> aggregate to report the highest letter encountered. In this case, the input source for <code>Max</code> happens to be the entire list of letters.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Chars(It) &gt;&gt; Max]
#=&gt;
│ It │
┼────┼
│ c  │
=#</code></pre><p>We could use <code>Record</code> to bucket the letters by the outer index.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Record(Chars(It))]
#=&gt;
  │ #A      │
──┼─────────┼
1 │ a       │
2 │ a; b    │
3 │ a; b; c │
=#</code></pre><p>Then we could compute the maximum letter for each of the three records. In this example, the input for each invocation of <code>Max</code> is a set of letters, as seen above.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Record(Chars(It) &gt;&gt; Max)]
#=&gt;
  │ #A │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p>This bucketing is what <code>Each</code> does, only that an intermediate record is not formed. For each of its input elements, it processes that element in its own context, where it becomes the input source for subsequent aggregates.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Each(Chars(It) &gt;&gt; Max)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p>After the argument is processed for every input element to <code>Each</code>, the outputs are flattened into a single output flow. In this way, the use of <code>Each</code> in the following query doesn&#39;t do anything. It may process <code>Chars(It)</code> for each input element, but in the end, even though the outputs may be initially segregated, they are eventually merged together.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Each(Chars(It))]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ a  │
3 │ b  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>This could be seen with another aggregate, <code>Take</code>. Unlike <code>Filter</code> which evaluates its argument for each input element, the argument to <code>Take</code> is evaluated once, and in the context of the input&#39;s <em>source</em>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Each(Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Take(It))]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ a  │
3 │ b  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>In this example, the argument of <code>Take</code> evaluates in the context of <code>Lift(1:3)</code>. Therefore, <code>Take</code> will be performed three times, where <code>It</code> has the values <code>1</code>, <code>2</code>, and <code>3</code>.</p><h2><a class="nav-anchor" id="Group-1" href="#Group-1">Group</a></h2><p>Before we can demonstrate <code>Group</code>, we need an interesting dataset. Let&#39;s create a flat list of numbers with two characteristics.</p><pre><code class="language-julia">DataRow = :data=&gt; Record(:no =&gt; It,
                         :even =&gt; iseven.(It),
                         :char =&gt; Char.((It .+ 2) .% 3 .+ 97))
DataSet = Lift(1:9) &gt;&gt; DataRow

unitknot[DataSet]
#=&gt;
  │ data            │
  │ no  even   char │
──┼─────────────────┼
1 │  1  false  a    │
2 │  2   true  b    │
3 │  3  false  c    │
4 │  4   true  a    │
5 │  5  false  b    │
6 │  6   true  c    │
7 │  7  false  a    │
8 │  8   true  b    │
9 │  9  false  c    │
=#</code></pre><p>The <code>Group</code> combinator rearranges the dataset to bucket unique values of a particular expression together with its matching data.</p><pre><code class="language-julia">unitknot[DataSet &gt;&gt; Group(It.char)]
#=&gt;
  │ char  data                                 │
──┼────────────────────────────────────────────┼
1 │ a     1, false, a; 4, true, a; 7, false, a │
2 │ b     2, true, b; 5, false, b; 8, true, b  │
3 │ c     3, false, c; 6, true, c; 9, false, c │
=#</code></pre><p>With this rearrangement, we could summarize data with respect to the grouping expression.</p><pre><code class="language-julia">unitknot[DataSet &gt;&gt;
         Group(It.char) &gt;&gt;
         Record(It.char,
                It.data.no,
                :count =&gt; Count(It.data),
                :mean =&gt; mean.(It.data.no))]
#=&gt;
  │ char  no       count  mean │
──┼────────────────────────────┼
1 │ a     1; 4; 7      3   4.0 │
2 │ b     2; 5; 8      3   5.0 │
3 │ c     3; 6; 9      3   6.0 │
=#</code></pre><p>It&#39;s possible to group by more than one expression.</p><pre><code class="language-julia">unitknot[DataSet &gt;&gt;
         Group(It.even, It.char) &gt;&gt;
         Record(It.even, It.char, It.data.no)]
#=&gt;
  │ even   char  no   │
──┼───────────────────┼
1 │ false  a     1; 7 │
2 │ false  b     5    │
3 │ false  c     3; 9 │
4 │  true  a     4    │
5 │  true  b     2; 8 │
6 │  true  c     6    │
=#</code></pre><p>The <code>Group</code> combinator lets you adapt the structure of a dataset to form a hierarchy suitable to a particular analysis.</p><h2><a class="nav-anchor" id="Query-Parameters-1" href="#Query-Parameters-1">Query Parameters</a></h2><p>With DataKnots, parameters can be provided so that static data can be used within query expressions. By convention, we use upper case, singular labels for query parameters.</p><pre><code class="language-julia">unitknot[&quot;Hello &quot; .* Get(:WHO), WHO=&quot;World&quot;]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>To make <code>Get</code> convenient, <code>It</code> provides a shorthand syntax.</p><pre><code class="language-julia">unitknot[&quot;Hello &quot; .* It.WHO, WHO=&quot;World&quot;]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>Query parameters are available anywhere in the query. They could, for example be used within a filter.</p><pre><code class="language-julia">query = OneTo(6) &gt;&gt; Filter(It .&gt; It.START)

unitknot[query, START=3]
#=&gt;
  │ It │
──┼────┼
1 │  4 │
2 │  5 │
3 │  6 │
=#</code></pre><p>Parameters can also be defined as part of a query using <code>Given</code>. This combinator takes set of pairs (<code>=&gt;</code>) that map symbols (<code>:name</code>) onto query expressions. The subsequent argument is then evaluated in a naming context where the defined parameters are available for reuse.</p><pre><code class="language-julia">unitknot[Given(:WHO =&gt; &quot;World&quot;, &quot;Hello &quot; .* Get(:WHO))]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>Query parameters can be especially useful when managing aggregates, or with expressions that one may wish to repeat more than once.</p><pre><code class="language-julia">GreaterThanAverage(X) =
  Given(:AVG =&gt; Mean(X),
        X &gt;&gt; Filter(It .&gt; Get(:AVG)))

unitknot[GreaterThanAverage(OneTo(6))]
#=&gt;
  │ It │
──┼────┼
1 │  4 │
2 │  5 │
3 │  6 │
=#</code></pre><p>With <code>Given</code> the parameter provided, <code>AVG</code> does not leak into the surrounding context.</p><pre><code class="language-julia">unitknot[GreaterThanAverage(OneTo(6)) &gt;&gt; It.AVG]
#-&gt; ERROR: cannot find &quot;AVG&quot; at ⋮</code></pre><p>In DataKnots, query parameters permit external data to be used within query expressions. Parameters that are defined with <code>Given</code> can be used to remember values and reuse them.</p><h2><a class="nav-anchor" id="Julia-Integration-1" href="#Julia-Integration-1">Julia Integration</a></h2><p>DataKnots is a query algebra embedded in the Julia programming language. We should discuss the interaction between the semantics of the query algebra and the semantics of Julia.</p><h3><a class="nav-anchor" id="Precedence-of-Composition-1" href="#Precedence-of-Composition-1">Precedence of Composition</a></h3><p>DataKnots uses Julia&#39;s bitshift operator (<code>&gt;&gt;</code>) for composition.</p><p>This works visually, but the <em>precedence</em> of this operator does not match user expectations. Specifically, common binary operators such as addition (<code>+</code>) have a lower precedence.</p><p>This expectation mismatch could lead a user to write:</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; It .+ It]
#-&gt; ERROR: cannot apply + to Tuple{Array{Int64,1},Tuple{}}⋮</code></pre><p>To fix this query, we add parentheses.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (It .+ It)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  4 │
3 │  6 │
=#</code></pre><h3><a class="nav-anchor" id="Composition-of-Queries-1" href="#Composition-of-Queries-1">Composition of Queries</a></h3><p>For bitshift operator (<code>&gt;&gt;</code>) to work as composition, the first operand must be a query.</p><pre><code class="language-julia">unitknot[1:3 &gt;&gt; &quot;Hello&quot;]
#-&gt; ERROR: MethodError: no method matching &gt;&gt;(::Int64, ::String)⋮</code></pre><p>To fix this query, we use <code>Lift</code> to convert the first operand to a query.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; &quot;Hello&quot;]
#=&gt;
  │ It    │
──┼───────┼
1 │ Hello │
2 │ Hello │
3 │ Hello │
=#</code></pre><h3><a class="nav-anchor" id="Broadcasting-over-Queries-1" href="#Broadcasting-over-Queries-1">Broadcasting over Queries</a></h3><p>Broadcasting can be used to convert function calls into query expressions. For broadcasting to build a query, at least one argument must be a query.</p><p>Even when the argument isn&#39;t a query, the result often works as expected.</p><pre><code class="language-julia">unitknot[iseven.(2)]
#=&gt;
│ It   │
┼──────┼
│ true │
=#</code></pre><p>In this case, <code>iseven.(2)</code> is evaluated to the constant <code>true</code>, which is automatically lifted to a constant query.</p><p>For some functions this may lead to unexpected results. Suppose we need to generate 3 random characters.</p><pre><code class="language-julia">using Random: seed!, rand
seed!(1)
rand(&#39;a&#39;:&#39;z&#39;)
#-&gt; &#39;o&#39;</code></pre><p>We could try to make the following query.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; rand(&#39;a&#39;:&#39;z&#39;)]
#=&gt;
  │ It │
──┼────┼
1 │ c  │
2 │ c  │
3 │ c  │
=#</code></pre><p>Unfortunately, the function <code>rand</code> evaluated once, which gives us the same value repeated 3 times. Let&#39;s try broadcasting.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; rand.(&#39;a&#39;:&#39;z&#39;)]
#-&gt; ERROR: ArgumentError: Sampler for this object is not defined⋮</code></pre><p>For broadcasting to generate a query, we need at least one argument to be a query. If we don&#39;t have a query argument, we could make one using <code>Lift</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; rand.(Lift(&#39;a&#39;:&#39;z&#39;))]
#=&gt;
  │ It │
──┼────┼
1 │ h  │
2 │ b  │
3 │ v  │
=#</code></pre><footer><hr/><a class="previous" href="../reference/"><span class="direction">Previous</span><span class="title">Reference</span></a><a class="next" href="../vectors/"><span class="direction">Next</span><span class="title">Column Store</span></a></footer></article></body></html>
