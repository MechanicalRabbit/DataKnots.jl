<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Column Store · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../install/">Installation Instructions</a></li><li><a class="toctext" href="../thinking/">Thinking in Combinators</a></li><li><a class="toctext" href="../usage/">Usage Guide</a></li><li><a class="toctext" href="../implementation/">Implementation Guide</a><ul><li class="current"><a class="toctext" href>Column Store</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#API-Reference-1">API Reference</a></li><li><a class="toctext" href="#Test-Suite-1">Test Suite</a></li></ul></li></ul></li><li><a class="toctext" href="../generated/simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="../implementation/">Implementation Guide</a></li><li><a href>Column Store</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/vectors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Column Store</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Column-Store-1" href="#Column-Store-1">Column Store</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>This section describes how <code>DataKnots</code> implements an in-memory column store. We will need the following definitions:</p><pre><code class="language-julia">using DataKnots:
    @VectorTree,
    OPT,
    PLU,
    REG,
    BlockVector,
    Cardinality,
    TupleVector,
    cardinality,
    column,
    columns,
    elements,
    isoptional,
    isplural,
    isregular,
    labels,
    offsets,
    width</code></pre><h3><a class="nav-anchor" id="Tabular-data-1" href="#Tabular-data-1">Tabular data</a></h3><p>Structured data can often be represented in a tabular form.  For example, information about city employees can be arranged in the following table.</p><table><tr><th>name</th><th>position</th><th>salary</th></tr><tr><td>JEFFERY A</td><td>SERGEANT</td><td>101442</td></tr><tr><td>JAMES A</td><td>FIRE ENGINEER-EMT</td><td>103350</td></tr><tr><td>TERRY A</td><td>POLICE OFFICER</td><td>93354</td></tr></table><p>Internally, a database engine stores tabular data using composite data structures such as <em>tuples</em> and <em>vectors</em>.</p><p>A tuple is a fixed-size collection of heterogeneous values and can represent a table row.</p><pre><code class="language-julia">(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442)</code></pre><p>A vector is a variable-size collection of homogeneous values and can store a table column.</p><pre><code class="language-julia">[&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;]</code></pre><p>For a table as a whole, we have two options: either store it as a vector of tuples or store it as a tuple of vectors.  The former is called a <em>row-oriented format</em>, commonly used in programming and traditional database engines.</p><pre><code class="language-julia">[(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442),
 (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350),
 (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354)]</code></pre><p>The other option, &quot;tuple of vectors&quot; layout, is called a <em>column-oriented format</em>.  It is often used by analytical databases as it is more suited for processing complex analytical queries.</p><p>The module <code>DataKnot</code> implements data structures to support column-oriented data format.  In particular, tabular data is represented using <code>TupleVector</code> objects.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;],
            :position =&gt; [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;],
            :salary =&gt; [101442, 103350, 93354])</code></pre><h3><a class="nav-anchor" id="Blank-cells-1" href="#Blank-cells-1">Blank cells</a></h3><p>As we arrange data in a tabular form, we may need to leave some cells blank.</p><p>For example, consider that a city employee could be compensated either with salary or with hourly pay.  To display the compensation data in a table, we add two columns: the annual salary and the hourly rate.  However, only one of the columns per each row is filled.</p><table><tr><th>name</th><th>position</th><th>salary</th><th>rate</th></tr><tr><td>JEFFERY A</td><td>SERGEANT</td><td>101442</td><td></td></tr><tr><td>JAMES A</td><td>FIRE ENGINEER-EMT</td><td>103350</td><td></td></tr><tr><td>TERRY A</td><td>POLICE OFFICER</td><td>93354</td><td></td></tr><tr><td>LAKENYA A</td><td>CROSSING GUARD</td><td></td><td>17.68</td></tr></table><p>How can this data be serialized in a column-oriented format?  To retain the advantages of the format, we&#39;d like to keep the column data in tightly packed vectors of <em>elements</em>.</p><pre><code class="language-julia">name_elts = [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;, &quot;LAKENYA A&quot;]
position_elts = [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;, &quot;CROSSING GUARD&quot;]
salary_elts = [101442, 103350, 93354]
rate_elts = [17.68]</code></pre><p>These vectors are partitioned into table cells by the vectors of <em>offsets</em>.</p><pre><code class="language-julia">name_offs = [1, 2, 3, 4, 5]
position_offs = [1, 2, 3, 4, 5]
salary_offs = [1, 2, 3, 4, 4]
rate_offs = [1, 1, 1, 1, 2]</code></pre><p>Each pair of adjacent offsets maps a slice of the element vector to the corresponding column cell.  For example, here is how we fetch the 4-th row of the table:</p><pre><code class="language-julia">(name_elts[name_offs[4]:name_offs[5]-1],
 position_elts[position_offs[4]:position_offs[5]-1],
 salary_elts[salary_offs[4]:salary_offs[5]-1],
 rate_elts[rate_offs[4]:rate_offs[5]-1])
#-&gt; ([&quot;LAKENYA A&quot;], [&quot;CROSSING GUARD&quot;], Int[], [17.68])</code></pre><p>Together, elements and offsets faithfully reproduce the layout of the column. A pair of the offset and the element vectors is encapsulated with a <code>BlockVector</code> instance.</p><pre><code class="language-julia">name_col = BlockVector(name_offs, name_elts, REG)
position_col = BlockVector(position_offs, position_elts, REG)
salary_col = BlockVector(salary_offs, salary_elts, OPT)
rate_col = BlockVector(rate_offs, rate_elts, OPT)</code></pre><p><code>BlockVector</code> is a column-oriented encoding of a vector of variable-size blocks.  The last parameter of the <code>BlockVector</code> constructor is the <em>cardinality</em> constraint on the size of the blocks.  <code>REG</code> indicates that each block has exactly one element; <code>OPT</code> allows a block to be empty.  The constraint <code>PLU</code> is used to indicate that a block may contain more than one element.</p><p>In this specific case, each block corresponds to a table cell: an empty block to a blank cell and a one-element block to a filled cell.  To represent the whole table, the columns should be wrapped with a <code>TupleVector</code>.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; name_col,
    :position =&gt; position_col,
    :salary =&gt; salary_col,
    :rate =&gt; rate_col)</code></pre><h3><a class="nav-anchor" id="Nested-data-1" href="#Nested-data-1">Nested data</a></h3><p>When data does not fit a single table, it can often be presented in a top-down fashion.  For example, HR data can be seen as a collection of departments, each of which containing the associated employees.  Such data is serialized using <em>nested</em> data structures, which, in row-oriented format, may look as follows:</p><pre><code class="language-julia">[(name = &quot;POLICE&quot;,
  employee = [(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
              (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 80016, rate = missing)]),
 (name = &quot;FIRE&quot;,
  employee = [(name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
              (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;, salary = 95484, rate = missing)]),
 (name = &quot;OEMC&quot;,
  employee = [(name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
              (name = &quot;DORIS A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 19.38)])]</code></pre><p>To store this data in a column-oriented format, we should use nested <code>TupleVector</code> and <code>BlockVector</code> instances.  We start with representing employee data.</p><pre><code class="language-julia">employee_elts =
    TupleVector(
        :name =&gt; BlockVector(:, [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;]),
        :position =&gt; BlockVector(:, [&quot;SERGEANT&quot;, &quot;POLICE OFFICER&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;FIRE FIGHTER-EMT&quot;, &quot;CROSSING GUARD&quot;, &quot;CROSSING GUARD&quot;]),
        :salary =&gt; BlockVector([1, 2, 3, 4, 5, 5, 5], [101442, 80016, 103350, 95484], OPT),
        :rate =&gt; BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], OPT))</code></pre><p>Then we partition employee data by departments:</p><pre><code class="language-julia">employee_col = BlockVector([1, 3, 5, 7], employee_elts, PLU)</code></pre><p>Adding a column of department names, we obtain HR data in a column-oriented format.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; BlockVector(:, [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;]),
    :employee =&gt; employee_col)</code></pre><p>Since writing offset vectors manually is tedious, <code>DataKnots</code> provides a convenient macro <code>@VectorTree</code>, which lets you specify column-oriented data using regular tuple and vector literals.</p><pre><code class="language-julia">@VectorTree (name = [String, REG],
             employee = [(name = [String, REG],
                          position = [String, REG],
                          salary = [Int, OPT],
                          rate = [Float64, OPT]), PLU]) [
    (name = &quot;POLICE&quot;,
     employee = [(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
                 (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 80016, rate = missing)]),
    (name = &quot;FIRE&quot;,
     employee = [(name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
                 (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;, salary = 95484, rate = missing)]),
    (name = &quot;OEMC&quot;,
     employee = [(name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
                 (name = &quot;DORIS A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 19.38)])
]</code></pre><h2><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.BlockVector" href="#DataKnots.BlockVector"><code>DataKnots.BlockVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BlockVector(offs::AbstractVector{Int}, elts::AbstractVector, card::Cardinality=OPT|PLU)
BlockVector(:, elts::AbstractVector, card::Cardinality=REG)</code></pre><p>Vector of vectors (blocks) stored as a vector of elements partitioned by a vector of offsets.</p><ul><li><code>elts</code> is a continuous vector of block elements.</li><li><code>offs</code> is a vector of indexes that subdivide <code>elts</code> into separate blocks. Should be monotonous with <code>offs[1] == 1</code> and <code>offs[end] == length(elts)+1</code>.</li><li><code>card</code> is the expected cardinality of the blocks.</li></ul><p>The second constructor creates a <code>BlockVector</code> of one-element blocks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/a25920df82abb80d27deb799f1b7982fee667b2d/src/vectors.jl#L258-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Cardinality" href="#DataKnots.Cardinality"><code>DataKnots.Cardinality</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">REG::Cardinality
OPT::Cardinality
PLU::Cardinality
OPT|PLU::Cardinality</code></pre><p>Cardinality constraints on a block of values.  <code>REG</code> stands for <em>1…1</em>, <code>OPT</code> for <em>0…1</em>, <code>PLU</code> for <em>1…∞</em>, <code>OPT|PLU</code> for <em>0…∞</em>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/a25920df82abb80d27deb799f1b7982fee667b2d/src/vectors.jl#L211-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.TupleVector" href="#DataKnots.TupleVector"><code>DataKnots.TupleVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TupleVector([lbls::Vector{Symbol},] len::Int, cols::Vector{AbstractVector})
TupleVector([lbls::Vector{Symbol},] idxs::AbstractVector{Int}, cols::Vector{AbstractVector})
TupleVector(lcols::Pair{Symbol,&lt;:AbstractVector}...)</code></pre><p>Vector of tuples stored as a collection of column vectors.</p><ul><li><code>cols</code> is a vector of columns; optional <code>lbls</code> is a vector of column labels. Alternatively, labels and columns could be provided as a list of pairs <code>lcols</code>.</li><li><code>len</code> is the vector length, which must coincide with the length of all the columns.  Alternatively, the vector could be constructed from a subset of the column data using a vector of indexes <code>idxs</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/a25920df82abb80d27deb799f1b7982fee667b2d/src/vectors.jl#L23-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}" href="#Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(::BlockVector)[ks::AbstractVector{Int}] :: BlockVector</code></pre><p>Returns a new <code>BlockVector</code> with a selection of blocks specified by indexes <code>ks</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/a25920df82abb80d27deb799f1b7982fee667b2d/src/vectors.jl#L364-L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}" href="#Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(::TupleVector)[ks::AbstractVector{Int}] :: TupleVector</code></pre><p>Returns a new <code>TupleVector</code> with a subset of rows specified by indexes <code>ks</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/a25920df82abb80d27deb799f1b7982fee667b2d/src/vectors.jl#L185-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.@VectorTree-Tuple{Any,Any}" href="#DataKnots.@VectorTree-Tuple{Any,Any}"><code>DataKnots.@VectorTree</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@VectorTree sig vec</code></pre><p>Constructs a tree of columnar vectors from a plain vector literal.</p><p>The first parameter, <code>sig</code>, describes the tree structure.  It is defined recursively:</p><ul><li>Julia type <code>T</code> indicates a regular vector of type <code>T</code>.</li><li>Tuple <code>(col₁, col₂, ...)</code> indicates a <code>TupleVector</code> instance.</li><li>Named tuple <code>(lbl₁ = col₁, lbl₂ = col₂, ...)</code> indicates a <code>TupleVector</code> instance with the given labels.</li><li>One-element vector <code>[elt]</code> indicates a <code>BlockVector</code> instance.</li><li>Two-element vector <code>[elt, card]</code> indicates a <code>BlockVector</code> with the given cardinality.</li></ul><p>The second parameter, <code>vec</code>, is a vector literal in row-oriented format:</p><ul><li><code>TupleVector</code> data is specified either by a matrix or by a vector of (regular or named) tuples.</li><li><code>BlockVector</code> data is specified by a vector of vectors.  A one-element block could be represented by its element; an empty block by <code>missing</code> literal.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/a25920df82abb80d27deb799f1b7982fee667b2d/src/vectors.jl#L523-L545">source</a></section><h2><a class="nav-anchor" id="Test-Suite-1" href="#Test-Suite-1">Test Suite</a></h2><h3><a class="nav-anchor" id="TupleVector-1" href="#TupleVector-1"><code>TupleVector</code></a></h3><p><code>TupleVector</code> is a vector of tuples stored as a collection of parallel vectors.</p><pre><code class="language-julia">tv = TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;],
                 :salary =&gt; [260004, 185364, 170112])
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

display(tv)
#=&gt;
TupleVector of 3 × (name = String, salary = Int):
 (name = &quot;GARRY M&quot;, salary = 260004)
 (name = &quot;ANTHONY R&quot;, salary = 185364)
 (name = &quot;DANA A&quot;, salary = 170112)
=#</code></pre><p>It is possible to construct a <code>TupleVector</code> without labels.</p><pre><code class="language-julia">TupleVector(length(tv), columns(tv))
#-&gt; @VectorTree (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p>An error is reported in case of duplicate labels or columns of different height.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :name =&gt; [&quot;DANA A&quot;, &quot;JUAN R&quot;])
#-&gt; ERROR: duplicate column label :name

TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :salary =&gt; [260004, 185364, 170112])
#-&gt; ERROR: unexpected column height</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">labels(tv)
#-&gt; Symbol[:name, :salary]

width(tv)
#-&gt; 2

column(tv, 2)
#-&gt; [260004, 185364, 170112]

column(tv, :salary)
#-&gt; [260004, 185364, 170112]

columns(tv)
#-&gt; …[[&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;], [260004, 185364, 170112]]</code></pre><p>When indexed by another vector, we get a new instance of <code>TupleVector</code>.</p><pre><code class="language-julia">tv′ = tv[[3,1]]
display(tv′)
#=&gt;
TupleVector of 2 × (name = String, salary = Int):
 (name = &quot;DANA A&quot;, salary = 170112)
 (name = &quot;GARRY M&quot;, salary = 260004)
=#</code></pre><p>Note that the new instance wraps the index and the original column vectors. Updated column vectors are generated on demand.</p><pre><code class="language-julia">column(tv′, 2)
#-&gt; [170112, 260004]</code></pre><h3><a class="nav-anchor" id="Cardinality-1" href="#Cardinality-1"><code>Cardinality</code></a></h3><p>Enumerated type <code>Cardinality</code> is used to constrain the cardinality of a data block.  A block of data is called <em>regular</em> if it must contain exactly one element; <em>optional</em> if it may have no elements; and <em>plural</em> if it may have more than one element.  This gives us four different cardinality constraints.</p><pre><code class="language-julia">display(Cardinality)
#=&gt;
Enum Cardinality:
REG = 0x00
OPT = 0x01
PLU = 0x02
OPT_PLU = 0x03
=#</code></pre><p>Cardinality values support bitwise operations.</p><pre><code class="language-julia">print(REG|OPT|PLU)      #-&gt; OPT_PLU
print(PLU&amp;~PLU)         #-&gt; REG</code></pre><p>We can use predicates <code>isregular()</code>, <code>isoptional()</code>, <code>isplural()</code> to check cardinality values.</p><pre><code class="language-julia">isregular(REG)          #-&gt; true
isregular(OPT)          #-&gt; false
isregular(PLU)          #-&gt; false
isoptional(OPT)         #-&gt; true
isoptional(PLU)         #-&gt; false
isplural(PLU)           #-&gt; true
isplural(OPT)           #-&gt; false</code></pre><h3><a class="nav-anchor" id="BlockVector-1" href="#BlockVector-1"><code>BlockVector</code></a></h3><p><code>BlockVector</code> is a vector of homogeneous vectors (blocks) stored as a vector of elements partitioned into individual blocks by a vector of offsets.</p><pre><code class="language-julia">bv = BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;], PLU)
#-&gt; @VectorTree [String, PLU] [[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]

display(bv)
#=&gt;
BlockVector of 3 × [String, PLU]:
 [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]
 [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]
 [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]
=#</code></pre><p>If each block contains exactly one element, we could use <code>:</code> in place of the offset vector.</p><pre><code class="language-julia">BlockVector(:, [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;])
#-&gt; @VectorTree [String, REG] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;]</code></pre><p>The <code>BlockVector</code> constructor verifies that the offset vector is well-formed.</p><pre><code class="language-julia">BlockVector(Base.OneTo(0), [])
#-&gt; ERROR: partition must be non-empty

BlockVector(Int[], [])
#-&gt; ERROR: partition must be non-empty

BlockVector([0], [])
#-&gt; ERROR: partition must start with 1

BlockVector([1,2,2,1], [&quot;HEALTH&quot;])
#-&gt; ERROR: partition must be monotone

BlockVector(Base.OneTo(4), [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements

BlockVector([1,2,3,6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements</code></pre><p>The constructor also validates the cardinality constraint.</p><pre><code class="language-julia">BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;], OPT)
#-&gt; ERROR: singular blocks must have at most one element

BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], REG)
#-&gt; ERROR: mandatory blocks must have at least one element</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">offsets(bv)
#-&gt; [1, 3, 5, 7]

elements(bv)
#-&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;]

print(cardinality(bv))
#-&gt; PLU</code></pre><p>When indexed by a vector of indexes, an instance of <code>BlockVector</code> is returned.</p><pre><code class="language-julia">elts = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

reg_bv = BlockVector(:, elts, REG)
#-&gt; @VectorTree [String, REG] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

opt_bv = BlockVector([1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7], elts, OPT)
#-&gt; @VectorTree [String, OPT] [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]

plu_bv = BlockVector([1, 1, 1, 2, 2, 4, 4, 6, 7], elts, OPT|PLU)
#-&gt; @VectorTree [String] [[], [], [&quot;POLICE&quot;], [], [&quot;FIRE&quot;, &quot;HEALTH&quot;], [], [&quot;AVIATION&quot;, &quot;WATER MGMNT&quot;], [&quot;FINANCE&quot;]]

reg_bv[[1,3,5,3]]
#-&gt; @VectorTree [String, REG] [&quot;POLICE&quot;, &quot;HEALTH&quot;, &quot;WATER MGMNT&quot;, &quot;HEALTH&quot;]

plu_bv[[1,3,5,3]]
#-&gt; @VectorTree [String] [[], [&quot;POLICE&quot;], [&quot;FIRE&quot;, &quot;HEALTH&quot;], [&quot;POLICE&quot;]]

reg_bv[Base.OneTo(4)]
#-&gt; @VectorTree [String, REG] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;]

reg_bv[Base.OneTo(6)]
#-&gt; @VectorTree [String, REG] [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

plu_bv[Base.OneTo(6)]
#-&gt; @VectorTree [String] [[], [], [&quot;POLICE&quot;], [], [&quot;FIRE&quot;, &quot;HEALTH&quot;], []]

opt_bv[Base.OneTo(10)]
#-&gt; @VectorTree [String, OPT] [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]</code></pre><h3><a class="nav-anchor" id="@VectorTree-1" href="#@VectorTree-1"><code>@VectorTree</code></a></h3><p>We can use <code>@VectorTree</code> macro to convert vector literals to the columnar form assembled with <code>TupleVector</code> and <code>BlockVector</code> objects.</p><p><code>TupleVector</code> is created from a matrix or a vector of (named) tuples.</p><pre><code class="language-julia">@VectorTree (name = String, salary = Int) [
    &quot;GARRY M&quot;   260004
    &quot;ANTHONY R&quot; 185364
    &quot;DANA A&quot;    170112
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (&quot;GARRY M&quot;, 260004),
    (&quot;ANTHONY R&quot;, 185364),
    (&quot;DANA A&quot;, 170112),
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (name = &quot;GARRY M&quot;, salary = 260004),
    (name = &quot;ANTHONY R&quot;, salary = 185364),
    (name = &quot;DANA A&quot;, salary = 170112),
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]</code></pre><p>Column labels are optional.</p><pre><code class="language-julia">@VectorTree (String, Int) [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
#-&gt; @VectorTree (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p><code>BlockVector</code> is constructed from a vector of vector literals.  A one-element block could be represented by the element itself; an empty block by <code>missing</code>.</p><pre><code class="language-julia">@VectorTree [String] [
    &quot;HEALTH&quot;,
    [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;],
    missing,
    [&quot;POLICE&quot;, &quot;FIRE&quot;],
]
#-&gt; @VectorTree [String] [[&quot;HEALTH&quot;], [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], [], [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>Ill-formed <code>@VectorTree</code> contructors are rejected.</p><pre><code class="language-julia">@VectorTree (String, Int) (&quot;GARRY M&quot;, 260004)
#=&gt;
ERROR: LoadError: expected a vector literal; got :((&quot;GARRY M&quot;, 260004))
⋮
=#

@VectorTree (String, Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected no label; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected label :name; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004)]
#=&gt;
ERROR: LoadError: expected 2 column(s); got :((&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004))
⋮
=#

@VectorTree (name = String, salary = Int) [&quot;GARRY M&quot;]
#=&gt;
ERROR: LoadError: expected a tuple or a row literal; got &quot;GARRY M&quot;
⋮
=#</code></pre><p>Using <code>@VectorTree</code>, we can easily construct hierarchical data.</p><pre><code class="language-julia">hier_data = @VectorTree (name = [String, REG], employee = [(name = [String, REG], salary = [Int, OPT])]) [
    &quot;POLICE&quot;    [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
    &quot;FIRE&quot;      [&quot;JOSE S&quot; 202728; &quot;CHARLES S&quot; 197736]
]
display(hier_data)
#=&gt;
TupleVector of 2 × (name = [String, REG], employee = [(name = [String, REG], salary = [Int, OPT])]):
 (name = &quot;POLICE&quot;, employee = [(name = &quot;GARRY M&quot;, salary = 260004) … ])
 (name = &quot;FIRE&quot;, employee = [(name = &quot;JOSE S&quot;, salary = 202728) … ])
=#</code></pre><footer><hr/><a class="previous" href="../implementation/"><span class="direction">Previous</span><span class="title">Implementation Guide</span></a><a class="next" href="../queries/"><span class="direction">Next</span><span class="title">Query Algebra</span></a></footer></article></body></html>
