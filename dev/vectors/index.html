<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Column Store · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../thinking/">Thinking in Combinators</a></li><li><a class="toctext" href="../reference/">Reference</a></li><li><a class="toctext" href="../implementation/">Implementation Guide</a><ul><li class="current"><a class="toctext" href>Column Store</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#API-Reference-1">API Reference</a></li><li><a class="toctext" href="#Test-Suite-1">Test Suite</a></li></ul></li></ul></li><li><a class="toctext" href="../simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="../implementation/">Implementation Guide</a></li><li><a href>Column Store</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/vectors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Column Store</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Column-Store-1" href="#Column-Store-1">Column Store</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>This section describes how <code>DataKnots</code> implements an in-memory column store. We will need the following definitions:</p><pre><code class="language-julia">using DataKnots:
    @VectorTree,
    BlockVector,
    TupleVector,
    column,
    columns,
    elements,
    isoptional,
    isplural,
    labels,
    offsets,
    width</code></pre><h3><a class="nav-anchor" id="Tabular-data-and-TupleVector-1" href="#Tabular-data-and-TupleVector-1">Tabular data and <code>TupleVector</code></a></h3><p>Structured data can often be represented in a tabular form.  For example, information about city employees can be arranged in the following table.</p><table><tr><th>name</th><th>position</th><th>salary</th></tr><tr><td>JEFFERY A</td><td>SERGEANT</td><td>101442</td></tr><tr><td>JAMES A</td><td>FIRE ENGINEER-EMT</td><td>103350</td></tr><tr><td>TERRY A</td><td>POLICE OFFICER</td><td>93354</td></tr></table><p>Internally, a database engine stores tabular data using composite data structures such as <em>tuples</em> and <em>vectors</em>.</p><p>A tuple is a fixed-size collection of heterogeneous values and can represent a table row.</p><pre><code class="language-julia">(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442)</code></pre><p>A vector is a variable-size collection of homogeneous values and can store a table column.</p><pre><code class="language-julia">[&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;]</code></pre><p>For a table as a whole, we have two options: either store it as a vector of tuples or store it as a tuple of vectors.  The former is called a <em>row-oriented format</em>, commonly used in programming and traditional database engines.</p><pre><code class="language-julia">[(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442),
 (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350),
 (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354)]</code></pre><p>The other option, &quot;tuple of vectors&quot; layout, is called a <em>column-oriented format</em>.  It is often used by analytical databases as it is more suited for processing complex analytical queries.</p><p>The module <code>DataKnot</code> implements data structures to support column-oriented data format.  In particular, tabular data is represented using <code>TupleVector</code> objects.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;],
            :position =&gt; [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;],
            :salary =&gt; [101442, 103350, 93354])</code></pre><p>Since creating <code>TupleVector</code> objects by hand is tedious and error prone, <code>DataKnots</code> provides a convenient macro <code>@VectorTree</code>, which lets you create column-oriented data using regular tuple and vector literals.</p><pre><code class="language-julia">@VectorTree (name = String, position = String, salary = Int) [
    (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442),
    (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350),
    (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354),
]</code></pre><h3><a class="nav-anchor" id="Hierarchical-data-and-BlockVector-1" href="#Hierarchical-data-and-BlockVector-1">Hierarchical data and <code>BlockVector</code></a></h3><p>Structured data could also be organized in hierarchical fashion.  For example, consider a collection of departments, where each department contains a list of associated employees.</p><table><tr><th>name</th><th>employee</th></tr><tr><td>POLICE</td><td>JEFFERY A; NANCY A</td></tr><tr><td>FIRE</td><td>JAMES A; DANIEL A</td></tr><tr><td>OEMC</td><td>LAKENYA A; DORIS A</td></tr></table><p>In the row-oriented format, this data is represented using nested vectors.</p><pre><code class="language-julia">[(name = &quot;POLICE&quot;, employee = [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]),
 (name = &quot;FIRE&quot;, employee = [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]),
 (name = &quot;OEMC&quot;, employee = [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;])]</code></pre><p>To represent this data in column-oriented format, we need to serialize <em>name</em> and <em>employee</em> as column vectors.  The <em>name</em> column is straightforward.</p><pre><code class="language-julia">name_col = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;]</code></pre><p>As for the <em>employee</em> column, naively, we could store it as a vector of vectors.</p><pre><code class="language-julia">[[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]</code></pre><p>However, this representation loses the advantages of the column-oriented format since the data is no longer serialized with a fixed number of vectors. Instead, we should keep the column data in a tightly-packed vector of <em>elements</em>.</p><pre><code class="language-julia">employee_elts = [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;]</code></pre><p>This vector could be partitioned into separate blocks by the vector of <em>offsets</em>.</p><pre><code class="language-julia">employee_offs = [1, 3, 5, 7]</code></pre><p>Each pair of adjacent offsets corresponds a slice of the element vector.</p><pre><code class="language-julia">employee_elts[employee_offs[1]:employee_offs[2]-1]
#-&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]
employee_elts[employee_offs[2]:employee_offs[3]-1]
#-&gt; [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]
employee_elts[employee_offs[3]:employee_offs[4]-1]
#-&gt; [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]</code></pre><p>Together, elements and offsets faithfully reproduce the layout of the column. A pair of the offset and the element vectors is encapsulated with a <code>BlockVector</code> object, which represents a column-oriented encoding of a vector of variable-size blocks.</p><pre><code class="language-julia">employee_col = BlockVector(employee_offs, employee_elts)</code></pre><p>Now we can wrap the columns using <code>TupleVector</code>.</p><pre><code class="language-julia">TupleVector(:name =&gt; name_col, :employee =&gt; employee_col)</code></pre><p><code>@VectorTree</code> provides a convenient way to create <code>BlockVector</code> objects from regular vector literals.</p><pre><code class="language-julia">@VectorTree (name = String, employee = (0:N)String) [
    (name = &quot;POLICE&quot;, employee = [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]),
    (name = &quot;FIRE&quot;, employee = [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]),
    (name = &quot;OEMC&quot;, employee = [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]),
]</code></pre><h3><a class="nav-anchor" id="Optional-values-1" href="#Optional-values-1">Optional values</a></h3><p>As we arrange data in a tabular form, we may need to leave some cells blank.</p><p>For example, consider that a city employee could be compensated either with salary or with hourly pay.  To display the compensation data in a table, we add two columns: the annual salary and the hourly rate.  However, only one of the columns per each row is filled.</p><table><tr><th>name</th><th>position</th><th>salary</th><th>rate</th></tr><tr><td>JEFFERY A</td><td>SERGEANT</td><td>101442</td><td></td></tr><tr><td>JAMES A</td><td>FIRE ENGINEER-EMT</td><td>103350</td><td></td></tr><tr><td>TERRY A</td><td>POLICE OFFICER</td><td>93354</td><td></td></tr><tr><td>LAKENYA A</td><td>CROSSING GUARD</td><td></td><td>17.68</td></tr></table><p>As in the previous section, the cells in this table may contain a variable number of values.  Therefore, the table columns could be represented using <code>BlockVector</code> objects.  We start with packing the column data as element vectors.</p><pre><code class="language-julia">salary_elts = [101442, 103350, 93354]
rate_elts = [17.68]</code></pre><p>Element vectors are partitioned into table cells by offset vectors.</p><pre><code class="language-julia">salary_offs = [1, 2, 3, 4, 4]
rate_offs = [1, 1, 1, 1, 2]</code></pre><p>The pairs of element of offset vectors are wrapped as <code>BlockVector</code> objects.</p><pre><code class="language-julia">salary_col = BlockVector(salary_offs, salary_elts, plural=false)
rate_col = BlockVector(rate_offs, rate_elts, plural=false)</code></pre><p>Here, the parameter <code>plural=false</code> of the <code>BlockVector</code> constructor specifies that each block should contain no more than one element.</p><p>The first two columns of the table do not contain empty cells, and therefore could be represented by regular vectors.  If we choose to wrap these columns with <code>BlockVector</code>, we should indicate that each block must contain exactly one element by specifying the parameters <code>plural=false</code> and <code>optional=false</code>. Alternatively, <code>BlockVector</code> provides the following shorthand notation.</p><pre><code class="language-julia">name_col = BlockVector(:, [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;, &quot;LAKENYA A&quot;])
position_col = BlockVector(:, [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;, &quot;CROSSING GUARD&quot;])</code></pre><p>To represent the whole table, the columns should be wrapped with a <code>TupleVector</code>.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; name_col,
    :position =&gt; position_col,
    :salary =&gt; salary_col,
    :rate =&gt; rate_col)</code></pre><p>As usual, we could create this data from tuple and vector literals.</p><pre><code class="language-julia">@VectorTree (name = (1:1)String,
             position = (1:1)String,
             salary = (0:1)Int,
             rate = (0:1)Float64) [
    (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
    (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
    (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354, rate = missing),
    (name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
]</code></pre><h3><a class="nav-anchor" id="Nested-data-1" href="#Nested-data-1">Nested data</a></h3><p>When data does not fit a single table, it can often be presented in a top-down fashion.  For example, HR data can be seen as a collection of departments, each of which containing the associated employees.  Such data is serialized using <em>nested</em> data structures, which, in row-oriented format, may look as follows:</p><pre><code class="language-julia">[(name = &quot;POLICE&quot;,
  employee = [(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
              (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 80016, rate = missing)]),
 (name = &quot;FIRE&quot;,
  employee = [(name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
              (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;, salary = 95484, rate = missing)]),
 (name = &quot;OEMC&quot;,
  employee = [(name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
              (name = &quot;DORIS A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 19.38)])]</code></pre><p>To store this data in a column-oriented format, we should use nested <code>TupleVector</code> and <code>BlockVector</code> instances.  We start with representing employee data.</p><pre><code class="language-julia">employee_elts =
    TupleVector(
        :name =&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;],
        :position =&gt; [&quot;SERGEANT&quot;, &quot;POLICE OFFICER&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;FIRE FIGHTER-EMT&quot;, &quot;CROSSING GUARD&quot;, &quot;CROSSING GUARD&quot;],
        :salary =&gt; BlockVector([1, 2, 3, 4, 5, 5, 5], [101442, 80016, 103350, 95484], plural=false),
        :rate =&gt; BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], plural=false))</code></pre><p>Then we partition employee data by departments:</p><pre><code class="language-julia">employee_col = BlockVector([1, 3, 5, 7], employee_elts)</code></pre><p>Adding a column of department names, we obtain HR data in a column-oriented format.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;],
    :employee =&gt; employee_col)</code></pre><p>Another way to assemble this data in column-oriented format is to use <code>@VectorTree</code>.</p><pre><code class="language-julia">@VectorTree (name = String,
             employee = [(name = String,
                          position = String,
                          salary = (0:1)Int,
                          rate = (0:1)Float64)]) [
    (name = &quot;POLICE&quot;,
     employee = [(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
                 (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 80016, rate = missing)]),
    (name = &quot;FIRE&quot;,
     employee = [(name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
                 (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;, salary = 95484, rate = missing)]),
    (name = &quot;OEMC&quot;,
     employee = [(name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
                 (name = &quot;DORIS A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 19.38)])
]</code></pre><h2><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.BlockVector" href="#DataKnots.BlockVector"><code>DataKnots.BlockVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BlockVector(offs::AbstractVector{Int}, elts::AbstractVector; plural=true, optional=true)
BlockVector(:, elts::AbstractVector; plural=false, optional=false)</code></pre><p>Vector of vectors (blocks) stored as a vector of elements partitioned by a vector of offsets.</p><ul><li><code>elts</code> is a continuous vector of block elements.</li><li><code>offs</code> is a vector of indexes that subdivide <code>elts</code> into separate blocks. Should be monotonous with <code>offs[1] == 1</code> and <code>offs[end] == length(elts)+1</code>. Use <code>:</code> if the offset vector is a unit range.</li><li><code>plural</code> is <code>false</code> if each block should contain at most 1 element (<code>offs[i+1] &lt;= offs[i]+1</code> for all <code>i</code>); <code>true</code> otherwise.</li><li><code>optional</code> is <code>false</code> if each block should contain at least 1 element (<code>offs[i+1] &gt;= offs[i]+1</code> for all <code>i</code>); <code>true</code> otherwise.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/28978b82a422e11868fdde533bf5191ade0df2c4/src/vectors.jl#L216-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.TupleVector" href="#DataKnots.TupleVector"><code>DataKnots.TupleVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TupleVector([lbls::Vector{Symbol},] len::Int, cols::Vector{AbstractVector})
TupleVector([lbls::Vector{Symbol},] idxs::AbstractVector{Int}, cols::Vector{AbstractVector})
TupleVector(lcols::Pair{&lt;:Union{Symbol,String},&lt;:AbstractVector}...)</code></pre><p>Vector of tuples stored as a collection of column vectors.</p><ul><li><code>cols</code> is a vector of columns; optional <code>lbls</code> is a vector of column labels. Alternatively, labels and columns could be provided as a list of pairs <code>lcols</code>.</li><li><code>len</code> is the vector length, which must coincide with the length of all the columns.  Alternatively, the vector could be constructed from a subset of the column data using a vector of indexes <code>idxs</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/28978b82a422e11868fdde533bf5191ade0df2c4/src/vectors.jl#L23-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}" href="#Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(::BlockVector)[ks::AbstractVector{Int}] :: BlockVector</code></pre><p>Returns a new <code>BlockVector</code> with a selection of blocks specified by indexes <code>ks</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/28978b82a422e11868fdde533bf5191ade0df2c4/src/vectors.jl#L333-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}" href="#Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(::TupleVector)[ks::AbstractVector{Int}] :: TupleVector</code></pre><p>Returns a new <code>TupleVector</code> with a subset of rows specified by indexes <code>ks</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/28978b82a422e11868fdde533bf5191ade0df2c4/src/vectors.jl#L188-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.@VectorTree-Tuple{Any,Any}" href="#DataKnots.@VectorTree-Tuple{Any,Any}"><code>DataKnots.@VectorTree</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@VectorTree sig vec</code></pre><p>Constructs a tree of columnar vectors from a plain vector literal.</p><p>The first parameter, <code>sig</code>, describes the tree structure.  It is defined recursively:</p><ul><li>Julia type <code>T</code> indicates a regular vector of type <code>T</code>.</li><li>Tuple <code>(col₁, col₂, ...)</code> indicates a <code>TupleVector</code> instance.</li><li>Named tuple <code>(lbl₁ = col₁, lbl₂ = col₂, ...)</code> indicates a <code>TupleVector</code> instance with the given labels.</li><li>Prefixes <code>(*)</code>, <code>(+)</code>, <code>(-)</code>, <code>(1)</code> indicate a <code>BlockVector</code> instance with the respective cardinality constraints (no constraints, mandatory, singular, mandatory+singular).</li></ul><p>The second parameter, <code>vec</code>, is a vector literal in row-oriented format:</p><ul><li><code>TupleVector</code> data is specified either by a matrix or by a vector of (regular or named) tuples.</li><li><code>BlockVector</code> data is specified by a vector of vectors.  A one-element block could be represented by its element; an empty block by <code>missing</code> literal.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/28978b82a422e11868fdde533bf5191ade0df2c4/src/vectors.jl#L494-L516">source</a></section><h2><a class="nav-anchor" id="Test-Suite-1" href="#Test-Suite-1">Test Suite</a></h2><h3><a class="nav-anchor" id="TupleVector-1" href="#TupleVector-1"><code>TupleVector</code></a></h3><p><code>TupleVector</code> is a vector of tuples stored as a collection of parallel vectors.</p><pre><code class="language-julia">tv = TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;],
                 :salary =&gt; [260004, 185364, 170112])
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

display(tv)
#=&gt;
@VectorTree of 3 × (name = String, salary = Int):
 (name = &quot;GARRY M&quot;, salary = 260004)
 (name = &quot;ANTHONY R&quot;, salary = 185364)
 (name = &quot;DANA A&quot;, salary = 170112)
=#</code></pre><p>Labels could be specified by strings.</p><pre><code class="language-julia">TupleVector(:salary =&gt; [260004, 185364, 170112], &quot;#B&quot; =&gt; [true, false, false])
#-&gt; @VectorTree (salary = Int, &quot;#B&quot; = Bool) [(salary = 260004, #B = 1) … ]</code></pre><p>It is also possible to construct a <code>TupleVector</code> without labels.</p><pre><code class="language-julia">TupleVector(length(tv), columns(tv))
#-&gt; @VectorTree (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p>An error is reported in case of duplicate labels or columns of different height.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :name =&gt; [&quot;DANA A&quot;, &quot;JUAN R&quot;])
#-&gt; ERROR: duplicate column label :name

TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :salary =&gt; [260004, 185364, 170112])
#-&gt; ERROR: unexpected column height</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">labels(tv)
#-&gt; Symbol[:name, :salary]

width(tv)
#-&gt; 2

column(tv, 2)
#-&gt; [260004, 185364, 170112]

column(tv, :salary)
#-&gt; [260004, 185364, 170112]

columns(tv)
#-&gt; …[[&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;], [260004, 185364, 170112]]</code></pre><p>When indexed by another vector, we get a new instance of <code>TupleVector</code>.</p><pre><code class="language-julia">tv′ = tv[[3,1]]
display(tv′)
#=&gt;
@VectorTree of 2 × (name = String, salary = Int):
 (name = &quot;DANA A&quot;, salary = 170112)
 (name = &quot;GARRY M&quot;, salary = 260004)
=#</code></pre><p>Note that the new instance wraps the index and the original column vectors. Updated column vectors are generated on demand.</p><pre><code class="language-julia">column(tv′, 2)
#-&gt; [170112, 260004]</code></pre><h3><a class="nav-anchor" id="BlockVector-1" href="#BlockVector-1"><code>BlockVector</code></a></h3><p><code>BlockVector</code> is a vector of homogeneous vectors (blocks) stored as a vector of elements partitioned into individual blocks by a vector of offsets.</p><pre><code class="language-julia">bv = BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;])
#-&gt; @VectorTree (0:N) × String [[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]

display(bv)
#=&gt;
@VectorTree of 3 × (0:N) × String:
 [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]
 [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]
 [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]
=#</code></pre><p>We can indicate that each block should contain at most one element or at least one element.</p><pre><code class="language-julia">BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], plural=false)
#-&gt; @VectorTree (0:1) × Float64 [missing, missing, missing, missing, 17.68, 19.38]

BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;], optional=false)
#-&gt; @VectorTree (1:N) × String [[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]</code></pre><p>If each block contains exactly one element, we could use <code>:</code> in place of the offset vector.</p><pre><code class="language-julia">BlockVector(:, [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;])
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;]</code></pre><p>The <code>BlockVector</code> constructor verifies that the offset vector is well-formed.</p><pre><code class="language-julia">BlockVector(Base.OneTo(0), [])
#-&gt; ERROR: partition must be non-empty

BlockVector(Int[], [])
#-&gt; ERROR: partition must be non-empty

BlockVector([0], [])
#-&gt; ERROR: partition must start with 1

BlockVector([1,2,2,1], [&quot;HEALTH&quot;])
#-&gt; ERROR: partition must be monotone

BlockVector(Base.OneTo(4), [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements

BlockVector([1,2,3,6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: partition must enclose the elements</code></pre><p>The constructor also validates the cardinality constraint.</p><pre><code class="language-julia">BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;], plural=false)
#-&gt; ERROR: singular blocks must have at most one element

BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], optional=false)
#-&gt; ERROR: mandatory blocks must have at least one element</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">offsets(bv)
#-&gt; [1, 3, 5, 7]

elements(bv)
#-&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;]

isplural(bv)
#-&gt; true

isoptional(bv)
#-&gt; true</code></pre><p>When indexed by a vector of indexes, an instance of <code>BlockVector</code> is returned.</p><pre><code class="language-julia">elts = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

reg_bv = BlockVector(:, elts)
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

opt_bv = BlockVector([1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7], elts, plural=false)
#-&gt; @VectorTree (0:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]

plu_bv = BlockVector([1, 1, 1, 2, 2, 4, 4, 6, 7], elts)
#-&gt; @VectorTree (0:N) × String [[], [], [&quot;POLICE&quot;], [], [&quot;FIRE&quot;, &quot;HEALTH&quot;], [], [&quot;AVIATION&quot;, &quot;WATER MGMNT&quot;], [&quot;FINANCE&quot;]]

reg_bv[[1,3,5,3]]
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;HEALTH&quot;, &quot;WATER MGMNT&quot;, &quot;HEALTH&quot;]

plu_bv[[1,3,5,3]]
#-&gt; @VectorTree (0:N) × String [[], [&quot;POLICE&quot;], [&quot;FIRE&quot;, &quot;HEALTH&quot;], [&quot;POLICE&quot;]]

reg_bv[Base.OneTo(4)]
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;]

reg_bv[Base.OneTo(6)]
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

plu_bv[Base.OneTo(6)]
#-&gt; @VectorTree (0:N) × String [[], [], [&quot;POLICE&quot;], [], [&quot;FIRE&quot;, &quot;HEALTH&quot;], []]

opt_bv[Base.OneTo(10)]
#-&gt; @VectorTree (0:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]</code></pre><h3><a class="nav-anchor" id="@VectorTree-1" href="#@VectorTree-1"><code>@VectorTree</code></a></h3><p>We can use <code>@VectorTree</code> macro to convert vector literals to the columnar form assembled with <code>TupleVector</code> and <code>BlockVector</code> objects.</p><p><code>TupleVector</code> is created from a matrix or a vector of (named) tuples.</p><pre><code class="language-julia">@VectorTree (name = String, salary = Int) [
    &quot;GARRY M&quot;   260004
    &quot;ANTHONY R&quot; 185364
    &quot;DANA A&quot;    170112
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (&quot;GARRY M&quot;, 260004),
    (&quot;ANTHONY R&quot;, 185364),
    (&quot;DANA A&quot;, 170112),
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (name = &quot;GARRY M&quot;, salary = 260004),
    (name = &quot;ANTHONY R&quot;, salary = 185364),
    (name = &quot;DANA A&quot;, salary = 170112),
]
#-&gt; @VectorTree (name = String, salary = Int) [(name = &quot;GARRY M&quot;, salary = 260004) … ]</code></pre><p>Column labels are optional.</p><pre><code class="language-julia">@VectorTree (String, Int) [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
#-&gt; @VectorTree (String, Int) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p><code>BlockVector</code> is constructed from a vector of vector literals.  A one-element block could be represented by the element itself; an empty block by <code>missing</code>.</p><pre><code class="language-julia">@VectorTree [String] [
    &quot;HEALTH&quot;,
    [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;],
    missing,
    [&quot;POLICE&quot;, &quot;FIRE&quot;],
]
#-&gt; @VectorTree (0:N) × String [[&quot;HEALTH&quot;], [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], [], [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>Ill-formed <code>@VectorTree</code> contructors are rejected.</p><pre><code class="language-julia">@VectorTree (String, Int) (&quot;GARRY M&quot;, 260004)
#=&gt;
ERROR: LoadError: expected a vector literal; got :((&quot;GARRY M&quot;, 260004))
⋮
=#

@VectorTree (String, Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected no label; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected label :name; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004)]
#=&gt;
ERROR: LoadError: expected 2 column(s); got :((&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004))
⋮
=#

@VectorTree (name = String, salary = Int) [&quot;GARRY M&quot;]
#=&gt;
ERROR: LoadError: expected a tuple or a row literal; got &quot;GARRY M&quot;
⋮
=#</code></pre><p>Using <code>@VectorTree</code>, we can easily construct hierarchical data.</p><pre><code class="language-julia">hier_data = @VectorTree (name = (1:1)String, employee = (0:N)(name = (1:1)String, salary = (0:1)Int)) [
    &quot;POLICE&quot;    [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
    &quot;FIRE&quot;      [&quot;JOSE S&quot; 202728; &quot;CHARLES S&quot; 197736]
]
display(hier_data)
#=&gt;
@VectorTree of 2 × (name = (1:1) × String,
                    employee = (0:N) × (name = (1:1) × String,
                                        salary = (0:1) × Int)):
 (name = &quot;POLICE&quot;, employee = [(name = &quot;GARRY M&quot;, salary = 260004) … ])
 (name = &quot;FIRE&quot;, employee = [(name = &quot;JOSE S&quot;, salary = 202728) … ])
=#</code></pre><footer><hr/><a class="previous" href="../implementation/"><span class="direction">Previous</span><span class="title">Implementation Guide</span></a><a class="next" href="../queries/"><span class="direction">Next</span><span class="title">Query Algebra</span></a></footer></article></body></html>
