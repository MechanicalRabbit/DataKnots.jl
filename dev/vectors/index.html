<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Column Store · DataKnots.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DataKnots.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Queries for Data Analysts</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../highlypaid/">Who is Highly Paid?</a></li></ul></li><li><span class="tocitem">Reference Manual</span><ul><li><a class="tocitem" href="../primer/">Thinking in Queries</a></li><li><a class="tocitem" href="../tutorial/">Embedded Query Interface</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li><li><span class="tocitem">Implementer&#39;s Guide</span><ul><li class="is-active"><a class="tocitem" href>Column Store</a><ul class="internal"><li><a class="tocitem" href="#Tabular-Data-and-TupleVector"><span>Tabular Data and <code>TupleVector</code></span></a></li><li><a class="tocitem" href="#Hierarchical-Data-and-BlockVector"><span>Hierarchical Data and <code>BlockVector</code></span></a></li><li><a class="tocitem" href="#Optional-Values"><span>Optional Values</span></a></li><li><a class="tocitem" href="#Nested-Data"><span>Nested Data</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Test-Suite"><span>Test Suite</span></a></li></ul></li><li><a class="tocitem" href="../pipelines/">Pipeline Algebra</a></li><li><a class="tocitem" href="../shapes/">Shapes and Signatures</a></li><li><a class="tocitem" href="../knots/">Data Knots</a></li><li><a class="tocitem" href="../queries/">Query Algebra</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementer&#39;s Guide</a></li><li class="is-active"><a href>Column Store</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Column Store</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/vectors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Column-Store"><a class="docs-heading-anchor" href="#Column-Store">Column Store</a><a id="Column-Store-1"></a><a class="docs-heading-anchor-permalink" href="#Column-Store" title="Permalink"></a></h1><p>This section describes how <code>DataKnots</code> implements an in-memory column store. We will need the following definitions:</p><pre><code class="language-julia">using DataKnots:
    @VectorTree,
    BlockVector,
    Cardinality,
    TupleVector,
    cardinality,
    column,
    columns,
    elements,
    ismandatory,
    issingular,
    labels,
    offsets,
    width,
    x0to1,
    x0toN,
    x1to1,
    x1toN</code></pre><h2 id="Tabular-Data-and-TupleVector"><a class="docs-heading-anchor" href="#Tabular-Data-and-TupleVector">Tabular Data and <code>TupleVector</code></a><a id="Tabular-Data-and-TupleVector-1"></a><a class="docs-heading-anchor-permalink" href="#Tabular-Data-and-TupleVector" title="Permalink"></a></h2><p>Structured data can often be represented in a tabular form.  For example, information about city employees can be arranged in the following table.</p><table><tr><th style="text-align: right">name</th><th style="text-align: right">position</th><th style="text-align: right">salary</th></tr><tr><td style="text-align: right">JEFFERY A</td><td style="text-align: right">SERGEANT</td><td style="text-align: right">101442</td></tr><tr><td style="text-align: right">JAMES A</td><td style="text-align: right">FIRE ENGINEER-EMT</td><td style="text-align: right">103350</td></tr><tr><td style="text-align: right">TERRY A</td><td style="text-align: right">POLICE OFFICER</td><td style="text-align: right">93354</td></tr></table><p>Internally, a database engine stores tabular data using composite data structures such as <em>tuples</em> and <em>vectors</em>.</p><p>A tuple is a fixed-size collection of heterogeneous values and can represent a table row.</p><pre><code class="language-julia">(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442)</code></pre><p>A vector is a variable-size collection of homogeneous values and can store a table column.</p><pre><code class="language-julia">[&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;]</code></pre><p>For a table as a whole, we have two options: either store it as a vector of tuples or store it as a tuple of vectors.  The former is called a <em>row-oriented format</em>, commonly used in programming and traditional database engines.</p><pre><code class="language-julia">[(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442),
 (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350),
 (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354)]</code></pre><p>The other option, &quot;tuple of vectors&quot; layout, is called a <em>column-oriented format</em>.  It is often used by analytical databases as it is more suited for processing complex analytical queries.</p><p>The <code>DataKnots</code> package implements data structures to support column-oriented data format.  In particular, tabular data is represented using <code>TupleVector</code> objects.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;],
            :position =&gt; [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;],
            :salary =&gt; [101442, 103350, 93354])</code></pre><p>Since creating <code>TupleVector</code> objects by hand is tedious and error prone, <code>DataKnots</code> provides a convenient macro <code>@VectorTree</code>, which lets you create column-oriented data using regular tuple and vector literals.</p><pre><code class="language-julia">@VectorTree (name = String, position = String, salary = Int) [
    (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442),
    (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350),
    (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354),
]</code></pre><h2 id="Hierarchical-Data-and-BlockVector"><a class="docs-heading-anchor" href="#Hierarchical-Data-and-BlockVector">Hierarchical Data and <code>BlockVector</code></a><a id="Hierarchical-Data-and-BlockVector-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-Data-and-BlockVector" title="Permalink"></a></h2><p>Structured data could also be organized in hierarchical fashion.  For example, consider a collection of departments, where each department contains a list of associated employees.</p><table><tr><th style="text-align: right">name</th><th style="text-align: right">employee</th></tr><tr><td style="text-align: right">POLICE</td><td style="text-align: right">JEFFERY A; NANCY A</td></tr><tr><td style="text-align: right">FIRE</td><td style="text-align: right">JAMES A; DANIEL A</td></tr><tr><td style="text-align: right">OEMC</td><td style="text-align: right">LAKENYA A; DORIS A</td></tr></table><p>In the row-oriented format, this data is represented using nested vectors.</p><pre><code class="language-julia">[(name = &quot;POLICE&quot;, employee = [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]),
 (name = &quot;FIRE&quot;, employee = [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]),
 (name = &quot;OEMC&quot;, employee = [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;])]</code></pre><p>To represent this data in column-oriented format, we need to serialize <em>name</em> and <em>employee</em> as column vectors.  The <em>name</em> column is straightforward.</p><pre><code class="language-julia">name_col = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;]</code></pre><p>As for the <em>employee</em> column, naively, we could store it as a vector of vectors.</p><pre><code class="language-julia">[[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]</code></pre><p>However, this representation loses the advantages of the column-oriented format since the data is no longer serialized with a fixed number of vectors. Instead, we should keep the column data in a tightly-packed vector of <em>elements</em>.</p><pre><code class="language-julia">employee_elts = [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;]</code></pre><p>This vector could be partitioned into separate blocks by the vector of <em>offsets</em>.</p><pre><code class="language-julia">employee_offs = [1, 3, 5, 7]</code></pre><p>Each pair of adjacent offsets corresponds a slice of the element vector.</p><pre><code class="language-julia">employee_elts[employee_offs[1]:employee_offs[2]-1]
#-&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]
employee_elts[employee_offs[2]:employee_offs[3]-1]
#-&gt; [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]
employee_elts[employee_offs[3]:employee_offs[4]-1]
#-&gt; [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]</code></pre><p>Together, elements and offsets faithfully reproduce the layout of the column. A pair of the offset and the element vectors is encapsulated with a <code>BlockVector</code> object, which represents a column-oriented encoding of a vector of variable-size blocks.</p><pre><code class="language-julia">employee_col = BlockVector(employee_offs, employee_elts)</code></pre><p>Now we can wrap the columns using <code>TupleVector</code>.</p><pre><code class="language-julia">TupleVector(:name =&gt; name_col, :employee =&gt; employee_col)</code></pre><p><code>@VectorTree</code> provides a convenient way to create <code>BlockVector</code> objects from regular vector literals.</p><pre><code class="language-julia">@VectorTree (name = String, employee = (0:N)String) [
    (name = &quot;POLICE&quot;, employee = [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]),
    (name = &quot;FIRE&quot;, employee = [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]),
    (name = &quot;OEMC&quot;, employee = [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]),
]</code></pre><h2 id="Optional-Values"><a class="docs-heading-anchor" href="#Optional-Values">Optional Values</a><a id="Optional-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Values" title="Permalink"></a></h2><p>As we arrange data in a tabular form, we may need to leave some cells blank.</p><p>For example, consider that a city employee could be compensated either with salary or with hourly pay.  To display the compensation data in a table, we add two columns: the annual salary and the hourly rate.  However, only one of the columns per each row is filled.</p><table><tr><th style="text-align: right">name</th><th style="text-align: right">position</th><th style="text-align: right">salary</th><th style="text-align: right">rate</th></tr><tr><td style="text-align: right">JEFFERY A</td><td style="text-align: right">SERGEANT</td><td style="text-align: right">101442</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">JAMES A</td><td style="text-align: right">FIRE ENGINEER-EMT</td><td style="text-align: right">103350</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">TERRY A</td><td style="text-align: right">POLICE OFFICER</td><td style="text-align: right">93354</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">LAKENYA A</td><td style="text-align: right">CROSSING GUARD</td><td style="text-align: right"></td><td style="text-align: right">17.68</td></tr></table><p>As in the previous section, the cells in this table may contain a variable number of values.  Therefore, the table columns could be represented using <code>BlockVector</code> objects.  We start with packing the column data as element vectors.</p><pre><code class="language-julia">salary_elts = [101442, 103350, 93354]
rate_elts = [17.68]</code></pre><p>Element vectors are partitioned into table cells by offset vectors.</p><pre><code class="language-julia">salary_offs = [1, 2, 3, 4, 4]
rate_offs = [1, 1, 1, 1, 2]</code></pre><p>The pairs of element and offset vectors are wrapped as <code>BlockVector</code> objects.</p><pre><code class="language-julia">salary_col = BlockVector(salary_offs, salary_elts, x0to1)
rate_col = BlockVector(rate_offs, rate_elts, x0to1)</code></pre><p>Here, the last parameter of the <code>BlockVector</code> constructor is the cardinality constraint on the size of the blocks.  The constraint <code>x0to1</code> indicates that each block should contain from 0 to 1 elements.  The default constraint <code>x0toN</code> does not restrict the block size.</p><p>The first two columns of the table do not contain empty cells, and therefore could be represented by regular vectors.  If we choose to wrap these columns with <code>BlockVector</code>, we should use the constraint <code>x1to1</code> to indicate that each block must contain exactly one element.  Alternatively, <code>BlockVector</code> provides the following shorthand notation.</p><pre><code class="language-julia">name_col = BlockVector(:, [&quot;JEFFERY A&quot;, &quot;JAMES A&quot;, &quot;TERRY A&quot;, &quot;LAKENYA A&quot;])
position_col = BlockVector(:, [&quot;SERGEANT&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;POLICE OFFICER&quot;, &quot;CROSSING GUARD&quot;])</code></pre><p>To represent the whole table, the columns should be wrapped with a <code>TupleVector</code>.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; name_col,
    :position =&gt; position_col,
    :salary =&gt; salary_col,
    :rate =&gt; rate_col)</code></pre><p>As usual, we could create this data from tuple and vector literals.</p><pre><code class="language-julia">@VectorTree (name = (1:1)String,
             position = (1:1)String,
             salary = (0:1)Int,
             rate = (0:1)Float64) [
    (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
    (name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
    (name = &quot;TERRY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 93354, rate = missing),
    (name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
]</code></pre><h2 id="Nested-Data"><a class="docs-heading-anchor" href="#Nested-Data">Nested Data</a><a id="Nested-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-Data" title="Permalink"></a></h2><p>When data does not fit a single table, it can often be presented in a top-down fashion.  For example, HR data can be seen as a collection of departments, each of which containing the associated employees.  Such data is serialized using <em>nested</em> data structures, which, in row-oriented format, may look as follows:</p><pre><code class="language-julia">[(name = &quot;POLICE&quot;,
  employee = [(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
              (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 80016, rate = missing)]),
 (name = &quot;FIRE&quot;,
  employee = [(name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
              (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;, salary = 95484, rate = missing)]),
 (name = &quot;OEMC&quot;,
  employee = [(name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
              (name = &quot;DORIS A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 19.38)])]</code></pre><p>To store this data in a column-oriented format, we should use nested <code>TupleVector</code> and <code>BlockVector</code> instances.  We start with representing employee data.</p><pre><code class="language-julia">employee_elts =
    TupleVector(
        :name =&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;],
        :position =&gt; [&quot;SERGEANT&quot;, &quot;POLICE OFFICER&quot;, &quot;FIRE ENGINEER-EMT&quot;, &quot;FIRE FIGHTER-EMT&quot;, &quot;CROSSING GUARD&quot;, &quot;CROSSING GUARD&quot;],
        :salary =&gt; BlockVector([1, 2, 3, 4, 5, 5, 5], [101442, 80016, 103350, 95484], x0to1),
        :rate =&gt; BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], x0to1))</code></pre><p>Then we partition employee data by departments:</p><pre><code class="language-julia">employee_col = BlockVector([1, 3, 5, 7], employee_elts)</code></pre><p>Adding a column of department names, we obtain HR data in a column-oriented format.</p><pre><code class="language-julia">TupleVector(
    :name =&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;],
    :employee =&gt; employee_col)</code></pre><p>Another way to assemble this data in column-oriented format is to use <code>@VectorTree</code>.</p><pre><code class="language-julia">@VectorTree (name = String,
             employee = [(name = String,
                          position = String,
                          salary = (0:1)Int,
                          rate = (0:1)Float64)]) [
    (name = &quot;POLICE&quot;,
     employee = [(name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;, salary = 101442, rate = missing),
                 (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;, salary = 80016, rate = missing)]),
    (name = &quot;FIRE&quot;,
     employee = [(name = &quot;JAMES A&quot;, position = &quot;FIRE ENGINEER-EMT&quot;, salary = 103350, rate = missing),
                 (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;, salary = 95484, rate = missing)]),
    (name = &quot;OEMC&quot;,
     employee = [(name = &quot;LAKENYA A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 17.68),
                 (name = &quot;DORIS A&quot;, position = &quot;CROSSING GUARD&quot;, salary = missing, rate = 19.38)])
]</code></pre><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataKnots.BlockVector" href="#DataKnots.BlockVector"><code>DataKnots.BlockVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlockVector(offs::AbstractVector{Int}, elts::AbstractVector, card::Cardinality=x0toN)
BlockVector(:, elts::AbstractVector, card::Cardinality=x1to1)</code></pre><p>Vector of data blocks stored as a vector of elements partitioned by a vector of offsets.</p><ul><li><code>elts</code> is a continuous vector of block elements.</li><li><code>offs</code> is a vector of indexes that subdivide <code>elts</code> into separate blocks. Should be monotonous with <code>offs[1] == 1</code> and <code>offs[end] == length(elts)+1</code>. Use <code>:</code> if the offset vector is a unit range.</li><li><code>card</code> is the cardinality constraint on the blocks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/2bdb55cab72bf85d3a7d5d498aab83fe6d42cc17/src/vectors.jl#L248-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Cardinality" href="#DataKnots.Cardinality"><code>DataKnots.Cardinality</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">x1to1::Cardinality
x0to1::Cardinality
x1toN::Cardinality
x0toN::Cardinality</code></pre><p>Cardinality constraints on a block of data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/2bdb55cab72bf85d3a7d5d498aab83fe6d42cc17/src/vectors.jl#L200-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.TupleVector" href="#DataKnots.TupleVector"><code>DataKnots.TupleVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TupleVector([lbls::Vector{Symbol},] len::Int, cols::Vector{AbstractVector})
TupleVector([lbls::Vector{Symbol},] idxs::AbstractVector{Int}, cols::Vector{AbstractVector})
TupleVector(lcols::Pair{&lt;:Union{Symbol,AbstractString},&lt;:AbstractVector}...)</code></pre><p>Vector of tuples stored as a collection of column vectors.</p><ul><li><code>cols</code> is a vector of columns; optional <code>lbls</code> is a vector of column labels. Alternatively, labels and columns could be provided as a list of pairs <code>lcols</code>.</li><li><code>len</code> is the vector length, which must coincide with the length of all the columns.  Alternatively, the vector could be constructed from a subset of the column data using a vector of indexes <code>idxs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/2bdb55cab72bf85d3a7d5d498aab83fe6d42cc17/src/vectors.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}" href="#Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(::BlockVector)[ks::AbstractVector{Int}] :: BlockVector</code></pre><p>Returns a new <code>BlockVector</code> with a selection of blocks specified by indexes <code>ks</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/2bdb55cab72bf85d3a7d5d498aab83fe6d42cc17/src/vectors.jl#L355-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}" href="#Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(::TupleVector)[ks::AbstractVector{Int}] :: TupleVector</code></pre><p>Returns a new <code>TupleVector</code> with a subset of rows specified by indexes <code>ks</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/2bdb55cab72bf85d3a7d5d498aab83fe6d42cc17/src/vectors.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.@VectorTree-Tuple{Any,Any}" href="#DataKnots.@VectorTree-Tuple{Any,Any}"><code>DataKnots.@VectorTree</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@VectorTree sig vec</code></pre><p>Constructs a tree of columnar vectors from a plain vector literal.</p><p>The first parameter, <code>sig</code>, describes the tree structure.  It is defined recursively:</p><ul><li>Julia type <code>T</code> indicates a regular vector of type <code>T</code>.</li><li>Tuple <code>(col₁, col₂, ...)</code> indicates a <code>TupleVector</code> instance.</li><li>Named tuple <code>(lbl₁ = col₁, lbl₂ = col₂, ...)</code> indicates a <code>TupleVector</code> instance with the given labels.</li><li>Prefixes <code>(0:N)</code>, <code>(1:N)</code>, <code>(0:1)</code>, <code>(1:1)</code> indicate a <code>BlockVector</code> instance with the respective cardinality constraints (no constraints, mandatory, singular, mandatory+singular).</li></ul><p>The second parameter, <code>vec</code>, is a vector literal in row-oriented format:</p><ul><li><code>TupleVector</code> data is specified either by a matrix or by a vector of (regular or named) tuples.</li><li><code>BlockVector</code> data is specified by a vector of vectors.  A one-element block could be represented by its element; an empty block by <code>missing</code> literal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/2bdb55cab72bf85d3a7d5d498aab83fe6d42cc17/src/vectors.jl#L526-L548">source</a></section></article><h2 id="Test-Suite"><a class="docs-heading-anchor" href="#Test-Suite">Test Suite</a><a id="Test-Suite-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Suite" title="Permalink"></a></h2><h3 id="TupleVector"><a class="docs-heading-anchor" href="#TupleVector"><code>TupleVector</code></a><a id="TupleVector-1"></a><a class="docs-heading-anchor-permalink" href="#TupleVector" title="Permalink"></a></h3><p><code>TupleVector</code> is a vector of tuples stored as a collection of parallel vectors.</p><pre><code class="language-julia">tv = TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;],
                 :salary =&gt; [260004, 185364, 170112])
#-&gt; @VectorTree (name = String, salary = Int64) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

display(tv)
#=&gt;
@VectorTree of 3 × (name = String, salary = Int64):
 (name = &quot;GARRY M&quot;, salary = 260004)
 (name = &quot;ANTHONY R&quot;, salary = 185364)
 (name = &quot;DANA A&quot;, salary = 170112)
=#</code></pre><p>Labels could be specified by strings.</p><pre><code class="language-julia">TupleVector(:salary =&gt; [260004, 185364, 170112], &quot;#B&quot; =&gt; [true, false, false])
#-&gt; @VectorTree (salary = Int64, &quot;#B&quot; = Bool) [(salary = 260004, #B = 1) … ]</code></pre><p>It is also possible to construct a <code>TupleVector</code> without labels.</p><pre><code class="language-julia">TupleVector(length(tv), columns(tv))
#-&gt; @VectorTree (String, Int64) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p>An error is reported in case of duplicate labels or columns of different height.</p><pre><code class="language-julia">TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :name =&gt; [&quot;DANA A&quot;, &quot;JUAN R&quot;])
#-&gt; ERROR: duplicate column label :name

TupleVector(:name =&gt; [&quot;GARRY M&quot;, &quot;ANTHONY R&quot;],
            :salary =&gt; [260004, 185364, 170112])
#-&gt; ERROR: unexpected column height</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">labels(tv)
#-&gt; [:name, :salary]

width(tv)
#-&gt; 2

column(tv, 2)
#-&gt; [260004, 185364, 170112]

column(tv, :salary)
#-&gt; [260004, 185364, 170112]

columns(tv)
#-&gt; …[[&quot;GARRY M&quot;, &quot;ANTHONY R&quot;, &quot;DANA A&quot;], [260004, 185364, 170112]]</code></pre><p>When indexed by another vector, we get a new instance of <code>TupleVector</code>.</p><pre><code class="language-julia">tv′ = tv[[3,1]]
display(tv′)
#=&gt;
@VectorTree of 2 × (name = String, salary = Int64):
 (name = &quot;DANA A&quot;, salary = 170112)
 (name = &quot;GARRY M&quot;, salary = 260004)
=#</code></pre><p>Note that the new instance wraps the index and the original column vectors. Updated column vectors are generated on demand.</p><pre><code class="language-julia">column(tv′, 2)
#-&gt; [170112, 260004]</code></pre><p>A labeled <code>TupleVector</code> supports a Tables.jl export interface.  For example, we can convert a <code>TupleVector</code> instance to a <code>DataFrame</code>.</p><pre><code class="language-julia">using DataFrames

tv |&gt; DataFrame |&gt; display
#=&gt;
3×2 DataFrame
│ Row │ name      │ salary │
│     │ String    │ Int64  │
├─────┼───────────┼────────┤
│ 1   │ GARRY M   │ 260004 │
│ 2   │ ANTHONY R │ 185364 │
│ 3   │ DANA A    │ 170112 │
=#</code></pre><h3 id="Cardinality"><a class="docs-heading-anchor" href="#Cardinality"><code>Cardinality</code></a><a id="Cardinality-1"></a><a class="docs-heading-anchor-permalink" href="#Cardinality" title="Permalink"></a></h3><p>Enumerated type <code>Cardinality</code> is used to constrain the cardinality of a data block.  There are four different cardinality constraints: <em>just one</em> <code>(1:1)</code>, <em>zero or one</em> <code>(0:1)</code>, <em>one or many</em> <code>(1:N)</code>, and <em>zero or many</em> <code>(0:N)</code>.</p><pre><code class="language-julia">display(Cardinality)
#=&gt;
Enum Cardinality:
x1to1 = 0x00
x0to1 = 0x01
x1toN = 0x02
x0toN = 0x03
=#</code></pre><p>Cardinality values could be obtained from the matching symbols.</p><pre><code class="language-julia">convert(Cardinality, :x1toN)
#-&gt; x1toN</code></pre><p>Cardinality values support bitwise operations.</p><pre><code class="language-julia">x1to1|x0to1|x1toN           #-&gt; x0toN
x1toN&amp;~x1toN                #-&gt; x1to1</code></pre><p>We can use predicates <code>ismandatory()</code> and <code>issingular()</code> to check if a constraint is present.</p><pre><code class="language-julia">ismandatory(x0to1)          #-&gt; false
ismandatory(x1toN)          #-&gt; true
issingular(x1toN)           #-&gt; false
issingular(x0to1)           #-&gt; true</code></pre><h3 id="BlockVector"><a class="docs-heading-anchor" href="#BlockVector"><code>BlockVector</code></a><a id="BlockVector-1"></a><a class="docs-heading-anchor-permalink" href="#BlockVector" title="Permalink"></a></h3><p><code>BlockVector</code> is a vector of homogeneous vectors (blocks) stored as a vector of elements partitioned into individual blocks by a vector of offsets.</p><pre><code class="language-julia">bv = BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;])
#-&gt; @VectorTree (0:N) × String [[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]

display(bv)
#=&gt;
@VectorTree of 3 × (0:N) × String:
 [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;]
 [&quot;JAMES A&quot;, &quot;DANIEL A&quot;]
 [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]
=#</code></pre><p>We can indicate that each block should contain at most one element or at least one element.</p><pre><code class="language-julia">BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], x0to1)
#-&gt; @VectorTree (0:1) × Float64 [missing, missing, missing, missing, 17.68, 19.38]

BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;], x1toN)
#-&gt; @VectorTree (1:N) × String [[&quot;JEFFERY A&quot;, &quot;NANCY A&quot;], [&quot;JAMES A&quot;, &quot;DANIEL A&quot;], [&quot;LAKENYA A&quot;, &quot;DORIS A&quot;]]</code></pre><p>If each block contains exactly one element, we could use <code>:</code> in place of the offset vector.</p><pre><code class="language-julia">BlockVector(:, [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;])
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;OEMC&quot;]</code></pre><p>The <code>BlockVector</code> constructor verifies that the offset vector is well-formed.</p><pre><code class="language-julia">BlockVector(Base.OneTo(0), [])
#-&gt; ERROR: offsets must be non-empty

BlockVector(Int[], [])
#-&gt; ERROR: offsets must be non-empty

BlockVector([0], [])
#-&gt; ERROR: offsets must start with 1

BlockVector([1,2,2,1], [&quot;HEALTH&quot;])
#-&gt; ERROR: offsets must be monotone

BlockVector(Base.OneTo(4), [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: offsets must enclose the elements

BlockVector([1,2,3,6], [&quot;HEALTH&quot;, &quot;FINANCE&quot;])
#-&gt; ERROR: offsets must enclose the elements</code></pre><p>The constructor also validates the cardinality constraint.</p><pre><code class="language-julia">BlockVector([1, 3, 5, 7], [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;], x0to1)
#-&gt; ERROR: singular blocks must have at most one element

BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], x1toN)
#-&gt; ERROR: mandatory blocks must have at least one element</code></pre><p>We can access individual components of the vector.</p><pre><code class="language-julia">offsets(bv)
#-&gt; [1, 3, 5, 7]

elements(bv)
#-&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;JAMES A&quot;, &quot;DANIEL A&quot;, &quot;LAKENYA A&quot;, &quot;DORIS A&quot;]

cardinality(bv)
#-&gt; x0toN</code></pre><p>When indexed by a vector of indexes, an instance of <code>BlockVector</code> is returned.</p><pre><code class="language-julia">elts = [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

reg_bv = BlockVector(:, elts)
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

opt_bv = BlockVector([1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7], elts, x0to1)
#-&gt; @VectorTree (0:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]

plu_bv = BlockVector([1, 1, 1, 2, 2, 4, 4, 6, 7], elts)
#-&gt; @VectorTree (0:N) × String [[], [], [&quot;POLICE&quot;], [], [&quot;FIRE&quot;, &quot;HEALTH&quot;], [], [&quot;AVIATION&quot;, &quot;WATER MGMNT&quot;], [&quot;FINANCE&quot;]]

reg_bv[[1,3,5,3]]
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;HEALTH&quot;, &quot;WATER MGMNT&quot;, &quot;HEALTH&quot;]

plu_bv[[1,3,5,3]]
#-&gt; @VectorTree (0:N) × String [[], [&quot;POLICE&quot;], [&quot;FIRE&quot;, &quot;HEALTH&quot;], [&quot;POLICE&quot;]]

reg_bv[Base.OneTo(4)]
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;]

reg_bv[Base.OneTo(6)]
#-&gt; @VectorTree (1:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, &quot;HEALTH&quot;, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, &quot;FINANCE&quot;]

plu_bv[Base.OneTo(6)]
#-&gt; @VectorTree (0:N) × String [[], [], [&quot;POLICE&quot;], [], [&quot;FIRE&quot;, &quot;HEALTH&quot;], []]

opt_bv[Base.OneTo(10)]
#-&gt; @VectorTree (0:1) × String [&quot;POLICE&quot;, &quot;FIRE&quot;, missing, &quot;HEALTH&quot;, missing, &quot;AVIATION&quot;, &quot;WATER MGMNT&quot;, missing, missing, &quot;FINANCE&quot;]</code></pre><h3 id="@VectorTree"><a class="docs-heading-anchor" href="#@VectorTree"><code>@VectorTree</code></a><a id="@VectorTree-1"></a><a class="docs-heading-anchor-permalink" href="#@VectorTree" title="Permalink"></a></h3><p>We can use <code>@VectorTree</code> macro to convert vector literals to the columnar form assembled with <code>TupleVector</code> and <code>BlockVector</code> objects.</p><p><code>TupleVector</code> is created from a matrix or a vector of (named) tuples.</p><pre><code class="language-julia">@VectorTree (name = String, salary = Int) [
    &quot;GARRY M&quot;   260004
    &quot;ANTHONY R&quot; 185364
    &quot;DANA A&quot;    170112
]
#-&gt; @VectorTree (name = String, salary = Int64) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (&quot;GARRY M&quot;, 260004),
    (&quot;ANTHONY R&quot;, 185364),
    (&quot;DANA A&quot;, 170112),
]
#-&gt; @VectorTree (name = String, salary = Int64) [(name = &quot;GARRY M&quot;, salary = 260004) … ]

@VectorTree (name = String, salary = Int) [
    (name = &quot;GARRY M&quot;, salary = 260004),
    (name = &quot;ANTHONY R&quot;, salary = 185364),
    (name = &quot;DANA A&quot;, salary = 170112),
]
#-&gt; @VectorTree (name = String, salary = Int64) [(name = &quot;GARRY M&quot;, salary = 260004) … ]</code></pre><p>Column labels are optional.</p><pre><code class="language-julia">@VectorTree (String, Int) [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
#-&gt; @VectorTree (String, Int64) [(&quot;GARRY M&quot;, 260004) … ]</code></pre><p><code>BlockVector</code> is constructed from a vector of vector literals.  A one-element block could be represented by the element itself; an empty block by <code>missing</code>.</p><pre><code class="language-julia">@VectorTree [String] [
    &quot;HEALTH&quot;,
    [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;],
    missing,
    [&quot;POLICE&quot;, &quot;FIRE&quot;],
]
#-&gt; @VectorTree (0:N) × String [[&quot;HEALTH&quot;], [&quot;FINANCE&quot;, &quot;HUMAN RESOURCES&quot;], [], [&quot;POLICE&quot;, &quot;FIRE&quot;]]</code></pre><p>Ill-formed <code>@VectorTree</code> constructors are rejected.</p><pre><code class="language-julia">@VectorTree &quot;String&quot; [&quot;POLICE&quot;, &quot;FIRE&quot;]
#=&gt;
ERROR: expected a type; got &quot;String&quot;
=#

@VectorTree (String, Int) (&quot;GARRY M&quot;, 260004)
#=&gt;
ERROR: LoadError: expected a vector literal; got :((&quot;GARRY M&quot;, 260004))
⋮
=#

@VectorTree (String, Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected no label; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(position = &quot;SUPERINTENDENT OF POLICE&quot;, salary = 260004)]
#=&gt;
ERROR: LoadError: expected label :name; got :(position = &quot;SUPERINTENDENT OF POLICE&quot;)
⋮
=#

@VectorTree (name = String, salary = Int) [(&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004)]
#=&gt;
ERROR: LoadError: expected 2 column(s); got :((&quot;GARRY M&quot;, &quot;SUPERINTENDENT OF POLICE&quot;, 260004))
⋮
=#

@VectorTree (name = String, salary = Int) [&quot;GARRY M&quot;]
#=&gt;
ERROR: LoadError: expected a tuple or a row literal; got &quot;GARRY M&quot;
⋮
=#</code></pre><p>Using <code>@VectorTree</code>, we can easily construct hierarchical data.</p><pre><code class="language-julia">hier_data = @VectorTree (name = (1:1)String, employee = (0:N)(name = (1:1)String, salary = (0:1)Int)) [
    &quot;POLICE&quot;    [&quot;GARRY M&quot; 260004; &quot;ANTHONY R&quot; 185364; &quot;DANA A&quot; 170112]
    &quot;FIRE&quot;      [&quot;JOSE S&quot; 202728; &quot;CHARLES S&quot; 197736]
]
display(hier_data)
#=&gt;
@VectorTree of 2 × (name = (1:1) × String,
                    employee = (0:N) × (name = (1:1) × String,
                                        salary = (0:1) × Int64)):
 (name = &quot;POLICE&quot;, employee = [(name = &quot;GARRY M&quot;, salary = 260004) … ])
 (name = &quot;FIRE&quot;, employee = [(name = &quot;JOSE S&quot;, salary = 202728) … ])
=#</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« Reference</a><a class="docs-footer-nextpage" href="../pipelines/">Pipeline Algebra »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 9 July 2020 06:14">Thursday 9 July 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
