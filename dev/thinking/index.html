<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Thinking in Combinators · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../tutorial/">DataKnots Tutorial</a></li><li class="current"><a class="toctext" href>Thinking in Combinators</a><ul class="internal"><li><a class="toctext" href="#Constructing-Queries-1">Constructing Queries</a></li><li><a class="toctext" href="#Query-Combinators-1">Query Combinators</a></li><li><a class="toctext" href="#Structuring-Data-1">Structuring Data</a></li><li><a class="toctext" href="#Working-With-Data-1">Working With Data</a></li><li><a class="toctext" href="#Quirks-and-Hints-1">Quirks &amp; Hints</a></li></ul></li><li><a class="toctext" href="../reference/">Reference</a></li><li><a class="toctext" href="../implementation/">Implementation Notes</a></li><li><a class="toctext" href="../simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Thinking in Combinators</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/thinking.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Thinking in Combinators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Thinking-in-Combinators-1" href="#Thinking-in-Combinators-1">Thinking in Combinators</a></h1><p>DataKnots is a Julia library for building database queries. In DataKnots, queries are assembled algebraically: they either come from a set of atomic <em>primitives</em> or are built from other queries using <em>combinators</em>. In this conceptual guide, we show how to build queries starting from smaller components and then combining them algebraically to implement complex processing tasks.</p><p>To start working with DataKnots, we import the package:</p><pre><code class="language-julia">using DataKnots</code></pre><h2><a class="nav-anchor" id="Constructing-Queries-1" href="#Constructing-Queries-1">Constructing Queries</a></h2><p>A <code>DataKnot</code>, or just <em>knot</em>, is a container having structured, vectorized data.</p><p>For this guide, we&#39;ll use a trivial knot, <code>void</code> as our data source. The <code>void</code> knot encapsulates the value <code>nothing</code>, which will serve as the input for our queries.</p><pre><code class="language-julia">void = DataKnot(nothing)
#=&gt;
│ It │
┼────┼
│    │
=#</code></pre><h3><a class="nav-anchor" id="Constant-Queries-1" href="#Constant-Queries-1">Constant Queries</a></h3><p>Any Julia value could be converted to a <em>query</em> using the <code>Lift</code> constructor. Queries constructed this way are constant: for each input element they receive, they output the given value. Consider the query <code>Hello</code>, lifted from the string value <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">Hello = Lift(&quot;Hello World&quot;)</code></pre><p>To query <code>void</code> with <code>Hello</code>, we use indexing notation <code>void[Hello]</code>. In this case, <code>Hello</code> receives <code>nothing</code> from <code>void</code> and produces the value, <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">void[Hello]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>A <code>Tuple</code> lifted to a constant query is displayed as a table.</p><pre><code class="language-julia">void[Lift((name=&quot;DataKnots&quot;, version=&quot;0.1&quot;))]
#=&gt;
│ name       version │
┼────────────────────┼
│ DataKnots  0.1     │
=#</code></pre><p>A <code>Vector</code> lifted to a constant query will produce plural output.</p><pre><code class="language-julia">void[Lift(&#39;a&#39;:&#39;c&#39;)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p>We call queries constructed this way <em>primitives</em>, as they do not rely upon any other query. There are also combinators, which build new queries from existing ones.</p><h3><a class="nav-anchor" id="Composition-and-Identity-1" href="#Composition-and-Identity-1">Composition &amp; Identity</a></h3><p>Two queries can be connected sequentially using the <em>composition</em> combinator (<code>&gt;&gt;</code>). Consider the composition <code>Lift(1:3) &gt;&gt; Hello</code>. Since <code>Hello</code> produces a value for each input element, preceding it with <code>Lift(1:3)</code> generates three copies of <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; Hello]
#=&gt;
  │ It          │
──┼─────────────┼
1 │ Hello World │
2 │ Hello World │
3 │ Hello World │
=#</code></pre><p>If we compose two plural queries, <code>Lift(1:2)</code> and <code>Lift(&#39;a&#39;:&#39;c&#39;)</code>, the output will contain the elements of <code>&#39;a&#39;:&#39;c&#39;</code> repeated twice.</p><pre><code class="language-julia">void[Lift(1:2) &gt;&gt; Lift(&#39;a&#39;:&#39;c&#39;)]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>The <em>identity</em> with respect to query composition is called <code>It</code>. This primitive can be composed with any query without changing the query&#39;s output.</p><pre><code class="language-julia">void[Hello &gt;&gt; It]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>The identity primitive, <code>It</code>, can be used to construct queries which rely upon the output from previous processing.</p><pre><code class="language-julia">Increment = It .+ 1
void[Lift(1:3) &gt;&gt; Increment]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  3 │
3 │  4 │
=#</code></pre><p>In DataKnots, queries are built algebraically, starting with query primitives, such as constants (<code>Lift</code>) or the identity (<code>It</code>), and then arranged with with combinators, such as composition (<code>&gt;&gt;</code>). This lets us define sophisticated query components and remix them in creative ways.</p><h3><a class="nav-anchor" id="Lifting-Functions-1" href="#Lifting-Functions-1">Lifting Functions</a></h3><p>Any function could be integrated into a DataKnots query. Consider the function <code>double(x)</code> that, when applied to a <code>Number</code>, produces a <code>Number</code>:</p><pre><code class="language-julia">double(x) = 2x
double(3) #-&gt; 6</code></pre><p>What we want is an analogue to <code>double</code> which, instead of operating on numbers, operates on queries. Such functions are called query <em>combinators</em>. We can convert any function to a combinator by passing the function and its arguments to <code>Lift</code>.</p><pre><code class="language-julia">Double(X) = Lift(double, (X,))</code></pre><p>In this case, <code>double</code> expects a scalar value. Therefore, for a query <code>X</code>, the combinator <code>Double(X)</code> evaluates <code>X</code> and then runs each output element though <code>double</code>. Thus, the query <code>Double(It)</code> would simply double its input.</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; Double(It)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  4 │
3 │  6 │
=#</code></pre><p>Broadcasting a function over a query argument performs a <code>Lift</code> implicitly, building a query component.</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; double.(It)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  4 │
3 │  6 │
=#</code></pre><p>Any existing function could be broadcast this way. For example, we could broadcast <code>getfield</code> to get a field value from a tuple.</p><pre><code class="language-julia">void[Lift((x=1,y=2)) &gt;&gt; getfield.(It, :y)]
#=&gt;
│ It │
┼────┼
│  2 │
=#</code></pre><p>Getting a field value is common enough to have its own notation, properties of <code>It</code>, such as <code>It.y</code>, are used for field access.</p><pre><code class="language-julia">void[Lift((x=1,y=2)) &gt;&gt; It.y]
#=&gt;
│ y │
┼───┼
│ 2 │
=#</code></pre><p>Implicit lifting also applies to built-in Julia operators (<code>+</code>) and values (<code>1</code>). The expression <code>It .+ 1</code> is a query component that increments each of its input elements.</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; (It .+ 1)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  3 │
3 │  4 │
=#</code></pre><p>In Julia, broadcasting lets the function&#39;s arguments control how the function is applied. When a function is broadcasted over queries, the result is a query. However, to make sure it works, we need to ensure that at least one argument is a query, and we can do this by wrapping at least one argument with <code>Lift</code>.</p><pre><code class="language-julia">OneTo(N) = UnitRange.(1, Lift(N))</code></pre><p>Note that the unit range constructor is vector-valued. Therefore, the resulting combinator builds queries with plural output.</p><pre><code class="language-julia">void[OneTo(3)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  2 │
3 │  3 │
=#</code></pre><p>This automated lifting lets us access rich statistical and data processing functions from within our queries.</p><h3><a class="nav-anchor" id="Cardinality-1" href="#Cardinality-1">Cardinality</a></h3><p>We have seen that queries produce any number of output rows: <code>Lift(1:3)</code> produces <code>3</code> rows and <code>Lift(&quot;Hello World&quot;)</code> produces exactly one row. Further, the value <code>missing</code>, lifted to a constant query, never produces any rows.</p><pre><code class="language-julia">void[Lift(missing)]
#=&gt;
│ It │
┼────┼
=#</code></pre><p>The constraint on the number of output rows a query may produce is called its <em>cardinality</em>. A query is <em>mandatory</em> if its output must contain at least one row. It is <em>singular</em> if its output must contain at most one row.</p><table><tr><th>Example</th><th>Data Type</th><th>Singular</th><th>Mandatory</th><th>Cardinality</th></tr><tr><td><code>Lift(&quot;Hello&quot;)</code></td><td><em>scalar</em></td><td>Yes</td><td>Yes</td><td>:x1to1</td></tr><tr><td><code>Lift(missing)</code></td><td><code>Missing</code></td><td>Yes</td><td>No</td><td>:x0to1</td></tr><tr><td><code>Lift(&#39;a&#39;:&#39;c&#39;)</code></td><td><code>Vector</code></td><td>No</td><td>No</td><td>:x0toN</td></tr><tr><td>``</td><td></td><td>No</td><td>Yes</td><td>:x1toN</td></tr></table><p>The last permutation in this chart, mandatory yet not singular, does not have a corresponding Julia type. However, data with this <code>:x1toN</code> cardinality could be created as a <code>DataKnot</code> and then lifted to a constant query.</p><pre><code class="language-julia">one_or_more = DataKnot(&#39;A&#39;:&#39;B&#39;, :x1toN)

void[Lift(one_or_more)]
#=&gt;
  │ It │
──┼────┼
1 │ A  │
2 │ B  │
=#</code></pre><h2><a class="nav-anchor" id="Query-Combinators-1" href="#Query-Combinators-1">Query Combinators</a></h2><p>There are query operations which cannot be lifted from Julia functions. We&#39;ve met a few already, including the identity (<code>It</code>) and query composition (<code>&gt;&gt;</code>). There are many others involving aggregation, filtering, and paging.</p><h3><a class="nav-anchor" id="Aggregate-Queries-1" href="#Aggregate-Queries-1">Aggregate Queries</a></h3><p>So far queries have been <em>elementwise</em>; that is, for each input element, they produce zero or more output elements. Consider the <code>Count</code> primitive; it returns the number of its input elements.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; Count]
#=&gt;
│ It │
┼────┼
│  3 │
=#</code></pre><p>An <em>aggregate</em> query such as <code>Count</code> is computed over the input as a whole, and not for each individual element. The semantics of aggregates require discussion. Consider <code>OneTo(3) &gt;&gt; OneTo(It)</code>.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; OneTo(It)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  1 │
3 │  2 │
4 │  1 │
5 │  2 │
6 │  3 │
=#</code></pre><p>By appending <code>&gt;&gt; Sum</code> we could aggregate the entire input flow, producing a single output element.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; OneTo(It) &gt;&gt; Sum]
#=&gt;
│ It │
┼────┼
│ 10 │
=#</code></pre><p>What if we wanted to produce sums by the outer query, <code>OneTo(3)</code>? Since query composition (<code>&gt;&gt;</code>) is associative, adding parenthesis around <code>OneTo(It) &gt;&gt; Sum</code> will not change the result.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; (OneTo(It) &gt;&gt; Sum)]
#=&gt;
│ It │
┼────┼
│ 10 │
=#</code></pre><p>We need the <code>Each</code> combinator, which acts as an elementwise <em>barrier</em>. For each input element, <code>Each</code> evaluates its argument, and then collects the outputs.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; Each(OneTo(It) &gt;&gt; Sum)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  3 │
3 │  6 │
=#</code></pre><p>Following is an equivalent query, using the <code>Sum</code> combinator. Here, <code>Sum(X)</code> produces the same output as <code>Each(X &gt;&gt; Sum)</code>. Although <code>Sum(X)</code> performs numerical aggregation, it is not an aggregate query since its input is treated elementwise.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; Sum(OneTo(It))]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  3 │
3 │  6 │
=#</code></pre><p>Julia functions taking a vector argument, such as <code>mean</code>, can be lifted to a combinator taking a plural query. When performed, the plural output is converted into the function&#39;s vector argument.</p><pre><code class="language-julia">using Statistics
Mean(X) = mean.(X)
void[Mean(OneTo(3) &gt;&gt; Sum(OneTo(It)))]
#=&gt;
│ It      │
┼─────────┼
│ 3.33333 │
=#</code></pre><p>To use <code>Mean</code> as a query primitive, we use <code>Then</code> to build a query that aggregates elements from its input. Next, we register this query so it is used when <code>Mean</code> is treated as a query.</p><pre><code class="language-julia">DataKnots.Lift(::typeof(Mean)) = DataKnots.Then(Mean)</code></pre><p>Once these are done, one could take an average of sums as follows:</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; Sum(OneTo(It)) &gt;&gt; Mean]
#=&gt;
│ It      │
┼─────────┼
│ 3.33333 │
=#</code></pre><p>In DataKnots, summary operations are expressed as aggregate query primitives or as query combinators taking a plural query argument. Moreover, custom aggregates can be constructed from native Julia functions and lifted into the query algebra.</p><h3><a class="nav-anchor" id="Filtering-1" href="#Filtering-1">Filtering</a></h3><p>The <code>Filter</code> combinator has one parameter, a predicate query that, for each input element, decides if this element should be included in the output.</p><pre><code class="language-julia">void[OneTo(6) &gt;&gt; Filter(It .&gt; 3)]
#=&gt;
  │ It │
──┼────┼
1 │  4 │
2 │  5 │
3 │  6 │
=#</code></pre><p>Being a combinator, <code>Filter</code> builds a query component, which could then be composed with any data generating query.</p><pre><code class="language-julia">KeepEven = Filter(iseven.(It))
void[OneTo(6) &gt;&gt; KeepEven]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  4 │
3 │  6 │
=#</code></pre><p>Filter can work in a nested context.</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; Filter(Sum(OneTo(It)) .&gt; 5)]
#=&gt;
  │ It │
──┼────┼
1 │  3 │
=#</code></pre><p>The <code>Filter</code> combinator is elementwise. Furthermore, the predicate argument is evaluated for each input element. If the predicate evaluation is <code>true</code> for a given element, then that element is reproduced, otherwise it is discarded.</p><h3><a class="nav-anchor" id="Paging-Data-1" href="#Paging-Data-1">Paging Data</a></h3><p>Like <code>Filter</code>, the <code>Take</code> and <code>Drop</code> combinators can be used to choose elements from an input: <code>Drop</code> is used to skip over input, while <code>Take</code> ignores input past a particular point.</p><pre><code class="language-julia">void[OneTo(9) &gt;&gt; Drop(3) &gt;&gt; Take(3)]
#=&gt;
  │ It │
──┼────┼
1 │  4 │
2 │  5 │
3 │  6 │
=#</code></pre><p>Unlike <code>Filter</code>, which evaluates its argument for each element, the argument to <code>Take</code> is evaluated once, in the context of the input&#39;s <em>source</em>.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; Each(Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Take(It))]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ a  │
3 │ b  │
4 │ a  │
5 │ b  │
6 │ c  │
=#</code></pre><p>In this example, the argument of <code>Take</code> evaluates in the context of <code>OneTo(3)</code>. Therefore, <code>Take</code> will be performed three times, where <code>It</code> has the values <code>1</code>, <code>2</code>, and <code>3</code>.</p><h3><a class="nav-anchor" id="Processing-Model-1" href="#Processing-Model-1">Processing Model</a></h3><p>DataKnots processing model has three levels.</p><ul><li>Combinators build queries.</li><li>Queries extend pipelines.</li><li>Pipelines process data.</li></ul><p>In particular, queries don&#39;t process data, they are blueprints for assembling pipeline extensions. Pipelines then do processing.</p><p>Every pipeline has two endpoints, a <em>source</em> and a <em>target</em>, such that each data element that enters at the source is processed to produce zero or more target elements.</p><p>Combinators, which take queries as arguments and build an output query, have a choice for what to use for each of its arguments&#39; starting pipeline. For query composition, the starting pipeline for its 1st argument is the input pipeline and the starting pipeline for the 2nd argument is the output pipeline of the 1st.</p><p>For <code>Filter</code> and other elementwise combinators, the argument queries get a starting pipeline which treats each target element individually. In in this way, they are evaluated locally, without consideration of a broader context.</p><p>For <code>Take</code> and other aggregate combinators, the arguments (if any) could only have a starting pipeline constructed from the input&#39;s source. This is advantageous since it lets the aggregate&#39;s argument inspect the broader context in which it is used.</p><p>We&#39;ve seen significant variation of processing approach among the queries we&#39;ve built thus far.</p><p>|               |             | Output      | Argument | | Query         | Input Model | Cardinality | Context  | |–––––––-|––––––-|––––––-|–––––| | <code>Lift(1:3)</code>   | Elementwise | <code>:x0toN</code>    |          | | <code>Count</code>       | Aggregate   | <code>:x1to1</code>    |          | | <code>Count(...)</code>  | Elementwise | <code>:x1to1</code>    | Target   | | <code>Filter(...)</code> | Elementwise | <code>:x0to1</code>    | Target   | | <code>Take(3)</code>     | Aggregate   | <code>:x0toN</code>    | Source   |</p><p>In DataKnots, how combinators construct their queries is given significant flexibility, with a simple interface for the queries themselves: they have an input and output pipeline. Each pipeline can be connected on both sides, the source, the target, or both.</p><h2><a class="nav-anchor" id="Structuring-Data-1" href="#Structuring-Data-1">Structuring Data</a></h2><p>Thus far we&#39;ve seen how queries can be composed in heavily nested environments. DataKnots also supports nested data and contexts.</p><h3><a class="nav-anchor" id="Records-and-Labels-1" href="#Records-and-Labels-1">Records &amp; Labels</a></h3><p>Data objects can be created using the <code>Record</code> combinator. Values can be labeled using Julia&#39;s <code>Pair</code> syntax. The entire result as a whole may also be named.</p><pre><code class="language-julia">GM = Record(:name =&gt; &quot;GARRY M&quot;, :salary =&gt; 260004)
void[GM]
#=&gt;
│ name     salary │
┼─────────────────┼
│ GARRY M  260004 │
=#</code></pre><p>Field access is possible via <code>Get</code> query constructor, which takes a label&#39;s name. Here <code>Get(:name)</code> is an elementwise query that returns the value of a given label when found.</p><pre><code class="language-julia">void[GM &gt;&gt; Get(:name)]
#=&gt;
│ name    │
┼─────────┼
│ GARRY M │
=#</code></pre><p>For syntactic convenience, <code>It</code> can be used for dotted access.</p><pre><code class="language-julia">void[GM &gt;&gt; It.name]
#=&gt;
│ name    │
┼─────────┼
│ GARRY M │
=#</code></pre><p>The <code>Label</code> combinator provides a name to any expression.</p><pre><code class="language-julia">void[Lift(&quot;Hello World&quot;) &gt;&gt; Label(:greeting)]
#=&gt;
│ greeting    │
┼─────────────┼
│ Hello World │
=#</code></pre><p>Alternatively, Julia&#39;s pair constructor (<code>=&gt;</code>) and and a <code>Symbol</code> denoted by a colon (<code>:</code>) can be used to label an expression.</p><pre><code class="language-julia">Hello =
  :greeting =&gt; Lift(&quot;Hello World&quot;)

void[Hello]
#=&gt;
│ greeting    │
┼─────────────┼
│ Hello World │
=#</code></pre><p>Records can be plural. Here is a table of obvious statistics.</p><pre><code class="language-julia">Stats = Record(:n¹=&gt;It, :n²=&gt;It.*It, :n³=&gt;It.*It.*It)
void[Lift(1:3) &gt;&gt; Stats]
#=&gt;
  │ n¹  n²  n³ │
──┼────────────┼
1 │  1   1   1 │
2 │  2   4   8 │
3 │  3   9  27 │
=#</code></pre><p>By accessing names, calculations can be performed on records.</p><pre><code class="language-julia">void[Lift(1:3) &gt;&gt; Stats &gt;&gt; (It.n¹ .+ It.n² .+ It.n³)]
#=&gt;
  │ It │
──┼────┼
1 │  3 │
2 │ 14 │
3 │ 39 │
=#</code></pre><p>Using records, it is possible to represent complex, hierarchical data. It is then possible to access and compute with this data.</p><h3><a class="nav-anchor" id="Query-Parameters-1" href="#Query-Parameters-1">Query Parameters</a></h3><p>With DataKnots, parameters can be provided so that static data can be used within query expressions. By convention, we use upper case, singular labels for query parameters.</p><pre><code class="language-julia">void[&quot;Hello &quot; .* Get(:WHO), WHO=&quot;World&quot;]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>To make <code>Get</code> convenient, <code>It</code> provides a shorthand syntax.</p><pre><code class="language-julia">void[&quot;Hello &quot; .* It.WHO, WHO=&quot;World&quot;]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>Query parameters are available anywhere in the query. They could, for example be used within a filter.</p><pre><code class="language-julia">query = OneTo(6) &gt;&gt; Filter(It .&gt; It.START)
void[query, START=3]
#=&gt;
  │ It │
──┼────┼
1 │  4 │
2 │  5 │
3 │  6 │
=#</code></pre><p>Parameters can also be defined as part of a query using <code>Given</code>. This combinator takes set of pairs (<code>=&gt;</code>) that map symbols (<code>:name</code>) onto query expressions. The subsequent argument is then evaluated in a naming context where the defined parameters are available for reuse.</p><pre><code class="language-julia">void[Given(:WHO =&gt; &quot;World&quot;, &quot;Hello &quot; .* Get(:WHO))]
#=&gt;
│ It          │
┼─────────────┼
│ Hello World │
=#</code></pre><p>Query parameters can be especially useful when managing aggregates, or with expressions that one may wish to repeat more than once.</p><pre><code class="language-julia">GreaterThanAverage(X) =
  Given(:AVG =&gt; Mean(X),
        X &gt;&gt; Filter(It .&gt; Get(:AVG)))

void[GreaterThanAverage(OneTo(6))]
#=&gt;
  │ It │
──┼────┼
1 │  4 │
2 │  5 │
3 │  6 │
=#</code></pre><p>In DataKnots, query parameters permit external data to be used within query expressions. Parameters that are defined with <code>Given</code> can be used to remember values and reuse them.</p><h2><a class="nav-anchor" id="Working-With-Data-1" href="#Working-With-Data-1">Working With Data</a></h2><p>Arrays of named tuples can be wrapped with <code>Lift</code> in order to provide a series of tuples. Since DataKnots works fluidly with Julia, any sort of Julia object may be used. In this case, <code>NamedTuple</code> has special support so that it prints well.</p><pre><code class="language-julia">DATA = Lift([(name = &quot;GARRY M&quot;, salary = 260004),
              (name = &quot;ANTHONY R&quot;, salary = 185364),
              (name = &quot;DANA A&quot;, salary = 170112)])

void[:staff =&gt; DATA]
#=&gt;
  │ staff             │
  │ name       salary │
──┼───────────────────┼
1 │ GARRY M    260004 │
2 │ ANTHONY R  185364 │
3 │ DANA A     170112 │
=#</code></pre><p>Access to slots in a <code>NamedTuple</code> is also supported by <code>Get</code>.</p><pre><code class="language-julia">void[DATA &gt;&gt; Get(:name)]
#=&gt;
  │ name      │
──┼───────────┼
1 │ GARRY M   │
2 │ ANTHONY R │
3 │ DANA A    │
=#</code></pre><p>Together with previous combinators, DataKnots could be used to create readable queries, such as &quot;who has the greatest salary&quot;?</p><pre><code class="language-julia">void[:highest_salary =&gt;
  Given(:MAX =&gt; Max(DATA &gt;&gt; It.salary),
        DATA &gt;&gt; Filter(It.salary .== Get(:MAX)))]
#=&gt;
  │ highest_salary  │
  │ name     salary │
──┼─────────────────┼
1 │ GARRY M  260004 │
=#</code></pre><p>Records can even contain lists of subordinate records.</p><pre><code class="language-julia">DB =
  void[:department =&gt;
    Record(:name =&gt; &quot;FIRE&quot;, :staff =&gt; It.FIRE),
    FIRE=[(name = &quot;JOSE S&quot;, salary = 202728),
          (name = &quot;CHARLES S&quot;, salary = 197736)]]
#=&gt;
│ department                              │
│ name  staff                             │
┼─────────────────────────────────────────┼
│ FIRE  JOSE S, 202728; CHARLES S, 197736 │
=#</code></pre><p>These subordinate records can then be summarized.</p><pre><code class="language-julia">void[:statistics =&gt;
  DB &gt;&gt; Record(:dept =&gt; It.name,
               :count =&gt; Count(It.staff))]
#=&gt;
│ statistics  │
│ dept  count │
┼─────────────┼
│ FIRE      2 │
=#</code></pre><h2><a class="nav-anchor" id="Quirks-and-Hints-1" href="#Quirks-and-Hints-1">Quirks &amp; Hints</a></h2><p>By <em>quirks</em> we mean perhaps unexpected consequences of embedding DataKnots in Julia or deviations from how other languages work. They are not necessarily bugs, nor could they be easily fixed.</p><p>The query <code>Count</code> is not the same as the query <code>Count(It)</code>. The former is an aggregate that consumes its entire input, the latter is an elementwise query that considers one input a time. Since it could only receive one input element at a time, <code>Count(It)</code> is always <code>1</code>. This is clearly less than ideal.</p><pre><code class="language-julia">void[OneTo(3) &gt;&gt; Count(It)]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  1 │
3 │  1 │
=#</code></pre><p>The <code>Count</code> aggregate only considers the number of elements in the input. It does not check for values that are truthy.</p><pre><code class="language-julia">void[OneTo(5) &gt;&gt; iseven.(It) &gt;&gt; Count]
#=&gt;
│ It │
┼────┼
│  5 │
=#

void[OneTo(5) &gt;&gt; Filter(iseven.(It)) &gt;&gt; Count]
#=&gt;
│ It │
┼────┼
│  2 │
=#</code></pre><p>Using the broadcast syntax to lift combinators is clever, but it doesn&#39;t always work out. If an argument to the broadcast isn&#39;t a <code>Query</code> then a regular broadcast will happen. For example, <code>rand.(1:3)</code> is an array of arrays containing random numbers. Wrapping an argument in <code>Lift</code> will address this challenge.</p><pre><code class="language-julia">using Random: seed!, rand
seed!(0)
void[Lift(1:3) &gt;&gt; rand.(Lift(7:9))]
#=&gt;
  │ It │
──┼────┼
1 │  7 │
2 │  9 │
3 │  8 │
=#</code></pre><footer><hr/><a class="previous" href="../tutorial/"><span class="direction">Previous</span><span class="title">DataKnots Tutorial</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
