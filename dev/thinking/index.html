<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Thinking in DataKnots · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../install/">Installation Instructions</a></li><li class="current"><a class="toctext" href>Thinking in DataKnots</a><ul class="internal"><li><a class="toctext" href="#Constant-Combinators-1">Constant Combinators</a></li><li><a class="toctext" href="#Lifting-Functions-to-Combinators-1">Lifting Functions to Combinators</a></li></ul></li><li><a class="toctext" href="../usage/">Usage Guide</a></li><li><a class="toctext" href="../implementation/">Implementation Guide</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Thinking in DataKnots</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/thinking.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Thinking in DataKnots</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Thinking-in-DataKnots-1" href="#Thinking-in-DataKnots-1">Thinking in DataKnots</a></h1><p>In this introduction, we describe DataKnots as a language-embedded library used for vectorized computation, rather than as a user-oriented database query language. In this library, each <code>DataKnot</code> is a container holding structured, often interrelated, vectorized data. Each <code>Combinator</code> is variable-free algebraic expression that specifies how to transform one DataKnot to another.</p><p>To start working with DataKnots, we import the package:</p><pre><code class="language-julia">using DataKnots</code></pre><h2><a class="nav-anchor" id="Constant-Combinators-1" href="#Constant-Combinators-1">Constant Combinators</a></h2><p>The DataKnots approach to computation is once indirect. One doesn&#39;t combine data transformation functions directly, instead one expresses the query with combinators.  These combinators are then converted into lower-level data manipulation functions. In fact, constant expressions are also seen as combinators, converted to functions that produce the same output no matter what the input.</p><p>To explain, let&#39;s consider an example combinator query that produces a <code>DataKnot</code> containing a singular string value, <code>&quot;Hello World&quot;</code>. </p><pre><code class="language-julia">query(&quot;Hello World&quot;)</code></pre><p>This example can be rewritten to show how <code>&quot;Hello World&quot;</code> is implicitly converted into its <code>Combinator</code> namesake. Hence, the <code>query()</code> argument is not a constant value at all, but rather an combinator expression which convert to a function that produces a constant value,  <code>&quot;Hello World&quot;</code> for each of its inputs.</p><pre><code class="language-julia">query(Combinator(&quot;Hello World&quot;))</code></pre><p>But, if <code>&quot;Hello World&quot;</code> expresses a query function, where is the function&#39;s input? There is also an implicit <code>DataKnot</code> containing a single element, <code>nothing</code>. Hence, this example can be rewritten:</p><pre><code class="language-julia">query(DataKnot(nothing), Combinator(&quot;Hello World&quot;))</code></pre><p>There are other combinators. The identity combinator, <code>It</code> converts to a query function that simply reproduces its input. This would permit us to write our <code>&quot;Hello World&quot;</code> example once again:</p><pre><code class="language-julia">query(query(&quot;Hello World&quot;), It)</code></pre><h2><a class="nav-anchor" id="Lifting-Functions-to-Combinators-1" href="#Lifting-Functions-to-Combinators-1">Lifting Functions to Combinators</a></h2><p>In fact, any scalar value can be seen as a function, just one that ignores its input. Given such a function, it could be <em>lifted</em> into its combinator form.</p><pre><code class="language-julia">hello_world(x) = &quot;Hello World&quot;
HelloWorld = Lift(hello_world, It)
query(HelloWorld)</code></pre><p>The <code>Lift()</code> function takes the function being lifted into a combinator as the 1st argument. The 2nd and remaining arguments are the combinator expressions used to convert. In Julia, anonymous functions can be used to make this lifting far more convenient.</p><pre><code class="language-julia">query(Lift(x -&gt; &quot;Hello World&quot;, It))</code></pre><footer><hr/><a class="previous" href="../install/"><span class="direction">Previous</span><span class="title">Installation Instructions</span></a><a class="next" href="../usage/"><span class="direction">Next</span><span class="title">Usage Guide</span></a></footer></article></body></html>
