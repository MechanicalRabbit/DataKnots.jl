<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href>Overview</a><ul class="internal"><li><a class="toctext" href="#Answering-an-Inquiry-1">Answering an Inquiry</a></li><li><a class="toctext" href="#Basic-Queries-1">Basic Queries</a></li><li><a class="toctext" href="#What-is-a-DataKnot?-1">What is a DataKnot?</a></li><li><a class="toctext" href="#Hierarchical-Transformations-1">Hierarchical Transformations</a></li><li><a class="toctext" href="#Query-Context-1">Query Context</a></li></ul></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></li><li><span class="toctext">Concepts</span><ul><li><a class="toctext" href="../primer/">Thinking in Queries</a></li><li><a class="toctext" href="../vectors/">Column Store</a></li><li><a class="toctext" href="../pipelines/">Pipeline Algebra</a></li><li><a class="toctext" href="../shapes/">Shapes and Signatures</a></li><li><a class="toctext" href="../knots/">Data Knots</a></li><li><a class="toctext" href="../queries/">Query Algebra</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Overview</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/overview.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Overview</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>DataKnots is a toolkit for representing and querying complex structured data. It is designed for data analysts and domain experts (e.g. accountants, engineers, clinicians) who need to build and share domain-specific queries. This overview introduces DataKnots and its query algebra.</p><h2><a class="nav-anchor" id="Answering-an-Inquiry-1" href="#Answering-an-Inquiry-1">Answering an Inquiry</a></h2><p>Let&#39;s discuss a particular inquiry: <em>Which City of Chicago employees have salary higher than the average for their department?</em></p><p>We use a tiny selection of public data from the City of Chicago. This dataset includes employees and their annual salary.</p><pre><code class="language-julia">using CSV

employee_csv = &quot;&quot;&quot;
    name,department,position,salary
    &quot;ANTHONY A&quot;,&quot;POLICE&quot;,&quot;POLICE OFFICER&quot;,72510
    &quot;DANIEL A&quot;,&quot;FIRE&quot;,&quot;FIRE FIGHTER-EMT&quot;,95484
    &quot;JAMES A&quot;,&quot;FIRE&quot;,&quot;FIRE ENGINEER-EMT&quot;,103350
    &quot;JEFFERY A&quot;,&quot;POLICE&quot;,&quot;SERGEANT&quot;,101442
    &quot;NANCY A&quot;,&quot;POLICE&quot;,&quot;POLICE OFFICER&quot;,80016
    &quot;ROBERT K&quot;,&quot;FIRE&quot;,&quot;FIRE FIGHTER-EMT&quot;,103272
    &quot;&quot;&quot; |&gt; IOBuffer |&gt; CSV.File</code></pre><p>To query this employee data, we convert it to a <code>DataKnot</code>, or just <em>knot</em>. In the <code>DataKnot</code> constructor, <code>employee_csv</code> is provided a label of <code>employee</code>.</p><pre><code class="language-julia">using DataKnots

chicago = DataKnot(:employee =&gt; employee_csv)</code></pre><p>Then, to answer this inquiry, we query <code>chicago</code> as follows.</p><pre><code class="language-julia">using Statistics: mean

@query chicago begin
    employee
    group(department)
    keep(mean_salary =&gt; mean(employee.salary))
    employee
    filter(salary &gt; mean_salary)
end
#=&gt;
  │ employee                                         │
  │ name       department  position           salary │
──┼──────────────────────────────────────────────────┼
1 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │
2 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │
3 │ JEFFERY A  POLICE      SERGEANT           101442 │
=#</code></pre><p>This overview will proceed by incrementally reconstructing this query, showing how an analyst could explore data and independently arrive at the answer above.</p><h2><a class="nav-anchor" id="Basic-Queries-1" href="#Basic-Queries-1">Basic Queries</a></h2><p>DataKnots implements an algebra of queries. This algebra&#39;s elements, or <em>queries</em>, represent relationships among class entities and datatypes. Nouns, such as <code>employee</code>, <code>department</code>, and <code>salary</code>, are <em>query primitives</em>.</p><p>Let&#39;s query the <code>chicago</code> knot to list <code>employee</code> records.</p><pre><code class="language-julia">@query chicago employee
#=&gt;
  │ employee                                         │
  │ name       department  position           salary │
──┼──────────────────────────────────────────────────┼
1 │ ANTHONY A  POLICE      POLICE OFFICER      72510 │
2 │ DANIEL A   FIRE        FIRE FIGHTER-EMT    95484 │
3 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │
4 │ JEFFERY A  POLICE      SERGEANT           101442 │
5 │ NANCY A    POLICE      POLICE OFFICER      80016 │
6 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │
=#</code></pre><p>Verbs, such as <code>group</code>, <code>keep</code>, <code>mean</code>, and <code>filter</code> are <em>query combinators</em>. Combinators build new queries from existing ones. For example, <code>count</code> is a combinator.</p><pre><code class="language-julia">@query chicago count(employee)
#=&gt;
┼───┼
│ 6 │
=#</code></pre><p>Query <em>composition</em> (<code>.</code>) is also a combinator, it builds a query that applies the output of one query as the input to another. The query <code>employee.name</code> lists all employee names.</p><pre><code class="language-julia">@query chicago employee.name
#=&gt;
  │ name      │
──┼───────────┼
1 │ ANTHONY A │
2 │ DANIEL A  │
3 │ JAMES A   │
4 │ JEFFERY A │
5 │ NANCY A   │
6 │ ROBERT K  │
=#</code></pre><p>Within a multi-line macro block, each individual statement is composed with its predecessor. Hence, we could write the query above without the period delimiter.</p><pre><code class="language-julia">@query chicago begin
    employee
    name
end</code></pre><p>Often it&#39;s helpful to see the combined output from correlated queries. The <em>record</em> combinator, which is delimited with a pair of curly braces <code>{}</code>, is used to build queries that produce parallel results.</p><pre><code class="language-julia">@query chicago employee{name, salary}
#=&gt;
  │ employee          │
  │ name       salary │
──┼───────────────────┼
1 │ ANTHONY A   72510 │
2 │ DANIEL A    95484 │
3 │ JAMES A    103350 │
4 │ JEFFERY A  101442 │
5 │ NANCY A     80016 │
6 │ ROBERT K   103272 │
=#</code></pre><p>Within a <code>@query</code> macro, constants, such as <code>100_000</code> are treated as query primitives. These constant queries produce the same output regardless of the input they receive.</p><pre><code class="language-julia">@query chicago employee{name, salary, threshold =&gt; 100_000}
#=&gt;
  │ employee                     │
  │ name       salary  threshold │
──┼──────────────────────────────┼
1 │ ANTHONY A   72510     100000 │
2 │ DANIEL A    95484     100000 │
3 │ JAMES A    103350     100000 │
4 │ JEFFERY A  101442     100000 │
5 │ NANCY A     80016     100000 │
6 │ ROBERT K   103272     100000 │
=#</code></pre><p>Functions, such as <code>titlecase</code>, and operators, such as greater-than (<code>&gt;</code>), are treated as query combinators; that is, they are used to build queries from component queries.</p><pre><code class="language-julia">@query chicago begin
    employee
    {name =&gt; titlecase(name), highly_paid =&gt; salary &gt; 100_000}
end
#=&gt;
  │ employee               │
  │ name       highly_paid │
──┼────────────────────────┼
1 │ Anthony A        false │
2 │ Daniel A         false │
3 │ James A           true │
4 │ Jeffery A         true │
5 │ Nancy A          false │
6 │ Robert K          true │
=#</code></pre><p>Since <code>salary &gt; 100_000</code> is a predicate query, we can use the <code>filter</code> combinator to build the query <code>filter(salary &gt; 100_000)</code>.</p><pre><code class="language-julia">@query chicago employee.filter(salary &gt; 100_000)
#=&gt;
  │ employee                                         │
  │ name       department  position           salary │
──┼──────────────────────────────────────────────────┼
1 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │
2 │ JEFFERY A  POLICE      SERGEANT           101442 │
3 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │
=#</code></pre><p>In this section, we have built a query that produces highly-compensated employees. More broadly, we&#39;ve demonstrated how an algebra of queries permits us to combine previously proven queries in an intuitive way.</p><p>Before moving on to the original inquiry, we need to discuss how queries see their input.</p><h2><a class="nav-anchor" id="What-is-a-DataKnot?-1" href="#What-is-a-DataKnot?-1">What is a DataKnot?</a></h2><p>Input and output of queries are serialized as <code>DataKnot</code> objects. A DataKnot is a container that stores a hierarchy of labeled elements, where each element is either a scalar value, such as an integer or a string, or a collection of nested elements.</p><p>Recall the knot produced by the query <code>employee{name, salary}</code>.</p><pre><code class="language-julia">@query chicago employee{name, salary}
#=&gt;
  │ employee          │
  │ name       salary │
──┼───────────────────┼
1 │ ANTHONY A   72510 │
2 │ DANIEL A    95484 │
3 │ JAMES A    103350 │
4 │ JEFFERY A  101442 │
5 │ NANCY A     80016 │
6 │ ROBERT K   103272 │
=#</code></pre><p>This knot contains 6 composite elements labeled <code>employee</code>, each employee having elements labeled <code>name</code> and <code>salary</code>. This element hierarchy can be visualized using show(::DataKnot, as=:flow)</p><pre><code class="language-literal">    show(as=:flow, @query chicago employee{name, salary})
    #=&gt;
    6-element DataKnot:
      employee:
        name: &quot;ANTHONY A&quot;
        salary: 72510
      employee:
        name: &quot;DANIEL A&quot;
        salary: 95484
      ⋮
    =#</code></pre><p>The structure of a DataKnot is called its <em>shape</em>. In this case, the shape describes a hierarchy with 2 levels: zero or more elements with label <code>employee</code>, each employee element containing exactly one string element labeled <code>name</code> and exactly one integer element labeled <code>salary</code>.</p><pre><code class="language-julia">show(as=:shape, @query chicago employee{name, salary})
#=&gt;
6-element DataKnot:
  employee  0:N
  ├╴name    1:1 × String
  └╴salary  1:1 × Int64
=#</code></pre><p>Not all knots have exactly two levels. Recall the query `count(employee) which produces a single, unlabeled numeric value.</p><pre><code class="language-julia">@query chicago count(employee)
#=&gt;
┼───┼
│ 6 │
=#</code></pre><p>The shape of the knot reflects this structure. Here <code>#</code> is used in place of the missing label.</p><pre><code class="language-julia">show(as=:shape, @query chicago count(employee))
#=&gt;
1-element DataKnot:
  #  1:1 × Int64
=#</code></pre><p>Our <code>chicago</code> knot has a hierarchy of <em>three</em> levels: a single unlabeled root element, branch level of <code>employee</code> elements, and a leaf level with <code>name</code>, <code>department</code>, <code>position</code>, and <code>salary</code>.</p><pre><code class="language-julia">show(as=:shape, chicago)
#=&gt;
1-element DataKnot:
  #               1:1
  └╴employee      0:N
    ├╴name        String
    ├╴department  String
    ├╴position    String
    └╴salary      Int64
=#</code></pre><p>This knot could be shown as a hierarchy of elements. Observe that <code>chicago</code> has a single, unlabeled root element.</p><pre><code class="language-literal">    show(as=:flow, chicago)
    #=&gt;
    1-element DataKnot:
      #:
        employee:
          name: &quot;ANTHONY A&quot;
          department: &quot;POLICE&quot;
          position: &quot;POLICE OFFICER&quot;
          salary: 72510
        employee:
          name: &quot;DANIEL A&quot;
          department: &quot;FIRE&quot;
          position: &quot;FIRE FIGHTER-EMT&quot;
          salary: 95484
        ⋮
    =#</code></pre><p>When a knot is displayed, its hierarchy is projected to a tabular form. For <code>chicago</code>, the root element gets its own row with <code>employee</code> elements packed into a single cell: employees are delimited by a semi-colon; and nested attributes are separated by a comma. For packed cells, such as <code>employee</code>, the header shows the subordinate labels within a pair of curly braces.</p><pre><code class="language-julia">chicago
#=&gt;
│ employee{name,department,position,salary}                           │
┼─────────────────────────────────────────────────────────────────────┼
│ ANTHONY A, POLICE, POLICE OFFICER, 72510; DANIEL A, FIRE, FIRE FIGH…│
=#</code></pre><p>In this section, we have seen how DataKnots sees data as a hierarchical flow of labeled elements. In the next section, we show how hierarchies can be collapsed and created.</p><h2><a class="nav-anchor" id="Hierarchical-Transformations-1" href="#Hierarchical-Transformations-1">Hierarchical Transformations</a></h2><p>DataKnots&#39; combinators implement hierarchical transformations. Summary combinators, such as <code>count</code>, build queries that collapse a subtree into a single value. For example, we can compute average salary across employees with <code>mean(employee.salary)</code>.</p><pre><code class="language-julia">using Statistics: mean

@query chicago begin
    mean_salary =&gt; mean(employee.salary)
end
#=&gt;
│ mean_salary │
┼─────────────┼
│     92679.0 │
=#</code></pre><p>The <code>group</code> combinator builds queries that introduce a new level in the hierarchy by constructing grouping records for each unique element produced by its argument. For example, we could <code>group</code> employees by <code>department</code>.</p><pre><code class="language-julia">@query chicago employee.group(department)
#=&gt;
  │ department  employee{name,department,position,salary}             │
──┼───────────────────────────────────────────────────────────────────┼
1 │ FIRE        DANIEL A, FIRE, FIRE FIGHTER-EMT, 95484; JAMES A, FIR…│
2 │ POLICE      ANTHONY A, POLICE, POLICE OFFICER, 72510; JEFFERY A, …│
=#</code></pre><p>In this tabular layout, grouping records are represented as table rows, and the corresponding employees are packed into a single cell. To see the knot in an unpacked form, we can display it as an element hierarchy.</p><pre><code class="language-literal">    show(as=:shape, @query chicago employee.group(department))
    #=&gt;
    2-element DataKnot:
      #:
        department: &quot;POLICE&quot;
        employee:
          name: &quot;ANTHONY A&quot;
          department: &quot;POLICE&quot;
          position: &quot;POLICE OFFICER&quot;
          salary: 72510
        employee:
          name: &quot;JEFFERY A&quot;
          department: &quot;POLICE&quot;
          position: &quot;SERGEANT&quot;
          salary: 201442
        ⋮
      #:
        department: &quot;FIRE&quot;
        employee:
          name: &quot;DANIEL A&quot;
          department: &quot;FIRE&quot;
          position: &quot;FIRE FIGHTER-EMT&quot;
          salary: 95484
        employee:
          name: &quot;JAMES A&quot;
          department: &quot;FIRE&quot;
          position: &quot;FIRE ENGINEER-EMT&quot;
          salary: 103350
        ⋮
    =#</code></pre><p>Once constructed, grouping records can be used as any other input. In this next query, we show salaries of employees by department. Since each department in our reduced dataset happens to have 3 employees, our output has 3 salary entries.</p><pre><code class="language-julia">@query chicago begin
    employee
    group(department)
    {department, employee.salary}
end
#=&gt;
  │ department  salary                │
──┼───────────────────────────────────┼
1 │ FIRE        95484; 103350; 103272 │
2 │ POLICE      72510; 101442; 80016  │
=#</code></pre><p>We can use summary operations relative to grouping records. In this next example, <code>mean(employee.salary)</code> is computed for each department.</p><pre><code class="language-julia">@query chicago begin
    employee
    group(department)
    {department, mean_salary =&gt; mean(employee.salary)}
end
#=&gt;
  │ department  mean_salary │
──┼─────────────────────────┼
1 │ FIRE           100702.0 │
2 │ POLICE          84656.0 │
=#</code></pre><p>In this section, we have built a query that computes the average employee compensation for each department. Further, we&#39;ve shown how <code>group</code> is used to transform hierarchies. Finally, we&#39;ve demonstrated that grouping and summary combinators are independent, yet work fluidly together.</p><p>We&#39;re close to answering our original inquiry. We&#39;ve built a query that filters employees. We&#39;ve built a query that produces average salary by department. We need only connect these queries.</p><h2><a class="nav-anchor" id="Query-Context-1" href="#Query-Context-1">Query Context</a></h2><p>DataKnots&#39; queries are interpreted contextually, relative to the input that they receive. We&#39;ve seen this earlier: depending where it is placed, <code>mean(employee.salary)</code> can produce either the average salary over the entire dataset, or averages within each department.</p><p>For our inquiry, we need to compare each employee&#39;s salary with the average salary. However, we cannot evaluate both <code>salary</code> and <code>mean_salary</code> in the same context.</p><pre><code class="language-julia">@query chicago begin
    employee
    {name, salary, mean_salary =&gt; mean(employee.salary)}
end
#-&gt; ERROR: cannot find &quot;employee&quot; ⋮</code></pre><p>To evaluate an expression in one context and then make the value available in subsequent contexts, we could use the <code>keep</code> combinator. The next query computes <code>mean_salary</code> with respect to the entire dataset, and then uses this value in the context of each employee.</p><pre><code class="language-julia">@query chicago begin
    keep(mean_salary =&gt; mean(employee.salary))
    employee
    {name, salary, mean_salary}
end
#=&gt;
  │ employee                       │
  │ name       salary  mean_salary │
──┼────────────────────────────────┼
1 │ ANTHONY A   72510      92679.0 │
2 │ DANIEL A    95484      92679.0 │
3 │ JAMES A    103350      92679.0 │
4 │ JEFFERY A  101442      92679.0 │
5 │ NANCY A     80016      92679.0 │
6 │ ROBERT K   103272      92679.0 │
=#</code></pre><p>However, the inquiry asks us to use average salary <em>by department</em> not across all employees. To adapt the previous query, we need to place our <code>keep</code> in the context of <code>employee.group(department)</code>.</p><pre><code class="language-julia">@query chicago begin
    employee
    group(department)
    keep(mean_salary =&gt; mean(employee.salary))
    employee
    {name, salary, mean_salary}
end
#=&gt;
  │ employee                       │
  │ name       salary  mean_salary │
──┼────────────────────────────────┼
1 │ DANIEL A    95484     100702.0 │
2 │ JAMES A    103350     100702.0 │
3 │ ROBERT K   103272     100702.0 │
4 │ ANTHONY A   72510      84656.0 │
5 │ JEFFERY A  101442      84656.0 │
6 │ NANCY A     80016      84656.0 │
=#</code></pre><p>We just need to add a <code>filter</code> to answer our initial inquiry: <em>which employees have a salary that is higher than the average for their department?</em></p><pre><code class="language-julia">@query chicago begin
    employee
    group(department)
    keep(mean_salary =&gt; mean(employee.salary))
    employee
    filter(salary &gt; mean_salary)
end
#=&gt;
  │ employee                                         │
  │ name       department  position           salary │
──┼──────────────────────────────────────────────────┼
1 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │
2 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │
3 │ JEFFERY A  POLICE      SERGEANT           101442 │
=#</code></pre><p>In this section, we&#39;ve completed our query. Let&#39;s talk more about mechanics, how these queries operate.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../tutorial/"><span class="direction">Next</span><span class="title">Tutorial</span></a></footer></article></body></html>
