<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DataKnots Tutorial · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>DataKnots Tutorial</a><ul class="internal"><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Query-Combinators-1">Query Combinators</a></li></ul></li><li><a class="toctext" href="../thinking/">Thinking in Combinators</a></li><li><a class="toctext" href="../reference/">Reference</a></li><li><a class="toctext" href="../implementation/">Implementation Notes</a></li><li><a class="toctext" href="../simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DataKnots Tutorial</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DataKnots Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DataKnots-Tutorial-1" href="#DataKnots-Tutorial-1">DataKnots Tutorial</a></h1><p>DataKnots is an embedded query language designed so that accidental programmers could more easily solve complex data analysis tasks.</p><p>This tutorial shows how typical query operations can be performed upon a simplified in-memory dataset. For initial releases, DataKnots will not include have methods to read/write common data formats (such as CSV or DataFrames). Contributors are welcome.</p><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>Consider a tiny cross-section of public data from Chicago, represented as nested <code>NamedTuple</code> and <code>Vector</code> objects.</p><pre><code class="language-julia">chicago_data =
  (department = [
    (name = &quot;POLICE&quot;,
     employee = [
      (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;,
       salary = 101442),
      (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;,
       salary = 80016)]),
    (name = &quot;FIRE&quot;,
     employee = [
      (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;,
       salary = 95484)])],);</code></pre><p>In this hierarchical Chicago dataset, the root is a <code>NamedTuple</code> with an entry <code>:department</code>, which is a <code>Vector</code> department records, and so on. Notice that the label <code>name</code> occurs both within the context of a department and an employee record.</p><p>To query this dataset, we convert it into a <code>DataKnot</code>, or <em>knot</em>.</p><pre><code class="language-julia">using DataKnots
chicago = DataKnot(chicago_data)</code></pre><h3><a class="nav-anchor" id="Our-First-Query-1" href="#Our-First-Query-1">Our First Query</a></h3><p>Let&#39;s say we want to return the list of department names from this dataset. We query the <code>chicago</code> knot using Julia&#39;s index notation and the query <code>It.department.name</code>.</p><pre><code class="language-julia">department_names = chicago[It.department.name]
#=&gt;
  │ name   │
──┼────────┼
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>The output, <code>department_names</code>, is also a DataKnot. The content of this output knot could be accessed via <code>get</code> function.</p><pre><code class="language-julia">get(department_names)
#-&gt; [&quot;POLICE&quot;, &quot;FIRE&quot;]</code></pre><h3><a class="nav-anchor" id="Navigation-1" href="#Navigation-1">Navigation</a></h3><p>In DataKnot queries, <code>It</code> means &quot;use the current input&quot;. The dotted notation lets one navigate the hierarchy. Let&#39;s continue our dataset exploration by listing employee names.</p><pre><code class="language-julia">chicago[It.department.employee.name]
#=&gt;
  │ name      │
──┼───────────┼
1 │ JEFFERY A │
2 │ NANCY A   │
3 │ DANIEL A  │
=#</code></pre><p>Navigation context matters. For example, <code>employee</code> tuples are not directly accessible from the root of the dataset. When a label can&#39;t be found, an appropriate error message is displayed.</p><pre><code class="language-julia">chicago[It.employee]
#-&gt; ERROR: cannot find &quot;employee&quot; ⋮</code></pre><p>Instead, <code>employee</code> tuples can be queried by navigating though <code>department</code> tuples. When tuples are returned, they is displayed with a tabular layout.</p><pre><code class="language-julia">chicago[It.department.employee]
#=&gt;
  │ employee                            │
  │ name       position          salary │
──┼─────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT          101442 │
2 │ NANCY A    POLICE OFFICER     80016 │
3 │ DANIEL A   FIRE FIGHTER-EMT   95484 │
=#</code></pre><p>Notice that nested lists traversed during navigation are flattened into a single output.</p><h3><a class="nav-anchor" id="Composition-and-Identity-1" href="#Composition-and-Identity-1">Composition &amp; Identity</a></h3><p>Dotted navigations, such as <code>It.department.name</code>, are a syntax shorthand for the <code>Get()</code> primitive together with query composition (<code>&gt;&gt;</code>).</p><pre><code class="language-julia">chicago[Get(:department) &gt;&gt; Get(:name)]
#=&gt;
  │ name   │
──┼────────┼
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>The <code>Get()</code> primitive returns values that match a given name. Query composition (<code>&gt;&gt;</code>) chains two queries serially, with the output of its first query as input to the second.</p><pre><code class="language-julia">chicago[Get(:department) &gt;&gt; Get(:employee)]
#=&gt;
  │ employee                            │
  │ name       position          salary │
──┼─────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT          101442 │
2 │ NANCY A    POLICE OFFICER     80016 │
3 │ DANIEL A   FIRE FIGHTER-EMT   95484 │
=#</code></pre><p>In this query algebra, <code>It</code> is the identity query with respect to composition (<code>&gt;&gt;</code>). The query <code>It</code> simply reproduces for its output what it recieves as its input. Hence, <code>It</code> can be woven into any composition without changing the result.</p><pre><code class="language-julia">chicago[It &gt;&gt; Get(:department) &gt;&gt; Get(:name)]
#=&gt;
  │ name   │
──┼────────┼
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>This motivates our clever use of <code>It</code> as a syntax short hand.</p><pre><code class="language-julia">chicago[It.department.name]
#=&gt;
  │ name   │
──┼────────┼
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>This query, <code>It.department.name</code>, could be equivalently written <code>Get(:department) &gt;&gt; Get(:name)</code>.</p><h3><a class="nav-anchor" id="Context-and-Counting-1" href="#Context-and-Counting-1">Context &amp; Counting</a></h3><p>To count the number of departments in this <code>chicago</code> dataset we write the query <code>Count(It.department)</code>. Observe that the argument provided to <code>Count()</code>, <code>It.department</code>, is itself a query.</p><pre><code class="language-julia">chicago[Count(It.department)]
#=&gt;
│ It │
┼────┼
│  2 │
=#</code></pre><p>Using query composition (<code>&gt;&gt;</code>), we can perform <code>Count</code> in a nested context. For this next example, let&#39;s count <code>employee</code> records within each <code>department</code>.</p><pre><code class="language-julia">chicago[It.department &gt;&gt; Count(It.employee)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  1 │
=#</code></pre><p>In this output we see that the 1st department, <code>&quot;POLICE&quot;</code>, has <code>2</code> employees, while the 2nd, <code>&quot;FIRE&quot;</code> only has <code>1</code>. The occurrence of <code>It</code> within the subordinate query <code>Count(It.employee)</code> refers to each department individually, not to the dataset as a whole.</p><h3><a class="nav-anchor" id="Record-Construction-1" href="#Record-Construction-1">Record Construction</a></h3><p>Returning values in tandem can be done with <code>Record()</code>. Let&#39;s improve the previous output by including each department&#39;s name alongside employee counts.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Record(It.name,
           Count(It.employee))]
#=&gt;
  │ department │
  │ name    #B │
──┼────────────┼
1 │ POLICE   2 │
2 │ FIRE     1 │
=#</code></pre><p>Records can be nested. The following listing includes, for each department, employee names and their salary.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Record(It.name,
           It.employee &gt;&gt;
           Record(It.name,
                  It.salary))]
#=&gt;
  │ department                                │
  │ name    employee                          │
──┼───────────────────────────────────────────┼
1 │ POLICE  JEFFERY A, 101442; NANCY A, 80016 │
2 │ FIRE    DANIEL A, 95484                   │
=#</code></pre><p>In this nested display, commas are used to separate fields and semi-colons separate values.</p><h3><a class="nav-anchor" id="Expressions-and-Output-Labels-1" href="#Expressions-and-Output-Labels-1">Expressions &amp; Output Labels</a></h3><p>Query expressions can be named and reused. Further, the output column of these named queries may be labeled using Julia&#39;s <code>Pair</code> syntax (<code>=&gt;</code>). Let&#39;s define <code>EmployeeCount</code> to be the number of employees in a given department.</p><pre><code class="language-julia">EmployeeCount =
    :employee_count =&gt;
        Count(It.employee)

chicago[
    It.department &gt;&gt;
    Record(It.name,
           EmployeeCount)]
#=&gt;
  │ department             │
  │ name    employee_count │
──┼────────────────────────┼
1 │ POLICE               2 │
2 │ FIRE                 1 │
=#</code></pre><p>Labels can be attached to an existing query using the <code>Label</code> primitive. This form is handy for use in successive query refinements (<code>&gt;&gt;=</code>).</p><pre><code class="language-julia">DeptCount = Count(It.department)
DeptCount &gt;&gt;= Label(:dept_count)

chicago[DeptCount]
#=&gt;
│ dept_count │
┼────────────┼
│          2 │
=#</code></pre><p>Besides providing a display title, labels also provide a way to access fields within a record.</p><pre><code class="language-julia">chicago[
    Record(It, DeptCount) &gt;&gt;
    It.dept_count]
#=&gt;
│ dept_count │
┼────────────┼
│          2 │
=#</code></pre><h3><a class="nav-anchor" id="Filtering-Data-1" href="#Filtering-Data-1">Filtering Data</a></h3><p>Returning only wanted values can be done with <code>Filter()</code>. Here we list department names who have exactly one employee.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Filter(EmployeeCount .== 1) &gt;&gt;
    Record(It.name, EmployeeCount)]
#=&gt;
  │ department           │
  │ name  employee_count │
──┼──────────────────────┼
1 │ FIRE               1 │
=#</code></pre><p>In query expressions, the broadcast variant of common operators, such as <code>.==</code>, are to be used. Forgetting the period is an easy mistake to make and the resulting Julia language error message may not be helpful.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Filter(EmployeeCount == 1) &gt;&gt;
    Record(It.name, EmployeeCount)]
#=&gt;
ERROR: AssertionError: eltype(input) &lt;: AbstractVector
=#</code></pre><p>Let&#39;s define <code>GT100K</code> to check if an employee&#39;s salary is greater than 100K. The output of this query component is also labeled.</p><pre><code class="language-julia">GT100K =
    :gt100k =&gt;
        It.salary .&gt; 100000

chicago[
    It.department.employee &gt;&gt;
    Record(It.name, It.salary, GT100K)]
#=&gt;
  │ employee                  │
  │ name       salary  gt100k │
──┼───────────────────────────┼
1 │ JEFFERY A  101442    true │
2 │ NANCY A     80016   false │
3 │ DANIEL A    95484   false │
=#</code></pre><p>Since <code>Filter</code> takes a boolean valued query for an argument, we could use <code>GTK100K</code> to filter employees.</p><pre><code class="language-julia">chicago[
    It.department.employee &gt;&gt;
    Filter(GT100K) &gt;&gt;
    It.name]
#=&gt;
  │ name      │
──┼───────────┼
1 │ JEFFERY A │
=#</code></pre><h3><a class="nav-anchor" id="Incremental-Composition-1" href="#Incremental-Composition-1">Incremental Composition</a></h3><p>This data discovery could have been done incrementally, with each intermediate query being fully runnable. Let&#39;s start <code>our_query</code> as a list of employees. We&#39;re not going to run it, but we could.</p><pre><code class="language-julia">our_query = It.department.employee
#-&gt; It.department.employee</code></pre><p>Let&#39;s extend this query to compute if the salary is over 100k. Notice how query composition is tracked for us.</p><pre><code class="language-julia">GT100K = :gt100k =&gt; It.salary .&gt; 100000
our_query &gt;&gt;= Record(It.name, It.salary, GT100K)
#=&gt;
It.department.employee &gt;&gt;
Record(It.name, It.salary, :gt100k =&gt; It.salary .&gt; 100000)
=#</code></pre><p>Let&#39;s run <code>our_query</code> against the <code>chicago</code> knot.</p><pre><code class="language-julia">chicago[our_query]
#=&gt;
  │ employee                  │
  │ name       salary  gt100k │
──┼───────────────────────────┼
1 │ JEFFERY A  101442    true │
2 │ NANCY A     80016   false │
3 │ DANIEL A    95484   false │
=#</code></pre><p>Since labeling permits direct Record access, we could further extend <code>our_query</code> to filter unwanted rows.</p><pre><code class="language-julia">our_query &gt;&gt;= Filter(It.gt100k)
#=&gt;
It.department.employee &gt;&gt;
Record(It.name, It.salary, :gt100k =&gt; It.salary .&gt; 100000) &gt;&gt;
Filter(It.gt100k)
=#</code></pre><p>Let&#39;s run <code>our_query</code> again.</p><pre><code class="language-julia">chicago[our_query]
#=&gt;
  │ employee                  │
  │ name       salary  gt100k │
──┼───────────────────────────┼
1 │ JEFFERY A  101442    true │
=#</code></pre><p>Well-tested queries may benefit from a <code>Tag</code> so that their definitions are suppressed in larger compositions.</p><pre><code class="language-julia">GT100K = Tag(:GT100K, :gt100k =&gt; It.salary .&gt; 100000)
#-&gt; GT100K</code></pre><p>This tagging can make subsequent compositions easier to read, when the definition of the named query is not being questioned.</p><pre><code class="language-julia">our_query = It.department.employee &gt;&gt;
            Record(It.name, It.salary, GT100K)
#=&gt;
It.department.employee &gt;&gt; Record(It.name, It.salary, GT100K)
=#</code></pre><p>Notice that the tag (<code>:GT100K</code>) is distinct from the data label (<code>:gt100k</code>), the tag names the query while the label names the output column.</p><pre><code class="language-julia">our_query &gt;&gt;= Filter(It.gt100k)
chicago[our_query]
#=&gt;
  │ employee                  │
  │ name       salary  gt100k │
──┼───────────────────────────┼
1 │ JEFFERY A  101442    true │
=#</code></pre><p>For the final step of our query&#39;s incremental construction, let&#39;s only show the employee&#39;s name that met the GT100K criteria.</p><pre><code class="language-julia">our_query &gt;&gt;= It.name
chicago[our_query]
#=&gt;
  │ name      │
──┼───────────┼
1 │ JEFFERY A │
=#</code></pre><p>As we see, queries can be combined in series or as arguments to make new queries. Queries can then be performed on a DataKnot to produce a new DataKnot. Hence, the construction and performance of a query are distinct and separate operations.</p><h3><a class="nav-anchor" id="Accessing-Data-1" href="#Accessing-Data-1">Accessing Data</a></h3><p>Given any <code>DataKnot</code>, its content can be accessed via <code>get</code>. For scalar outputs, <code>get</code> returns a typed Julia value.</p><pre><code class="language-julia">get(chicago[Count(It.department)])
#-&gt; 2</code></pre><p>For simple lists, <code>get</code> returns a typed <code>Vector</code>.</p><pre><code class="language-julia">get(chicago[It.department.employee.name])
#-&gt; [&quot;JEFFERY A&quot;, &quot;NANCY A&quot;, &quot;DANIEL A&quot;]</code></pre><p>For more complex outputs, <code>get</code> may return a <code>@VectorTree</code>, a column-oriented storage for our <code>DataKnot</code> system.</p><pre><code class="language-julia">query = It.department &gt;&gt;
        Record(It.name,
               :employee_count =&gt; Count(It.employee))
vt = get(chicago[query])
display(vt)
#=&gt;
@VectorTree of 2 × (name = (1:1) × String, employee_count = (1:1) × Int):
 (name = &quot;POLICE&quot;, employee_count = 2)
 (name = &quot;FIRE&quot;, employee_count = 1)
=#</code></pre><p>The <code>@VectorTree</code> datatype is considered an implemention detail, upon which specific input/output converters will be written.</p><h2><a class="nav-anchor" id="Query-Combinators-1" href="#Query-Combinators-1">Query Combinators</a></h2><p>We&#39;ve seen how DataKnots&#39; queries are assembled algebraically: they either come from a set of atomic <em>primitives</em> or are built from other queries using <em>combinators</em>.</p><p>Query primitives include the identity (<code>It</code>), constant values (like <code>100000</code>), and data navigation via <code>Get(:Symbol)</code>. Besides query composition (<code>&gt;&gt;</code>), query combinators include <code>Count()</code>, <code>Record()</code>, <code>Label()</code>, <code>Filter()</code>, <code>Tag()</code> and broadcast operators such as equality <code>(.==)</code> and greater than <code>(.&gt;)</code>.</p><p>This next section describes additional primitives and combinators included with DataKnots&#39; core library.</p><h3><a class="nav-anchor" id="Aggregate-queries-1" href="#Aggregate-queries-1">Aggregate queries</a></h3><p>Aggregates, such as <code>Count</code> may be used as a query primitive, providing incremental refinement without additional nesting. In this next example, <code>Count</code> takes an input of filtered employees, and returns the size of its input.</p><pre><code class="language-julia">chicago[
    It.department.employee &gt;&gt;
    Filter(It.salary .&gt; 100000) &gt;&gt;
    Count]
#=&gt;
│ It │
┼────┼
│  1 │
=#</code></pre><p>Aggregate query primitives operate contextually. In the following example, <code>Count</code> is performed relative to each department.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Record(
        It.name,
        :over_100k =&gt;
            It.employee &gt;&gt;
            Filter(It.salary .&gt; 100000) &gt;&gt;
            Count)]
#=&gt;
  │ department        │
  │ name    over_100k │
──┼───────────────────┼
1 │ POLICE          1 │
2 │ FIRE            0 │
=#</code></pre><p>Note that in the query <code>It.department.employee &gt;&gt; Count</code>, the <code>Count</code> primitive aggregates the number of employees across all departments. This doesn&#39;t change even if we add parentheses:</p><pre><code class="language-julia">chicago[It.department &gt;&gt; (It.employee &gt;&gt; Count)]
#=&gt;
│ It │
┼────┼
│  3 │
=#</code></pre><p>To count employees in <em>each</em> department, we use <code>Each()</code>. This combinator applies its input <em>elementwise</em> to its argument. Therefore, we get two counts, one for each department.</p><pre><code class="language-julia">chicago[It.department &gt;&gt; Each(It.employee &gt;&gt; Count)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  1 │
=#</code></pre><p>Naturally, we could use the <code>Count()</code> query combinator to get the same result.</p><pre><code class="language-julia">chicago[It.department &gt;&gt; Count(It.employee)]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  1 │
=#</code></pre><p>Which form of an aggregate to use depends upon what is notationally convenient. For incremental construction, being able to simply append <code>&gt;&gt; Count</code> is often very helpful.</p><pre><code class="language-julia">our_query = It.department.employee
chicago[our_query &gt;&gt; Count]
#=&gt;
│ It │
┼────┼
│  3 │
=#</code></pre><p>We could then refine the query, and run the exact same command.</p><pre><code class="language-julia">our_query &gt;&gt;= Filter(It.salary .&gt; 100000)
chicago[our_query &gt;&gt; Count]
#=&gt;
│ It │
┼────┼
│  1 │
=#</code></pre><h3><a class="nav-anchor" id="Function-broadcasting-1" href="#Function-broadcasting-1">Function broadcasting</a></h3><p>Besides operators, such as greater than (<code>.&gt;</code>), arbitrary functions can also be used as a query combinator with the broadcast notation. Let&#39;s define a function to extract an employee&#39;s first name.</p><pre><code class="language-julia">fname(x) = titlecase(split(x)[1])
fname(&quot;NANCY A&quot;)
#-&gt; &quot;Nancy&quot;</code></pre><p>This <code>fname</code> function can then be used within a query expression to return first names of all employees.</p><pre><code class="language-julia">chicago[
    It.department.employee &gt;&gt;
    fname.(It.name) &gt;&gt;
    Label(:first_name)]
#=&gt;
  │ first_name │
──┼────────────┼
1 │ Jeffery    │
2 │ Nancy      │
3 │ Daniel     │
=#</code></pre><p>Aggregate Julia functions, such as <code>mean</code>, can also be used.</p><pre><code class="language-julia">using Statistics: mean

chicago[
    It.department &gt;&gt;
    Record(
        It.name,
        :mean_salary =&gt; mean.(It.employee.salary))]
#=&gt;
  │ department          │
  │ name    mean_salary │
──┼─────────────────────┼
1 │ POLICE      90729.0 │
2 │ FIRE        95484.0 │
=#</code></pre><p>The conversion of a function into a combinator is accomplished by <code>Lift</code>, as documented in the reference. How a lifted function is treated as a query combinator depends upon that function&#39;s input and output signature.</p><h3><a class="nav-anchor" id="Keeping-Values-1" href="#Keeping-Values-1">Keeping Values</a></h3><p>Suppose we&#39;d like a list of employee names together with the corresponding department name. The naive approach won&#39;t work, because <code>department</code> is not a label in the context of an employee.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    It.employee &gt;&gt;
    Record(It.name, It.department.name)]
#-&gt; ERROR: cannot find &quot;department&quot; ⋮</code></pre><p>This can be overcome by using <code>Keep</code> to label an expression&#39;s result, so that it is available within subsequent computations.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Keep(:dept_name =&gt; It.name) &gt;&gt;
    It.employee &gt;&gt;
    Record(It.name, It.dept_name)]
#=&gt;
  │ employee             │
  │ name       dept_name │
──┼──────────────────────┼
1 │ JEFFERY A  POLICE    │
2 │ NANCY A    POLICE    │
3 │ DANIEL A   FIRE      │
=#</code></pre><p>This pattern also emerges with aggregate computations which need to be done in a parent scope. For example, let&#39;s compute employees with a higher than average salary for their department.</p><pre><code class="language-julia">using Statistics: mean
chicago[
    It.department &gt;&gt;
    Keep(:mean_salary =&gt; mean.(It.employee.salary)) &gt;&gt;
    It.employee &gt;&gt;
    Filter(It.salary .&gt; It.mean_salary)]
#=&gt;
  │ employee                    │
  │ name       position  salary │
──┼─────────────────────────────┼
1 │ JEFFERY A  SERGEANT  101442 │
=#</code></pre><p>In this last query, <code>mean</code> simply can&#39;t be moved into <code>Filter</code>&#39;s argument, since this argument is evaluated for <em>each</em> employee.</p><h3><a class="nav-anchor" id="Paging-Data-1" href="#Paging-Data-1">Paging Data</a></h3><p>Sometimes query results can be quite large. In this case it&#39;s helpful to <code>Take</code> or <code>Drop</code> items from the input stream. Let&#39;s start by listing all 3 employees of our toy database.</p><pre><code class="language-julia">Employee = It.department.employee
chicago[Employee]
#=&gt;
  │ employee                            │
  │ name       position          salary │
──┼─────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT          101442 │
2 │ NANCY A    POLICE OFFICER     80016 │
3 │ DANIEL A   FIRE FIGHTER-EMT   95484 │
=#</code></pre><p>To return up to the 2nd employee record, we use <code>Take</code>.</p><pre><code class="language-julia">chicago[Employee &gt;&gt; Take(2)]
#=&gt;
  │ employee                          │
  │ name       position        salary │
──┼───────────────────────────────────┼
1 │ JEFFERY A  SERGEANT        101442 │
2 │ NANCY A    POLICE OFFICER   80016 │
=#</code></pre><p>A negative index can be used, counting records from the end of the query&#39;s input. So, to return up to, but not including, the very last item in the stream, we could write:</p><pre><code class="language-julia">chicago[Employee &gt;&gt; Take(-1)]
#=&gt;
  │ employee                          │
  │ name       position        salary │
──┼───────────────────────────────────┼
1 │ JEFFERY A  SERGEANT        101442 │
2 │ NANCY A    POLICE OFFICER   80016 │
=#</code></pre><p>To return the last record of the query&#39;s input, we could <code>Drop</code> up to the last item in the stream:</p><pre><code class="language-julia">chicago[Employee &gt;&gt; Drop(-1)]
#=&gt;
  │ employee                           │
  │ name      position          salary │
──┼────────────────────────────────────┼
1 │ DANIEL A  FIRE FIGHTER-EMT   95484 │
=#</code></pre><p>To return the 1st half of the employees in the database, we could use <code>Take</code> with an argument that computes how many to take.</p><pre><code class="language-julia">chicago[Employee &gt;&gt; Take(Count(Employee) .÷ 2)]
#=&gt;
  │ employee                    │
  │ name       position  salary │
──┼─────────────────────────────┼
1 │ JEFFERY A  SERGEANT  101442 │
=#</code></pre><h3><a class="nav-anchor" id="Query-Parameters-1" href="#Query-Parameters-1">Query Parameters</a></h3><p>Julia&#39;s index notation permits named parameters. Each argument passed via named parameter is converted into a <code>DataKnot</code> and then made available as a label accessible anywhere in the query.</p><pre><code class="language-julia">chicago[AMT=100000, It.AMT]
#=&gt;
│ AMT    │
┼────────┼
│ 100000 │
=#</code></pre><p>This technique permits complex queries to be re-used with different argument values. By convention we capitalize parameters so they standout from regular data labels.</p><pre><code class="language-julia">PaidOverAmt =
    It.department &gt;&gt;
    It.employee &gt;&gt;
    Filter(It.salary .&gt; It.AMT) &gt;&gt;
    It.name

chicago[PaidOverAmt, AMT=100000]
#=&gt;
  │ name      │
──┼───────────┼
1 │ JEFFERY A │
=#</code></pre><p>What if we want to return employee names who have a greater than average salary? This average could be computed first.</p><pre><code class="language-julia">using Statistics
mean_salary = chicago[mean.(It.department.employee.salary)]
#=&gt;
│ It      │
┼─────────┼
│ 92314.0 │
=#</code></pre><p>Then, this value could be used as a query parameter.</p><pre><code class="language-julia">chicago[PaidOverAmt, AMT=mean_salary]
#=&gt;
  │ name      │
──┼───────────┼
1 │ JEFFERY A │
2 │ DANIEL A  │
=#</code></pre><p>While this approach works, it performs composition outside of the query language. If the dataset changes, a new <code>mean_salary</code> would have to be computed before the query above could be performed.</p><h3><a class="nav-anchor" id="Parameterized-Queries-1" href="#Parameterized-Queries-1">Parameterized Queries</a></h3><p>Suppose we want parameterized query that could take other queries as arguments. Using <code>Given</code>, we could build a query that returns <code>employee</code> records with <code>salary</code> over a given amount.</p><pre><code class="language-julia">EmployeesOver(X) =
    Given(:AMT =&gt; X,
        It.department &gt;&gt;
        It.employee &gt;&gt;
        Filter(It.salary .&gt; It.AMT))

chicago[EmployeesOver(100000)]
#=&gt;
  │ employee                    │
  │ name       position  salary │
──┼─────────────────────────────┼
1 │ JEFFERY A  SERGEANT  101442 │
=#</code></pre><p>But what if we wished to find employees with higher than average salary? Let&#39;s compute the average value as a query.</p><pre><code class="language-julia">using Statistics: mean
AvgSalary = mean.(It.department.employee.salary)

chicago[AvgSalary]
#=&gt;
│ It      │
┼─────────┼
│ 92314.0 │
=#</code></pre><p>We could then combine these two queries.</p><pre><code class="language-julia">chicago[EmployeesOver(AvgSalary)]
#=&gt;
  │ employee                            │
  │ name       position          salary │
──┼─────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT          101442 │
2 │ DANIEL A   FIRE FIGHTER-EMT   95484 │
=#</code></pre><p>Note that this combined expression is yet another query that could be further refined.</p><pre><code class="language-julia">chicago[EmployeesOver(AvgSalary) &gt;&gt; It.name]
#=&gt;
  │ name      │
──┼───────────┼
1 │ JEFFERY A │
2 │ DANIEL A  │
=#</code></pre><p>Unlike its cousin <code>Having</code>, <code>Given</code> doesn&#39;t leak its definitions. Specifically, <code>It.amt</code> is not available outside <code>EmployeesOver()</code>.</p><pre><code class="language-julia">chicago[EmployeesOver(AvgSalary) &gt;&gt; It.amt]
#-&gt; ERROR: cannot find &quot;amt&quot; ⋮</code></pre><h3><a class="nav-anchor" id="Aggregate-Combinators-1" href="#Aggregate-Combinators-1">Aggregate Combinators</a></h3><p>There are other aggregate combinators, such as <code>Min</code>, <code>Max</code>, and <code>Sum</code>. They could be used to create a statistical measure.</p><pre><code class="language-julia">using Statistics: mean
Stats(X) =
    Record(
        :count =&gt; Count(X),
        :mean =&gt; floor.(Int, mean.(X)),
        :min =&gt; Min(X),
        :max =&gt; Max(X),
        :sum =&gt; Sum(X))

chicago[
    :salary_stats_for_all_employees =&gt;
        Stats(It.department.employee.salary)]
#=&gt;
│ salary_stats_for_all_employees      │
│ count  mean   min    max     sum    │
┼─────────────────────────────────────┼
│     3  92314  80016  101442  276942 │
=#</code></pre><p>These statistics could be computed for each department.</p><pre><code class="language-julia">chicago[
    It.department &gt;&gt;
    Record(
        It.name,
        :salary_stats =&gt; Stats(It.employee.salary))]
#=&gt;
  │ department                              │
  │ name    salary_stats                    │
──┼─────────────────────────────────────────┼
1 │ POLICE  2, 90729, 80016, 101442, 181458 │
2 │ FIRE    1, 95484, 95484, 95484, 95484   │
=#</code></pre><p>To inspect the definition of <code>Stats</code> you could build a query, <code>Stats(It)</code>, and show it.</p><pre><code class="language-julia">Stats(It)
#=&gt;
Record(:count =&gt; Count(It),
       :mean =&gt; floor.(Int, mean.(It)),
       :min =&gt; Min(It),
       :max =&gt; Max(It),
       :sum =&gt; Sum(It))
=#</code></pre><p>Parameterized queries, such as <code>Stats</code>, can also be tagged. Then, when they are displayed with an argument, the definition is suppressed.</p><pre><code class="language-julia">Stats(X) =
  Tag(:Stats, (X,),
    Record(
        :count =&gt; Count(X),
        :mean =&gt; floor.(Int, mean.(X)),
        :min =&gt; Min(X),
        :max =&gt; Max(X),
        :sum =&gt; Sum(X)))
Stats(It)
#-&gt; Stats(It)</code></pre><p>Suppressing the definition of parameterized queries such as <code>Stats</code> makes the incremental composition easier to follow.</p><pre><code class="language-julia">MyQuery = It.department
MyQuery &gt;&gt;= Stats(It.employee.salary)
#=&gt;
It.department &gt;&gt; Stats(It.employee.salary)
=#</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../thinking/"><span class="direction">Next</span><span class="title">Thinking in Combinators</span></a></footer></article></body></html>
