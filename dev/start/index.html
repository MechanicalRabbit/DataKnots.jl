<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Getting Started</a><ul class="internal"><li><a class="toctext" href="#Installation-Instructions-1">Installation Instructions</a></li><li><a class="toctext" href="#Quick-Tutorial-1">Quick Tutorial</a></li></ul></li><li><a class="toctext" href="../thinking/">Thinking in Combinators</a></li><li><a class="toctext" href="../reference/">Reference</a></li><li><a class="toctext" href="../implementation/">Implementation Guide</a></li><li><a class="toctext" href="../simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Getting Started</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/start.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><p>DataKnots is in active development and is not expected to be usable for general audiences. In particular, with the v0.1 release, there are no data source adapters.</p><h2><a class="nav-anchor" id="Installation-Instructions-1" href="#Installation-Instructions-1">Installation Instructions</a></h2><p>DataKnots.jl is a Julia library, but it is not yet registered with the Julia package manager.  To install it, run in the package shell (enter with <code>]</code> from the Julia shell):</p><pre><code class="language-juliarepl">pkg&gt; add https://github.com/rbt-lang/DataKnots.jl</code></pre><p>DataKnots.jl requires Julia 1.0 or higher.</p><p>If you want to modify the source code of DataKnots.jl, you need to install it in development mode with:</p><pre><code class="language-juliarepl">pkg&gt; dev https://github.com/rbt-lang/DataKnots.jl</code></pre><h2><a class="nav-anchor" id="Quick-Tutorial-1" href="#Quick-Tutorial-1">Quick Tutorial</a></h2><p>Consider the following database containing a tiny cross-section of public data from Chicago, represented as nested <code>NamedTuple</code> and <code>Vector</code> objects.</p><pre><code class="language-julia">chicago_data =
    (department = [
     (name = &quot;POLICE&quot;, employee = [
       (name = &quot;JEFFERY A&quot;, position = &quot;SERGEANT&quot;,
        salary = 101442),
       (name = &quot;NANCY A&quot;, position = &quot;POLICE OFFICER&quot;,
        salary = 80016)]),
     (name = &quot;FIRE&quot;, employee = [
       (name = &quot;DANIEL A&quot;, position = &quot;FIRE FIGHTER-EMT&quot;,
        salary = 95484)])],);</code></pre><p>To query this data via DataKnots, we need to first convert it into a <em>knot</em> structure. This data could then be converted back into Julia structure via <code>get</code> function.</p><pre><code class="language-julia">using DataKnots
ChicagoData = DataKnot(chicago_data)
typeof(get(ChicagoData))
#-&gt; NamedTuple{(:department,),⋮</code></pre><p>By convention, it is helpful if the top-level object in a data structure be a named tuple. In our source dataset, the very top of the tree is named <code>&quot;department&quot;</code>.</p><h3><a class="nav-anchor" id="Navigating-1" href="#Navigating-1">Navigating</a></h3><p>Pipeline queries can be <code>run</code> on data knot. For example, to list all department names, we write <code>It.department.name</code>:</p><pre><code class="language-julia">run(ChicagoData, It.department.name)
#=&gt;
  │ name   │
──┼────────┤
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>In this pipeline, <code>It</code> means &quot;use the current input&quot; and the dotted notation let one navigate via hierarchy. Navigation context matters. For example, given the data provided, <code>employee</code> tuples are not directly accessible from the root of the dataset.</p><pre><code class="language-julia">run(ChicagoData, It.employee)
#-&gt; ERROR: cannot find employee ⋮</code></pre><p>The <code>employee</code> tuples can be accessed by navigating though <code>department</code> tuples.</p><pre><code class="language-julia">run(ChicagoData, It.department.employee)
#=&gt;
  │ employee                            │
  │ name       position          salary │
──┼─────────────────────────────────────┤
1 │ JEFFERY A  SERGEANT          101442 │
2 │ NANCY A    POLICE OFFICER     80016 │
3 │ DANIEL A   FIRE FIGHTER-EMT   95484 │
=#</code></pre><p>Notice that nested lists are flattened as necessary. </p><h3><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h3><p>Dotted expressions above are a syntax shorthand for the <code>Lookup</code> primitive together with pipeline composition (<code>&gt;&gt;</code>). We could list departments in this dataset more formally:</p><pre><code class="language-julia">Department, Employee, Name, Salary = 
   Lookup.([:department, :employee, :name, :salary])

run(ChicagoData, Department &gt;&gt; Name)
#=&gt;
  │ name   │
──┼────────┤
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>Since <code>It</code> is the pipeline identity, the query above could be equivalently written:</p><pre><code class="language-julia">run(ChicagoData, It &gt;&gt; Department &gt;&gt; It &gt;&gt; Name)
#=&gt;
  │ name   │
──┼────────┤
1 │ POLICE │
2 │ FIRE   │
=#</code></pre><p>From here on, we use <code>It.department</code>, not <code>Lookup(:department)</code>.</p><h3><a class="nav-anchor" id="Counting-1" href="#Counting-1">Counting</a></h3><p>This example returns the number of departments in the dataset.</p><pre><code class="language-julia">run(ChicagoData, Count(It.department))
#=&gt;
│ DataKnot │
├──────────┤
│        2 │
=#</code></pre><p>Using pipeline composition (<code>&gt;&gt;</code>), we can perform <code>Count</code> in a nested context; in this case, we count <code>employee</code> records within each <code>department</code>.</p><pre><code class="language-julia">run(ChicagoData,
    It.department
    &gt;&gt; Count(It.employee))
#=&gt;
  │ DataKnot │
──┼──────────┤
1 │        2 │
2 │        1 │
=#</code></pre><p>In this toy dataset, we see that the 1st department, <code>&quot;POLICE&quot;</code>, has <code>2</code> employees, while the 2nd, <code>&quot;FIRE&quot;</code> only has <code>1</code>.</p><h3><a class="nav-anchor" id="Labels-1" href="#Labels-1">Labels</a></h3><p>Since DataKnots is compositional, reusable pipeline expressions can be factored. These expressions can be given a <code>Label</code>.</p><pre><code class="language-julia">EmployeeCount = 
  Count(It.employee) &gt;&gt; Label(:count)

run(ChicagoData,
    It.department
    &gt;&gt; EmployeeCount)
#=&gt;
  │ count │
──┼───────┤
1 │     2 │
2 │     1 │
=#</code></pre><p>The pair syntax (<code>=&gt;</code>) sugar will also attach an expression label.</p><pre><code class="language-julia">run(ChicagoData, 
    :dept_count =&gt; 
      Count(It.department))
#=&gt;
│ dept_count │
├────────────┤
│          2 │
=#</code></pre><h3><a class="nav-anchor" id="Records-1" href="#Records-1">Records</a></h3><p>Sometimes it is helpful to return two or more values in tandem; this can be done with <code>Record</code>.</p><pre><code class="language-julia">run(ChicagoData,
    It.department
    &gt;&gt; Record(It.name,
              EmployeeCount))
#=&gt;
  │ department    │
  │ name    count │
──┼───────────────┤
1 │ POLICE      2 │
2 │ FIRE        1 │
=#</code></pre><p>Records can be nested. We could build a result that includes department names and, within each department, employee names.</p><pre><code class="language-julia">run(ChicagoData,
    It.department
    &gt;&gt; Record(It.name,
         It.employee &gt;&gt;
         Record(It.name, It.salary)))
#=&gt;
  │ department                                │
  │ name    employee                          │
──┼───────────────────────────────────────────┤
1 │ POLICE  JEFFERY A, 101442; NANCY A, 80016 │
2 │ FIRE    DANIEL A, 95484                   │
=#</code></pre><p>In the nested display, commas are used to separate fields and semi-colons separate values.</p><h3><a class="nav-anchor" id="Filtering-Data-1" href="#Filtering-Data-1">Filtering Data</a></h3><p>Filtering data is also contextual. Here we list department names who have exactly one employee.</p><pre><code class="language-julia">run(ChicagoData,
    It.department
    &gt;&gt; Filter(EmployeeCount .== 1)
    &gt;&gt; Record(It.name, EmployeeCount))
#=&gt;
  │ department  │
  │ name  count │
──┼─────────────┤
1 │ FIRE      1 │
=#</code></pre><p>In in pipeline expressions, the broadcast variant of common operators, such as <code>.==</code> are to be used.</p><pre><code class="language-julia">run(ChicagoData,
    It.department
    &gt;&gt; Filter(EmployeeCount == 1)
    &gt;&gt; Record(It.name, EmployeeCount))
#=&gt;
ERROR: AssertionError: eltype(input) &lt;: AbstractVector
=#</code></pre><p>Most broadcast operators just work.</p><pre><code class="language-julia">run(ChicagoData,
    It.department.employee
    &gt;&gt; Filter(It.salary .&gt; 100000)
    &gt;&gt; It.name)
#=&gt;
  │ name      │
──┼───────────┤
1 │ JEFFERY A │
=#</code></pre><h3><a class="nav-anchor" id="Lifting-1" href="#Lifting-1">Lifting</a></h3><p>Arbitrary Julia functions can also be used within DataKnots using the broadcast notation. For example, <code>occursin</code> returns a boolean value if its 1st argument is found within another. Hence, it could be used within a filter expression.</p><pre><code class="language-julia">run(ChicagoData,
    It.department.employee.name
    &gt;&gt; Filter(occursin.(&quot;AN&quot;, It)))
#=&gt;
  │ name     │
──┼──────────┤
1 │ NANCY A  │
2 │ DANIEL A │
=#</code></pre><p>Aggregate julia functions, such as <code>mean</code>, can also be used.</p><pre><code class="language-julia">using Statistics: mean

MeanSalary = (
  mean.(It.employee.salary) 
  &gt;&gt; Label(:mean_salary))

run(ChicagoData,
    It.department
    &gt;&gt; Record(It.name, MeanSalary))
#=&gt;
  │ department          │
  │ name    mean_salary │
──┼─────────────────────┤
1 │ POLICE      90729.0 │
2 │ FIRE        95484.0 │
=#</code></pre><p>The more general form of <code>Lift</code> can be used to handle more complex situations. Its usage is documented in the reference.</p><h3><a class="nav-anchor" id="Keeping-Values-1" href="#Keeping-Values-1">Keeping Values</a></h3><p>It&#39;s possible to <code>Keep</code> an expression&#39;s result, so that it is available within subsequent computations. For example, you may want to return records of an employee&#39;s name with their corresponding department&#39;s name.</p><pre><code class="language-julia">    run(ChicagoData, 
         It.department 
         &gt;&gt; Keep(:dept_name =&gt; It.name) 
         &gt;&gt; It.employee 
         &gt;&gt; Record(It.name, It.dept_name))
    #=&gt;
      │ employee             │
      │ name       dept_name │
    ──┼──────────────────────┤
    1 │ JEFFERY A  POLICE    │
    2 │ NANCY A    POLICE    │
    3 │ DANIEL A   FIRE      │
    =#</code></pre><p>Suppose we wish, for a given department, to return employees having a salary greater than that department&#39;s average. </p><pre><code class="language-julia">    run(ChicagoData, 
         It.department 
         &gt;&gt; Keep(MeanSalary)
         &gt;&gt; It.employee 
         &gt;&gt; Filter(It.salary .&gt; It.mean_salary))
    #=&gt;
      │ employee                    │
      │ name       position  salary │
    ──┼─────────────────────────────┤
    1 │ JEFFERY A  SERGEANT  101442 │
    =#</code></pre><h3><a class="nav-anchor" id="Parameters-1" href="#Parameters-1">Parameters</a></h3><p>Suppose we want a parameterized pipeline that when passed a given salary would return employees having greater than that salary.</p><pre><code class="language-julia">EmployeesOver(N) = 
  Given(:avg =&gt; N,
   It.department
   &gt;&gt; It.employee
   &gt;&gt; Filter(It.salary .&gt; It.avg))

run(ChicagoData, EmployeesOver(100000))
#=&gt;
  │ employee                    │
  │ name       position  salary │
──┼─────────────────────────────┤
1 │ JEFFERY A  SERGEANT  101442 │
=#</code></pre><p>This same query can be written as a parameter to <code>run</code>.</p><pre><code class="language-julia">run(ChicagoData, EmployeesOver(It.amt), amt=100000)
#=&gt;
  │ employee                    │
  │ name       position  salary │
──┼─────────────────────────────┤
1 │ JEFFERY A  SERGEANT  101442 │
=#</code></pre><p>Now suppose we wish to run this to return employees having greater than average salary?  We could compute the average salary across all employees as follows.</p><pre><code class="language-julia">AvgSalary = 
   :avg_salary =&gt; mean.(It.department.employee.salary)

run(ChicagoData, AvgSalary)
#=&gt;
│ avg_salary │
├────────────┤
│    92314.0 │
=#</code></pre><p>We could then combine these two pipelines.</p><pre><code class="language-julia">run(ChicagoData, EmployeesOver(AvgSalary))
#=&gt;
  │ employee                            │
  │ name       position          salary │
──┼─────────────────────────────────────┤
1 │ JEFFERY A  SERGEANT          101442 │
2 │ DANIEL A   FIRE FIGHTER-EMT   95484 │
=#</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../thinking/"><span class="direction">Next</span><span class="title">Thinking in Combinators</span></a></footer></article></body></html>
