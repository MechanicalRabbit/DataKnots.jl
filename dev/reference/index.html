<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · DataKnots.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DataKnots.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Queries for Data Analysts</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../highlypaid/">Who is Highly Paid?</a></li></ul></li><li><span class="tocitem">Reference Manual</span><ul><li><a class="tocitem" href="../primer/">Thinking in Queries</a></li><li><a class="tocitem" href="../tutorial/">Embedded Query Interface</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul></li><li><span class="tocitem">Implementer&#39;s Guide</span><ul><li><a class="tocitem" href="../vectors/">Column Store</a></li><li><a class="tocitem" href="../pipelines/">Pipeline Algebra</a></li><li><a class="tocitem" href="../shapes/">Shapes and Signatures</a></li><li><a class="tocitem" href="../knots/">Data Knots</a></li><li><a class="tocitem" href="../queries/">Query Algebra</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference Manual</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/master/doc/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DataKnots.It" href="#DataKnots.It"><code>DataKnots.It</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">It :: AbstractQuery</code></pre><p>In a query expression, use <code>It</code> to refer to the query&#39;s input.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(3) &gt;&gt; (It .+ 1)]
┼───┼
│ 4 │</code></pre><p><code>It</code> is the identity with respect to query composition.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; It]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre><p><code>It</code> provides a shorthand notation for data navigation using <code>Get</code>, so that <code>It.a.x</code> is equivalent to <code>Get(:a) &gt;&gt; Get(:x)</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((a=(x=1,y=2),)) &gt;&gt; It.a]
│ a    │
│ x  y │
┼──────┼
│ 1  2 │

julia&gt; unitknot[Lift((a=(x=1,y=2),)) &gt;&gt; It.a.x]
│ x │
┼───┼
│ 1 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L72-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.unitknot" href="#DataKnots.unitknot"><code>DataKnots.unitknot</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">unitknot</code></pre><p>The unit knot holds an empty tuple.</p><pre><code class="language-julia-repl">julia&gt; unitknot
┼──┼
│  │</code></pre><p>The <code>unitknot</code> is useful for constructing queries that do not originate from another datasource.</p><pre><code class="language-julia-repl">julia&gt; unitknot[&quot;Hello&quot;]
┼───────┼
│ Hello │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/knots.jl#L165-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.DataKnot" href="#DataKnots.DataKnot"><code>DataKnots.DataKnot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DataKnot(Pair{Symbol}...)</code></pre><p>This constructor binds names to datasets, so that they could be used to start a query. The knot created has a single top-level record, each with its own value.</p><pre><code class="language-julia-repl">julia&gt; test_knot = DataKnot(:dataset=&gt;&#39;a&#39;:&#39;c&#39;)
│ dataset │
┼─────────┼
│ a; b; c │

julia&gt; test_knot[It.dataset]
  │ dataset │
──┼─────────┼
1 │ a       │
2 │ b       │
3 │ c       │</code></pre><p>Arguments to this constructor are run though <code>convert</code>.</p><hr/><pre><code class="language-none">convert(DataKnot, val)</code></pre><p>This converter wraps a given value so that it could be used to start a query.</p><p>An empty knot can be constructed with <code>missing</code>.</p><pre><code class="language-julia-repl">julia&gt; convert(DataKnot, missing)
(empty)</code></pre><p>A plural knot is constructed from a vector.</p><pre><code class="language-julia-repl">julia&gt; convert(DataKnot, &#39;a&#39;:&#39;c&#39;)
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre><p>An object that complies with the <code>Table</code> interface, such as a <code>CSV</code> file, can be converted to a DataKnot.</p><pre><code class="language-julia-repl">julia&gt; using CSV;

julia&gt; csv_file = &quot;k,v\na,1\nb,\n&quot; |&gt; IOBuffer |&gt; CSV.File;

julia&gt; convert(DataKnot, csv_file)
  │ k  v │
──┼──────┼
1 │ a  1 │
2 │ b    │</code></pre><hr/><pre><code class="language-none">get(::DataKnot)</code></pre><p>Use <code>get</code> to extract the underlying value held by a knot.</p><pre><code class="language-julia-repl">julia&gt; get(convert(DataKnot, &quot;Hello World&quot;))
&quot;Hello World&quot;</code></pre><hr/><pre><code class="language-none">getindex(::DataKnot, X; kwargs...)</code></pre><p>We can query a knot using array indexing notation.</p><pre><code class="language-julia-repl">julia&gt; convert(DataKnot, (dataset=&#39;a&#39;:&#39;c&#39;,))[Count(It.dataset)]
┼───┼
│ 3 │</code></pre><p>Query parameters are provided as keyword arguments.</p><pre><code class="language-julia-repl">julia&gt; convert(DataKnot, 1:3)[PWR=2, It .^ It.PWR]
──┼───┼
1 │ 1 │
2 │ 4 │
3 │ 9 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/knots.jl#L16-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Collect-Tuple{Any, Vararg{Any, N} where N}" href="#DataKnots.Collect-Tuple{Any, Vararg{Any, N} where N}"><code>DataKnots.Collect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Collect(X₁, X₂ … Xₙ) :: Query</code></pre><p>In the combinator form, <code>Collect(X₁, X₂ … Xₙ)</code> adds fields <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code> to the input record.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Record(:x =&gt; 1) &gt;&gt; Collect(:y =&gt; 2 .* It.x)]
│ x  y │
┼──────┼
│ 1  2 │</code></pre><p>If a field already exists, it is replaced.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Record(:x =&gt; 1) &gt;&gt; Collect(:x =&gt; 2 .* It.x)]
│ x │
┼───┼
│ 2 │</code></pre><p>To remove a field, assign it the value <code>nothing</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Record(:x =&gt; 1) &gt;&gt; Collect(:y =&gt; 2 .* It.x, :x =&gt; nothing)]
│ y │
┼───┼
│ 2 │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Record) :: Query</code></pre><p>In the query form, <code>Collect</code> appends a field to the source record.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(1) &gt;&gt; Label(:x) &gt;&gt; Collect]
│ x │
┼───┼
│ 1 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L806-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Count-Tuple{Any}" href="#DataKnots.Count-Tuple{Any}"><code>DataKnots.Count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Count(X) :: Query</code></pre><p>In the combinator form, <code>Count(X)</code> emits the number of elements produced by <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[Count(X)]
┼───┼
│ 3 │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Count) :: Query</code></pre><p>In the query form, <code>Count</code> emits the number of elements in its input.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[X &gt;&gt; Count]
┼───┼
│ 3 │</code></pre><p>To limit the scope of aggregation, use <code>Each</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[Lift(1:3) &gt;&gt; Each(X &gt;&gt; Count)]
──┼───┼
1 │ 3 │
2 │ 3 │
3 │ 3 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1544-L1583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Drop-Tuple{Any}" href="#DataKnots.Drop-Tuple{Any}"><code>DataKnots.Drop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Drop(N) :: Query</code></pre><p>This query drops the first <code>N</code> elements of its input, preserving the rest.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Drop(2)]
──┼───┼
1 │ c │</code></pre><p><code>Drop(-N)</code> takes the last <code>N</code> elements.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Drop(-2)]
──┼───┼
1 │ b │
2 │ c │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2109-L2129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Each-Tuple{Any}" href="#DataKnots.Each-Tuple{Any}"><code>DataKnots.Each</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Each(X) :: Query</code></pre><p>This evaluates <code>X</code> elementwise.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Count;

julia&gt; unitknot[Lift(1:3) &gt;&gt; Each(X)]
──┼───┼
1 │ 3 │
2 │ 3 │
3 │ 3 │</code></pre><p>Compare this with the query without <code>Each</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Count;

julia&gt; unitknot[Lift(1:3) &gt;&gt; X]
┼───┼
│ 9 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1143-L1167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Exists-Tuple{Any}" href="#DataKnots.Exists-Tuple{Any}"><code>DataKnots.Exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Exists(X) :: Query</code></pre><p>In the combinator form, <code>Exists(X)</code> emits a boolean testing if <code>X</code> produces any elements.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[Exists(X)]
┼──────┼
│ true │</code></pre><p>When the query argument <code>X</code> is empty, <code>Exists(X)</code> produces <code>false</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift([]);

julia&gt; unitknot[Exists(X)]
┼───────┼
│ false │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Exists) :: Query</code></pre><p>In the query form, <code>Exists</code> emits a boolean testing if its input has any elements.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[X &gt;&gt; Exists]
┼──────┼
│ true │</code></pre><p>When the query input is empty, <code>Exists</code> produces <code>false</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift([]);

julia&gt; unitknot[X &gt;&gt; Exists]
┼───────┼
│ false │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1595-L1641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Filter-Tuple{Any}" href="#DataKnots.Filter-Tuple{Any}"><code>DataKnots.Filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Filter(X) :: Query</code></pre><p>This query emits the elements from its input that satisfy a given condition.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(1:5) &gt;&gt; Filter(isodd.(It))]
──┼───┼
1 │ 1 │
2 │ 3 │
3 │ 5 │</code></pre><p>When the predicate query produces an empty output, the condition is presumed to have failed.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Filter(missing)]
(empty)</code></pre><p>When the predicate produces plural output, the condition succeeds if at least one output value is <code>true</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Filter([true,false])]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1847-L1879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.First-Tuple{Any}" href="#DataKnots.First-Tuple{Any}"><code>DataKnots.First</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">First(X) :: Query</code></pre><p>In the combinator form, <code>First(X)</code> emits the first element produced by its argument <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[First(X)]
┼───┼
│ a │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; First) :: Query</code></pre><p>In the query form, <code>First</code> emits the first element of its input.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[X &gt;&gt; First]
┼───┼
│ a │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1918-L1943">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Get-Tuple{Any}" href="#DataKnots.Get-Tuple{Any}"><code>DataKnots.Get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Get(lbl::Symbol) :: Query</code></pre><p>This query extracts a field value by its label.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((x=1, y=2)) &gt;&gt; Get(:x)]
│ x │
┼───┼
│ 1 │</code></pre><p>This has a shorthand form using <code>It</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((x=1, y=2)) &gt;&gt; It.x]
│ x │
┼───┼
│ 1 │</code></pre><p>With unlabeled fields, ordinal labels (A, B, ...) can be used.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((1,2)) &gt;&gt; It.B]
┼───┼
│ 2 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1279-L1307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Given-Tuple{Any, Vararg{Any, N} where N}" href="#DataKnots.Given-Tuple{Any, Vararg{Any, N} where N}"><code>DataKnots.Given</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Given(X₁, X₂ … Xₙ, Q) :: Query</code></pre><p>This evaluates <code>Q</code> in a context augmented with named parameters added by a set of queries.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Given(:x =&gt; 2, It.x .+ 1)]
┼───┼
│ 3 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1475-L1486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Group-Tuple" href="#DataKnots.Group-Tuple"><code>DataKnots.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Group(X₁, X₂ … Xₙ) :: Query</code></pre><p>This query groups the input data by the keys <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(1:5) &gt;&gt; Group(isodd.(It))]
  │ #A     #B      │
──┼────────────────┼
1 │ false  2; 4    │
2 │  true  1; 3; 5 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2257-L2269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Is-Tuple{Type}" href="#DataKnots.Is-Tuple{Type}"><code>DataKnots.Is</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Is(T::Type) :: Query</code></pre><p>This query asserts that the input has the type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2297-L2301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Is0to1-Tuple{Any}" href="#DataKnots.Is0to1-Tuple{Any}"><code>DataKnots.Is0to1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Is0to1(X) :: Query</code></pre><p>This query asserts that <code>X</code> emits 0 or 1 element.</p><hr/><pre><code class="language-none">Each(X &gt;&gt; Is0to1) :: Query</code></pre><p>In this form, <code>Is0to1</code> asserts that its input contains 0 or 1 element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2322-L2332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Is0toN-Tuple{Any}" href="#DataKnots.Is0toN-Tuple{Any}"><code>DataKnots.Is0toN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Is0toN(X) :: Query</code></pre><p>This query asserts that <code>X</code> may emit any number of elements.</p><hr/><pre><code class="language-none">Each(X &gt;&gt; Is0toN) :: Query</code></pre><p>In this form, <code>Is0toN</code> asserts that its input contains any number of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2335-L2345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Is1to1-Tuple{Any}" href="#DataKnots.Is1to1-Tuple{Any}"><code>DataKnots.Is1to1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Is1to1(X) :: Query</code></pre><p>This query asserts that <code>X</code> emits 1 element.</p><hr/><pre><code class="language-none">Each(X &gt;&gt; Is1to1) :: Query</code></pre><p>In this form, <code>Is1to1</code> asserts that its input contains 1 element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2348-L2358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Is1toN-Tuple{Any}" href="#DataKnots.Is1toN-Tuple{Any}"><code>DataKnots.Is1toN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Is1toN(X) :: Query</code></pre><p>This query asserts that <code>X</code> emits 1 or more elements.</p><hr/><pre><code class="language-none">Each(X &gt;&gt; Is1toN) :: Query</code></pre><p>In this form, <code>Is1toN</code> asserts that its input contains 1 or more elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2361-L2371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Join-Tuple{Any}" href="#DataKnots.Join-Tuple{Any}"><code>DataKnots.Join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Join(X) :: Query</code></pre><p><code>Join(X)</code> evaluates <code>X</code> in the source context and adds it as a field to the input record.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Record(:x =&gt; 1) &gt;&gt; Each(Record(:y =&gt; 2 .* It.x) &gt;&gt; Join(It.x))]
│ y  x │
┼──────┼
│ 2  1 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L940-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Keep-Tuple{Any, Vararg{Any, N} where N}" href="#DataKnots.Keep-Tuple{Any, Vararg{Any, N} where N}"><code>DataKnots.Keep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Keep(X₁, X₂ … Xₙ) :: Query</code></pre><p><code>Keep</code> evaluates named queries, making their results available for subsequent computation.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Keep(:x =&gt; 2) &gt;&gt; It.x]
│ x │
┼───┼
│ 2 │</code></pre><p><code>Keep</code> does not otherwise change its input.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(1) &gt;&gt; Keep(:x =&gt; 2) &gt;&gt; (It .+ It.x)]
┼───┼
│ 3 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1430-L1450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Label-Tuple{Symbol}" href="#DataKnots.Label-Tuple{Symbol}"><code>DataKnots.Label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Label(lbl::Symbol) :: Query</code></pre><p>This assigns a label to the output.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&quot;Hello World&quot;) &gt;&gt; Label(:greeting)]
│ greeting    │
┼─────────────┼
│ Hello World │</code></pre><p>A label could also be assigned using the <code>=&gt;</code> operator.</p><pre><code class="language-julia-repl">julia&gt; unitknot[:greeting =&gt; Lift(&quot;Hello World&quot;)]
│ greeting    │
┼─────────────┼
│ Hello World │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1181-L1201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Last-Tuple{Any}" href="#DataKnots.Last-Tuple{Any}"><code>DataKnots.Last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Last(X) :: Query</code></pre><p>In the combinator form, <code>Last(X)</code> emits the last element produced by its argument <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[Last(X)]
┼───┼
│ c │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Last) :: Query</code></pre><p>In the query form, <code>Last</code> emits the last element of its input.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;c&#39;);

julia&gt; unitknot[X &gt;&gt; Last]
┼───┼
│ c │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1946-L1971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Lift-Tuple{Any, Tuple}" href="#DataKnots.Lift-Tuple{Any, Tuple}"><code>DataKnots.Lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Lift(f, (X₁, X₂ … Xₙ)) :: Query</code></pre><p><code>Lift</code> lets you use a function as a query combinator.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((x=1, y=2)) &gt;&gt; Lift(+, (It.x, It.y))]
┼───┼
│ 3 │</code></pre><p><code>Lift</code> is implicitly used when a function is broadcast over queries.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((x=1, y=2)) &gt;&gt; (It.x .+ It.y)]
┼───┼
│ 3 │</code></pre><p>Functions accepting a <code>AbstractVector</code> can be used with plural queries.</p><pre><code class="language-julia-repl">julia&gt; unitknot[sum.(Lift(1:3))]
┼───┼
│ 6 │</code></pre><p>Functions returning <code>AbstractVector</code> become plural queries.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift((x=&#39;a&#39;, y=&#39;c&#39;)) &gt;&gt; Lift(:, (It.x, It.y))]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1037-L1075">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Lift-Tuple{Any}" href="#DataKnots.Lift-Tuple{Any}"><code>DataKnots.Lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Lift(val) :: Query</code></pre><p>This converts any value to a constant query.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&quot;Hello&quot;)]
┼───────┼
│ Hello │</code></pre><p><code>AbstractVector</code> objects become plural queries.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;)]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre><p>To specify the vector cardinality, add <code>:x0to1</code>, <code>:x0toN</code>, <code>:x1to1</code>, or <code>:x1toN</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;, :x1toN)]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre><p>The <code>missing</code> value makes an query with no output.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(missing)]
(empty)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L992-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Max-Tuple{Any}" href="#DataKnots.Max-Tuple{Any}"><code>DataKnots.Max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> Max(X) :: Query</code></pre><p>In the combinator form, <code>Max(X)</code> finds the maximum among the elements produced by <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(1:3);

julia&gt; unitknot[Max(X)]
┼───┼
│ 3 │</code></pre><p>The <code>Max</code> of an empty input is empty.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Max(Int[])]
(empty)</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Max) :: Query</code></pre><p>In the query form, <code>Max</code> finds the maximum of its input elements.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(1:3);

julia&gt; unitknot[X &gt;&gt; Max]
┼───┼
│ 3 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1695-L1729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Min-Tuple{Any}" href="#DataKnots.Min-Tuple{Any}"><code>DataKnots.Min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> Min(X) :: Query</code></pre><p>In the combinator form, <code>Min(X)</code> finds the minimum among the elements produced by <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(1:3);

julia&gt; unitknot[Min(X)]
┼───┼
│ 1 │</code></pre><p>The <code>Min</code> of an empty input is empty.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Min(Int[])]
(empty)</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Min) :: Query</code></pre><p>In the query form, <code>Min</code> finds the minimum of its input elements.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(1:3);

julia&gt; unitknot[X &gt;&gt; Min]
┼───┼
│ 1 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1736-L1770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Mix-Tuple" href="#DataKnots.Mix-Tuple"><code>DataKnots.Mix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Mix(X₁, X₂ … Xₙ) :: Query</code></pre><p>This query emits records containing every combination of elements generated by <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Mix(Lift(1:2), Lift(&#39;a&#39;:&#39;c&#39;))]
  │ #A  #B │
──┼────────┼
1 │  1  a  │
2 │  1  b  │
3 │  1  c  │
4 │  2  a  │
5 │  2  b  │
6 │  2  c  │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L688-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Nth-Tuple{Any, Any}" href="#DataKnots.Nth-Tuple{Any, Any}"><code>DataKnots.Nth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Nth(X, N) :: Query</code></pre><p>In the combinator form, <code>Nth(X, N)</code> emits the <code>N</code>th element produced by its argument <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;d&#39;);

julia&gt; N = Count(X) .÷ 2;

julia&gt; unitknot[Nth(X, N)]
┼───┼
│ b │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Nth(N)) :: Query</code></pre><p>In the query form, <code>Nth(N)</code> emits the <code>N</code>th element produced by its input.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(&#39;a&#39;:&#39;d&#39;);

julia&gt; N = Count(X) .÷ 2;

julia&gt; unitknot[X &gt;&gt; Nth(N)]
┼───┼
│ b │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1974-L2003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Record-Tuple" href="#DataKnots.Record-Tuple"><code>DataKnots.Record</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Record(X₁, X₂ … Xₙ) :: Query</code></pre><p>This query emits a record with fields generated by <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(1:3) &gt;&gt; Record(It, It .* It)]
  │ #A  #B │
──┼────────┼
1 │  1   1 │
2 │  2   4 │
3 │  3   9 │</code></pre><p>Field labels are inherited from queries.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(1:3) &gt;&gt; Record(:x =&gt; It,
                                    :x² =&gt; It .* It)]
  │ x  x² │
──┼───────┼
1 │ 1   1 │
2 │ 2   4 │
3 │ 3   9 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L606-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Sum-Tuple{Any}" href="#DataKnots.Sum-Tuple{Any}"><code>DataKnots.Sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sum(X) :: Query</code></pre><p>In the combinator form, <code>Sum(X)</code> emits the sum of elements produced by <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(1:3);

julia&gt; unitknot[Sum(X)]
┼───┼
│ 6 │</code></pre><p>The <code>Sum</code> of an empty input is <code>0</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Sum(Int[])]
┼───┼
│ 0 │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Sum) :: Query</code></pre><p>In the query form, <code>Sum</code> emits the sum of input elements.</p><pre><code class="language-julia-repl">julia&gt; X = Lift(1:3);

julia&gt; unitknot[X &gt;&gt; Sum]
┼───┼
│ 6 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1653-L1688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Tag-Tuple{Symbol, Any}" href="#DataKnots.Tag-Tuple{Symbol, Any}"><code>DataKnots.Tag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Tag(name::Symbol, F) :: Query</code></pre><p>This provides a substitute name for a query.</p><pre><code class="language-julia-repl">julia&gt; IncIt = It .+ 1
It .+ 1

julia&gt; IncIt = Tag(:IncIt, It .+ 1)
IncIt</code></pre><hr/><pre><code class="language-none">Tag(name::Symbol, (X₁, X₂ … Xₙ), F) :: Query</code></pre><p>This provides a substitute name for a query combinator.</p><pre><code class="language-julia-repl">julia&gt; Inc(X) = Lift(+, (X, 1));

julia&gt; Inc(It)
Lift(+, (It, 1))

julia&gt; Inc(X) = Tag(:Inc, (X,), Lift(+, (X, 1)));

julia&gt; Inc(It)
Inc(It)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L1219-L1249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Take-Tuple{Any}" href="#DataKnots.Take-Tuple{Any}"><code>DataKnots.Take</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Take(N) :: Query</code></pre><p>This query preserves the first <code>N</code> elements of its input, dropping the rest.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Take(2)]
──┼───┼
1 │ a │
2 │ b │</code></pre><p><code>Take(-N)</code> drops the last <code>N</code> elements.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Take(-2)]
──┼───┼
1 │ a │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2085-L2105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.Unique-Tuple{Any}" href="#DataKnots.Unique-Tuple{Any}"><code>DataKnots.Unique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Unique(X) :: Query</code></pre><p>This query produces all distinct elements emitted by <code>X</code>.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Unique([&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;c&#39;])]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre><hr/><pre><code class="language-none">Each(X &gt;&gt; Unique) :: Query</code></pre><p>In the query form, <code>Unique</code> produces all distinct elements of its input.</p><pre><code class="language-julia-repl">julia&gt; unitknot[Lift([&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;c&#39;]) &gt;&gt; Unique]
──┼───┼
1 │ a │
2 │ b │
3 │ c │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L2161-L2187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.@query-Tuple{Any, Vararg{Any, N} where N}" href="#DataKnots.@query-Tuple{Any, Vararg{Any, N} where N}"><code>DataKnots.@query</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia"> @query dataset expr param=...</code></pre><p>Applies the query to a dataset with a given set of parameters.</p><pre><code class="language-julia-repl">julia&gt; @query unitknot 2x+1 x=1
┼───┼
│ 3 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L189-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataKnots.@query-Tuple{Any}" href="#DataKnots.@query-Tuple{Any}"><code>DataKnots.@query</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia"> @query expr</code></pre><p>Creates a query object from a specialized path-like notation:</p><ul><li>bare identifiers are translated to navigation with <code>Get</code>;</li><li>query combinators, such as <code>Count(X)</code>, use lower-case names;</li><li>the period (<code>.</code>) is used for query composition (<code>&gt;&gt;</code>);</li><li>aggregate queries, such as <code>Count</code>, require parentheses;</li><li>records can be constructed using curly brackets, <code>{}</code>; and</li><li>functions and operators are lifted automatically.</li></ul><pre><code class="language-julia-repl">julia&gt; @query 2x+1
Lift(+, (Lift(*, (Lift(2), Get(:x))), Lift(1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/DataKnots.jl/blob/61a046fbcf09de41e63b2417dd972fff0a84e542/src/queries.jl#L168-L184">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Embedded Query Interface</a><a class="docs-footer-nextpage" href="../vectors/">Column Store »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 18 April 2021 03:20">Sunday 18 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
