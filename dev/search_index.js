var documenterSearchIndex = {"docs":
[{"location":"#DataKnots.jl-1","page":"Home","title":"DataKnots.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DataKnots is a Julia library for querying data with an extensible, practical and coherent algebra of query combinators.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"At this time, while we welcome feedback and contributions, DataKnots is not yet usable for general audiences.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"overview.md\",\n    \"tutorial.md\",\n    \"reference.md\",\n]\nDepth=2","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following documents outline conceptual topics and implementation details.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"primer.md\",\n    \"vectors.md\",\n    \"pipelines.md\",\n    \"shapes.md\",\n    \"knots.md\",\n    \"queries.md\",\n]\nDepth=1","category":"page"},{"location":"overview/#Overview-1","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"DataKnots is a toolkit for representing and querying complex structured data. It is designed for data analysts and domain experts (e.g. accountants, engineers, clinicians) who need to build and share domain-specific queries. This overview introduces DataKnots and its query algebra.","category":"page"},{"location":"overview/#Answering-an-Inquiry-1","page":"Overview","title":"Answering an Inquiry","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Let's discuss a particular inquiry: Which City of Chicago employees have salary higher than the average for their department?","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"We use a tiny selection of public data from the City of Chicago. This dataset includes employees and their annual salary.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"using CSV\n\nemployee_csv = \"\"\"\n    name,department,position,salary\n    \"ANTHONY A\",\"POLICE\",\"POLICE OFFICER\",72510\n    \"DANIEL A\",\"FIRE\",\"FIRE FIGHTER-EMT\",95484\n    \"JAMES A\",\"FIRE\",\"FIRE ENGINEER-EMT\",103350\n    \"JEFFERY A\",\"POLICE\",\"SERGEANT\",101442\n    \"NANCY A\",\"POLICE\",\"POLICE OFFICER\",80016\n    \"ROBERT K\",\"FIRE\",\"FIRE FIGHTER-EMT\",103272\n    \"\"\" |> IOBuffer |> CSV.File","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"To query this employee data, we convert it to a DataKnot, or just knot. In the DataKnot constructor, employee_csv is provided a label of employee.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"using DataKnots\n\nchicago = DataKnot(:employee => employee_csv)","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Then, to answer this inquiry, we query chicago as follows.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"using Statistics: mean\n\n@query chicago begin\n    employee\n    group(department)\n    keep(mean_salary => mean(employee.salary))\n    employee\n    filter(salary > mean_salary)\nend\n#=>\n  │ employee                                         │\n  │ name       department  position           salary │\n──┼──────────────────────────────────────────────────┼\n1 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │\n2 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │\n3 │ JEFFERY A  POLICE      SERGEANT           101442 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"This overview will proceed by incrementally reconstructing this query, showing how an analyst could explore data and independently arrive at the answer above.","category":"page"},{"location":"overview/#Basic-Queries-1","page":"Overview","title":"Basic Queries","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"DataKnots implements an algebra of queries. This algebra's elements, or queries, represent relationships among class entities and datatypes. Nouns, such as employee, department, and salary, are query primitives.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Let's query the chicago knot to list employee records.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee\n#=>\n  │ employee                                         │\n  │ name       department  position           salary │\n──┼──────────────────────────────────────────────────┼\n1 │ ANTHONY A  POLICE      POLICE OFFICER      72510 │\n2 │ DANIEL A   FIRE        FIRE FIGHTER-EMT    95484 │\n3 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │\n4 │ JEFFERY A  POLICE      SERGEANT           101442 │\n5 │ NANCY A    POLICE      POLICE OFFICER      80016 │\n6 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Verbs, such as group, keep, mean, and filter are query combinators. Combinators build new queries from existing ones. For example, count is a combinator.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago count(employee)\n#=>\n┼───┼\n│ 6 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Query composition (.) is also a combinator, it builds a query that applies the output of one query as the input to another. The query employee.name lists all employee names.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee.name\n#=>\n  │ name      │\n──┼───────────┼\n1 │ ANTHONY A │\n2 │ DANIEL A  │\n3 │ JAMES A   │\n4 │ JEFFERY A │\n5 │ NANCY A   │\n6 │ ROBERT K  │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Within a multi-line macro block, each individual statement is composed with its predecessor. Hence, we could write the query above without the period delimiter.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    name\nend","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Often it's helpful to see the combined output from correlated queries. The record combinator, which is delimited with a pair of curly braces {}, is used to build queries that produce parallel results.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee{name, salary}\n#=>\n  │ employee          │\n  │ name       salary │\n──┼───────────────────┼\n1 │ ANTHONY A   72510 │\n2 │ DANIEL A    95484 │\n3 │ JAMES A    103350 │\n4 │ JEFFERY A  101442 │\n5 │ NANCY A     80016 │\n6 │ ROBERT K   103272 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Within a @query macro, constants, such as 100_000 are treated as query primitives. These constant queries produce the same output regardless of the input they receive.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee{name, salary, threshold => 100_000}\n#=>\n  │ employee                     │\n  │ name       salary  threshold │\n──┼──────────────────────────────┼\n1 │ ANTHONY A   72510     100000 │\n2 │ DANIEL A    95484     100000 │\n3 │ JAMES A    103350     100000 │\n4 │ JEFFERY A  101442     100000 │\n5 │ NANCY A     80016     100000 │\n6 │ ROBERT K   103272     100000 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Functions, such as titlecase, and operators, such as greater-than (>), are treated as query combinators; that is, they are used to build queries from component queries.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    {name => titlecase(name), highly_paid => salary > 100_000}\nend\n#=>\n  │ employee               │\n  │ name       highly_paid │\n──┼────────────────────────┼\n1 │ Anthony A        false │\n2 │ Daniel A         false │\n3 │ James A           true │\n4 │ Jeffery A         true │\n5 │ Nancy A          false │\n6 │ Robert K          true │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Since salary > 100_000 is a predicate query, we can use the filter combinator to build the query filter(salary > 100_000).","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee.filter(salary > 100_000)\n#=>\n  │ employee                                         │\n  │ name       department  position           salary │\n──┼──────────────────────────────────────────────────┼\n1 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │\n2 │ JEFFERY A  POLICE      SERGEANT           101442 │\n3 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In this section, we have built a query that produces highly-compensated employees. More broadly, we've demonstrated how an algebra of queries permits us to combine previously proven queries in an intuitive way.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Before moving on to the original inquiry, we need to discuss how queries see their input.","category":"page"},{"location":"overview/#What-is-a-DataKnot?-1","page":"Overview","title":"What is a DataKnot?","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Input and output of queries are serialized as DataKnot objects. A DataKnot is a container that stores a hierarchy of labeled elements, where each element is either a scalar value, such as an integer or a string, or a collection of nested elements.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Recall the knot produced by the query employee{name, salary}.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee{name, salary}\n#=>\n  │ employee          │\n  │ name       salary │\n──┼───────────────────┼\n1 │ ANTHONY A   72510 │\n2 │ DANIEL A    95484 │\n3 │ JAMES A    103350 │\n4 │ JEFFERY A  101442 │\n5 │ NANCY A     80016 │\n6 │ ROBERT K   103272 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"This knot contains 6 composite elements labeled employee, each employee having elements labeled name and salary. This element hierarchy can be visualized using show(::DataKnot, as=:flow)","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"    show(as=:flow, @query chicago employee{name, salary})\n    #=>\n    6-element DataKnot:\n      employee:\n        name: \"ANTHONY A\"\n        salary: 72510\n      employee:\n        name: \"DANIEL A\"\n        salary: 95484\n      ⋮\n    =#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The structure of a DataKnot is called its shape. In this case, the shape describes a hierarchy with 2 levels: zero or more elements with label employee, each employee element containing exactly one string element labeled name and exactly one integer element labeled salary.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"show(as=:shape, @query chicago employee{name, salary})\n#=>\n6-element DataKnot:\n  employee  0:N\n  ├╴name    1:1 × String\n  └╴salary  1:1 × Int64\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Not all knots have exactly two levels. Recall the query `count(employee) which produces a single, unlabeled numeric value.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago count(employee)\n#=>\n┼───┼\n│ 6 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The shape of the knot reflects this structure. Here # is used in place of the missing label.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"show(as=:shape, @query chicago count(employee))\n#=>\n1-element DataKnot:\n  #  1:1 × Int64\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Our chicago knot has a hierarchy of three levels: a single unlabeled root element, branch level of employee elements, and a leaf level with name, department, position, and salary.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"show(as=:shape, chicago)\n#=>\n1-element DataKnot:\n  #               1:1\n  └╴employee      0:N\n    ├╴name        String\n    ├╴department  String\n    ├╴position    String\n    └╴salary      Int64\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"This knot could be shown as a hierarchy of elements. Observe that chicago has a single, unlabeled root element.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"    show(as=:flow, chicago)\n    #=>\n    1-element DataKnot:\n      #:\n        employee:\n          name: \"ANTHONY A\"\n          department: \"POLICE\"\n          position: \"POLICE OFFICER\"\n          salary: 72510\n        employee:\n          name: \"DANIEL A\"\n          department: \"FIRE\"\n          position: \"FIRE FIGHTER-EMT\"\n          salary: 95484\n        ⋮\n    =#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"When a knot is displayed, its hierarchy is projected to a tabular form. For chicago, the root element gets its own row with employee elements packed into a single cell: employees are delimited by a semi-colon; and nested attributes are separated by a comma. For packed cells, such as employee, the header shows the subordinate labels within a pair of curly braces.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"chicago\n#=>\n│ employee{name,department,position,salary}                           │\n┼─────────────────────────────────────────────────────────────────────┼\n│ ANTHONY A, POLICE, POLICE OFFICER, 72510; DANIEL A, FIRE, FIRE FIGH…│\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In this section, we have seen how DataKnots sees data as a hierarchical flow of labeled elements. In the next section, we show how hierarchies can be collapsed and created.","category":"page"},{"location":"overview/#Hierarchical-Transformations-1","page":"Overview","title":"Hierarchical Transformations","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"DataKnots' combinators implement hierarchical transformations. Summary combinators, such as count, build queries that collapse a subtree into a single value. For example, we can compute average salary across employees with mean(employee.salary).","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"using Statistics: mean\n\n@query chicago begin\n    mean_salary => mean(employee.salary)\nend\n#=>\n│ mean_salary │\n┼─────────────┼\n│     92679.0 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"The group combinator builds queries that introduce a new level in the hierarchy by constructing grouping records for each unique element produced by its argument. For example, we could group employees by department.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago employee.group(department)\n#=>\n  │ department  employee{name,department,position,salary}             │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ FIRE        DANIEL A, FIRE, FIRE FIGHTER-EMT, 95484; JAMES A, FIR…│\n2 │ POLICE      ANTHONY A, POLICE, POLICE OFFICER, 72510; JEFFERY A, …│\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In this tabular layout, grouping records are represented as table rows, and the corresponding employees are packed into a single cell. To see the knot in an unpacked form, we can display it as an element hierarchy.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"    show(as=:shape, @query chicago employee.group(department))\n    #=>\n    2-element DataKnot:\n      #:\n        department: \"POLICE\"\n        employee:\n          name: \"ANTHONY A\"\n          department: \"POLICE\"\n          position: \"POLICE OFFICER\"\n          salary: 72510\n        employee:\n          name: \"JEFFERY A\"\n          department: \"POLICE\"\n          position: \"SERGEANT\"\n          salary: 201442\n        ⋮\n      #:\n        department: \"FIRE\"\n        employee:\n          name: \"DANIEL A\"\n          department: \"FIRE\"\n          position: \"FIRE FIGHTER-EMT\"\n          salary: 95484\n        employee:\n          name: \"JAMES A\"\n          department: \"FIRE\"\n          position: \"FIRE ENGINEER-EMT\"\n          salary: 103350\n        ⋮\n    =#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Once constructed, grouping records can be used as any other input. In this next query, we show salaries of employees by department. Since each department in our reduced dataset happens to have 3 employees, our output has 3 salary entries.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    group(department)\n    {department, employee.salary}\nend\n#=>\n  │ department  salary                │\n──┼───────────────────────────────────┼\n1 │ FIRE        95484; 103350; 103272 │\n2 │ POLICE      72510; 101442; 80016  │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"We can use summary operations relative to grouping records. In this next example, mean(employee.salary) is computed for each department.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    group(department)\n    {department, mean_salary => mean(employee.salary)}\nend\n#=>\n  │ department  mean_salary │\n──┼─────────────────────────┼\n1 │ FIRE           100702.0 │\n2 │ POLICE          84656.0 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In this section, we have built a query that computes the average employee compensation for each department. Further, we've shown how group is used to transform hierarchies. Finally, we've demonstrated that grouping and summary combinators are independent, yet work fluidly together.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"We're close to answering our original inquiry. We've built a query that filters employees. We've built a query that produces average salary by department. We need only connect these queries.","category":"page"},{"location":"overview/#Query-Context-1","page":"Overview","title":"Query Context","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"DataKnots' queries are interpreted contextually, relative to the input that they receive. We've seen this earlier: depending where it is placed, mean(employee.salary) can produce either the average salary over the entire dataset, or averages within each department.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"For our inquiry, we need to compare each employee's salary with the average salary. However, we cannot evaluate both salary and mean_salary in the same context.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    {name, salary, mean_salary => mean(employee.salary)}\nend\n#-> ERROR: cannot find \"employee\" ⋮","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"To evaluate an expression in one context and then make the value available in subsequent contexts, we could use the keep combinator. The next query computes mean_salary with respect to the entire dataset, and then uses this value in the context of each employee.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    keep(mean_salary => mean(employee.salary))\n    employee\n    {name, salary, mean_salary}\nend\n#=>\n  │ employee                       │\n  │ name       salary  mean_salary │\n──┼────────────────────────────────┼\n1 │ ANTHONY A   72510      92679.0 │\n2 │ DANIEL A    95484      92679.0 │\n3 │ JAMES A    103350      92679.0 │\n4 │ JEFFERY A  101442      92679.0 │\n5 │ NANCY A     80016      92679.0 │\n6 │ ROBERT K   103272      92679.0 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"However, the inquiry asks us to use average salary by department not across all employees. To adapt the previous query, we need to place our keep in the context of employee.group(department).","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    group(department)\n    keep(mean_salary => mean(employee.salary))\n    employee\n    {name, salary, mean_salary}\nend\n#=>\n  │ employee                       │\n  │ name       salary  mean_salary │\n──┼────────────────────────────────┼\n1 │ DANIEL A    95484     100702.0 │\n2 │ JAMES A    103350     100702.0 │\n3 │ ROBERT K   103272     100702.0 │\n4 │ ANTHONY A   72510      84656.0 │\n5 │ JEFFERY A  101442      84656.0 │\n6 │ NANCY A     80016      84656.0 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"We just need to add a filter to answer our initial inquiry: which employees have a salary that is higher than the average for their department?","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"@query chicago begin\n    employee\n    group(department)\n    keep(mean_salary => mean(employee.salary))\n    employee\n    filter(salary > mean_salary)\nend\n#=>\n  │ employee                                         │\n  │ name       department  position           salary │\n──┼──────────────────────────────────────────────────┼\n1 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │\n2 │ ROBERT K   FIRE        FIRE FIGHTER-EMT   103272 │\n3 │ JEFFERY A  POLICE      SERGEANT           101442 │\n=#","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In this section, we've completed our query. Let's talk more about mechanics, how these queries operate.","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"DataKnots is an embedded query language designed so that accidental programmers can more easily analyze complex data. This tutorial shows how typical query operations can be performed upon a simplified in-memory dataset.","category":"page"},{"location":"tutorial/#Getting-Started-1","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Consider a tiny cross-section of public data from Chicago, represented as nested Vector and NamedTuple objects.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"department_data = [\n  (name = \"POLICE\",\n   employee = [\n    (name = \"ANTHONY A\", position = \"POLICE OFFICER\", salary = 72510),\n    (name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442),\n    (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016)]),\n  (name = \"FIRE\",\n   employee = [\n    (name = \"DANIEL A\", position = \"FIREFIGHTER-EMT\", salary = 95484),\n    (name = \"ROBERT K\", position = \"FIREFIGHTER-EMT\", salary = 103272)])]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This hierarchical dataset contains a list of departments, with each department containing associated employees.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To query this dataset, we convert it into a DataKnot, or knot.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using DataKnots\n\nchicago = DataKnot(:department => department_data)","category":"page"},{"location":"tutorial/#Our-First-Query-1","page":"Tutorial","title":"Our First Query","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's say we want to return the list of department names from this dataset. We query the chicago knot using Julia's index notation with It.department.name.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"department_names = chicago[It.department.name]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The output, department_names, is also a DataKnot. The content of this output knot could be accessed via get function.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"get(department_names)\n#-> [\"POLICE\", \"FIRE\"]","category":"page"},{"location":"tutorial/#Navigation-1","page":"Tutorial","title":"Navigation","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In DataKnot queries, It means \"the current input\". The dotted notation lets one navigate a hierarchical dataset. Let's continue our dataset exploration by listing employee names.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.employee.name]\n#=>\n  │ name      │\n──┼───────────┼\n1 │ ANTHONY A │\n2 │ JEFFERY A │\n3 │ NANCY A   │\n4 │ DANIEL A  │\n5 │ ROBERT K  │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Navigation context matters. For example, employee tuples are not directly accessible from the root of the dataset. When a field label, such as employee, can't be found, an appropriate error message is displayed.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.employee]\n#-> ERROR: cannot find \"employee\" ⋮","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Instead, employee tuples can be queried by navigating through department tuples. When tuples are returned, they are displayed as a table.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.employee]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER    72510 │\n2 │ JEFFERY A  SERGEANT         101442 │\n3 │ NANCY A    POLICE OFFICER    80016 │\n4 │ DANIEL A   FIREFIGHTER-EMT   95484 │\n5 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Notice that nested vectors traversed during navigation are flattened into a single output vector.","category":"page"},{"location":"tutorial/#Composition-and-Identity-1","page":"Tutorial","title":"Composition & Identity","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Dotted navigation, such as It.department.name, is a syntax shorthand for the Get() primitive together with query composition (>>).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Get(:department) >> Get(:name)]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The Get() primitive returns values that match a given label. Query composition (>>) chains two queries serially, with the output of the first query as input to the second.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Get(:department) >> Get(:employee)]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER    72510 │\n2 │ JEFFERY A  SERGEANT         101442 │\n3 │ NANCY A    POLICE OFFICER    80016 │\n4 │ DANIEL A   FIREFIGHTER-EMT   95484 │\n5 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The It query simply reproduces its input, which makes it the identity with respect to composition (>>). Hence, It can be woven into any composition without changing the result.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It >> Get(:department) >> Get(:name)]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This motivates our clever use of It as a syntax shorthand.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.name]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In DataKnots, queries are either primitives, such as Get and It, or built from other queries with combinators, such as composition (>>). Let's explore some other combinators.","category":"page"},{"location":"tutorial/#Context-and-Counting-1","page":"Tutorial","title":"Context & Counting","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To count the number of departments in this chicago dataset we write the query Count(It.department). Observe that the argument provided to Count(), It.department, is itself a query.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Count(It.department)]\n#=>\n┼───┼\n│ 2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We could also count the total number of employees across all departments.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Count(It.department.employee)]\n#=>\n┼───┼\n│ 5 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"What if we wanted to count employees by department? Using query composition (>>), we can perform Count in a nested context.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >> Count(It.employee)]\n#=>\n──┼───┼\n1 │ 3 │\n2 │ 2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In this output, we see that one department has 3 employees, while the other has 2.","category":"page"},{"location":"tutorial/#Record-Construction-1","page":"Tutorial","title":"Record Construction","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's improve the previous query by including each department's name alongside employee counts. This can be done by using the Record combinator.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Record(It.name,\n           Count(It.employee))]\n#=>\n  │ department │\n  │ name    #B │\n──┼────────────┼\n1 │ POLICE   3 │\n2 │ FIRE     2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To label a record field we use Julia's Pair syntax, (=>).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Record(It.name,\n           :size => Count(It.employee))]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     3 │\n2 │ FIRE       2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This is syntax shorthand for the Label primitive.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Record(It.name,\n           Count(It.employee) >> Label(:size))]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     3 │\n2 │ FIRE       2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Rather than building a record from scratch, one could add a field to an existing record using Collect.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >>\n        Collect(:size => Count(It.employee))]\n#=>\n  │ department                                                        │\n  │ name    employee{name,position,salary}                       size │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ POLICE  ANTHONY A, POLICE OFFICER, 72510; JEFFERY A, SERGEA…    3 │\n2 │ FIRE    DANIEL A, FIREFIGHTER-EMT, 95484; ROBERT K, FIREFIG…    2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"If a label is set to nothing then that field is excluded. This would let us restructure a record as we see fit.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >>\n        Collect(:size => Count(It.employee),\n                :employee => nothing)]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     3 │\n2 │ FIRE       2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Records can be nested. The following listing includes, for each department, employees' name and salary.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Record(It.name,\n           It.employee >>\n           Record(It.name,\n                  It.salary))]\n#=>\n  │ department                                                  │\n  │ name    employee{name,salary}                               │\n──┼─────────────────────────────────────────────────────────────┼\n1 │ POLICE  ANTHONY A, 72510; JEFFERY A, 101442; NANCY A, 80016 │\n2 │ FIRE    DANIEL A, 95484; ROBERT K, 103272                   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In this output, commas separate tuple fields and semi-colons separate vector elements.","category":"page"},{"location":"tutorial/#Reusable-Queries-1","page":"Tutorial","title":"Reusable Queries","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Queries can be reused. Let's define DeptSize to be a query that computes the number of employees in a department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"DeptSize =\n    :size =>\n        Count(It.employee)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This query can be used in different ways.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Max(It.department >> DeptSize)]\n#=>\n┼───┼\n│ 3 │\n=#\n\nchicago[\n    It.department >>\n    Record(It.name, DeptSize)]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     3 │\n2 │ FIRE       2 │\n=#","category":"page"},{"location":"tutorial/#Filtering-Data-1","page":"Tutorial","title":"Filtering Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's extend the previous query to only show departments with more than one employee. This can be done using the Filter combinator.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Record(It.name, DeptSize) >>\n    Filter(It.size .> 2)]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     3 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To use regular operators in query expressions, we need to use broadcasting notation, such as .> rather than > ; forgetting the period is an easy mistake to make.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Record(It.name, DeptSize) >>\n    Filter(It.size > 2)]\n#=>\nERROR: MethodError: no method matching isless(::Int64, ::DataKnots.Navigation)\n⋮\n=#","category":"page"},{"location":"tutorial/#Incremental-Composition-1","page":"Tutorial","title":"Incremental Composition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Combinators let us construct queries incrementally. Let's explore our Chicago data starting with a list of employees.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q = It.department.employee\n\nchicago[Q]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER    72510 │\n2 │ JEFFERY A  SERGEANT         101442 │\n3 │ NANCY A    POLICE OFFICER    80016 │\n4 │ DANIEL A   FIREFIGHTER-EMT   95484 │\n5 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's extend this query to show if the salary is over 100k.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q >>= Collect(:gt100k => It.salary .> 100000)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The query definition is tracked automatically.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q\n#=>\nIt.department.employee >> Collect(:gt100k => It.salary .> 100000)\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's run Q again.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Q]\n#=>\n  │ employee                                   │\n  │ name       position         salary  gt100k │\n──┼────────────────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER    72510   false │\n2 │ JEFFERY A  SERGEANT         101442    true │\n3 │ NANCY A    POLICE OFFICER    80016   false │\n4 │ DANIEL A   FIREFIGHTER-EMT   95484   false │\n5 │ ROBERT K   FIREFIGHTER-EMT  103272    true │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can now filter the dataset to include only high-paid employees.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q >>= Filter(It.gt100k)\n#=>\nIt.department.employee >>\nCollect(:gt100k => It.salary .> 100000) >>\nFilter(It.gt100k)\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's run Q again.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Q]\n#=>\n  │ employee                                   │\n  │ name       position         salary  gt100k │\n──┼────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT         101442    true │\n2 │ ROBERT K   FIREFIGHTER-EMT  103272    true │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Well-tested queries may benefit from a Tag so that their definitions are suppressed in larger compositions.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"HighlyCompensated = Tag(:HighlyCompensated, Q)\n#-> HighlyCompensated\n\nchicago[HighlyCompensated]\n#=>\n  │ employee                                   │\n  │ name       position         salary  gt100k │\n──┼────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT         101442    true │\n2 │ ROBERT K   FIREFIGHTER-EMT  103272    true │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tagging can make subsequent compositions easier to read.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q = HighlyCompensated >> It.name\n#=>\nHighlyCompensated >> It.name\n=#\n\nchicago[Q]\n#=>\n  │ name      │\n──┼───────────┼\n1 │ JEFFERY A │\n2 │ ROBERT K  │\n=#","category":"page"},{"location":"tutorial/#Aggregate-Queries-1","page":"Tutorial","title":"Aggregate Queries","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We've demonstrated the Count combinator, but Count could also be used as a query. In this next example, Count receives employees as input, and produces their number as output.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.employee >> Count]\n#=>\n┼───┼\n│ 5 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Previously we've only seen elementwise queries, which emit an output for each of its input elements. The Count query is an aggregate, which means it emits an output for its entire input.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We may wish to count employees by department. Contrary to expectation, adding parentheses will not change the output.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >> (It.employee >> Count)]\n#=>\n┼───┼\n│ 5 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To count employees in each department, we use the Each() combinator, which evaluates its argument elementwise.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >> Each(It.employee >> Count)]\n#=>\n──┼───┼\n1 │ 3 │\n2 │ 2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Alternatively, we could use the Count() combinator to get the same result.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >> Count(It.employee)]\n#=>\n──┼───┼\n1 │ 3 │\n2 │ 2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Which form of Count to use depends upon what is notationally convenient. For incremental construction, being able to simply append >> Count is often very helpful.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q = It.department.employee\nchicago[Q >> Count]\n#=>\n┼───┼\n│ 5 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We could then refine the query, and run the exact same command.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Q >>= Filter(It.salary .> 100000)\nchicago[Q >> Count]\n#=>\n┼───┼\n│ 2 │\n=#","category":"page"},{"location":"tutorial/#Summarizing-Data-1","page":"Tutorial","title":"Summarizing Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To summarize data, we could use query combinators such as Min, Max, and Sum. Let's compute some salary statistics.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Salary = It.department.employee.salary\n\nchicago[\n    Record(\n        :count => Count(Salary),\n        :min => Min(Salary),\n        :max => Max(Salary),\n        :sum => Sum(Salary))]\n#=>\n│ count  min    max     sum    │\n┼──────────────────────────────┼\n│     5  72510  103272  452724 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Just as Count has an aggregate query form, so do Min, Max, and Sum. The previous query could be written in aggregate form.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    Record(\n        :count => Salary >> Count,\n        :min => Salary >> Min,\n        :max => Salary >> Max,\n        :sum => Salary >> Sum)]\n#=>\n│ count  min    max     sum    │\n┼──────────────────────────────┼\n│     5  72510  103272  452724 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's calculate salary statistics by department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Salary = It.employee.salary\n\nchicago[\n    It.department >>\n    Record(\n        It.name,\n        :count => Count(Salary),\n        :min => Min(Salary),\n        :max => Max(Salary),\n        :sum => Sum(Salary))]\n#=>\n  │ department                           │\n  │ name    count  min    max     sum    │\n──┼──────────────────────────────────────┼\n1 │ POLICE      3  72510  101442  253968 │\n2 │ FIRE        2  95484  103272  198756 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Summary combinators can be used to define domain specific measures, such as PayGap and AvgPay.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Salary = It.employee.salary\nPayGap = :paygap => Max(Salary) .- Min(Salary)\nAvgPay = :avgpay => Sum(Salary) ./ Count(It.employee)\n\nchicago[\n    It.department >>\n    Record(It.name, PayGap, AvgPay)]\n#=>\n  │ department              │\n  │ name    paygap  avgpay  │\n──┼─────────────────────────┼\n1 │ POLICE   28932  84656.0 │\n2 │ FIRE      7788  99378.0 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Unique is another combinator producing a summary value. Here, we use Unique to return distinct positions by department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department >>\n        Record(It.name,\n               Unique(It.employee.position))]\n#=>\n  │ department                       │\n  │ name    position                 │\n──┼──────────────────────────────────┼\n1 │ POLICE  POLICE OFFICER; SERGEANT │\n2 │ FIRE    FIREFIGHTER-EMT          │\n=#","category":"page"},{"location":"tutorial/#Grouping-Data-1","page":"Tutorial","title":"Grouping Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"So far, we've navigated and summarized data by exploiting its hierarchical organization: the whole dataset to department to employee. But what if we want a query that isn't supported by the existing hierarchy? For example, how could we calculate the number of employees for each position?","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A list of distinct positions could be obtained using Unique.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.employee.position >> Unique]\n#=>\n  │ position        │\n──┼─────────────────┼\n1 │ FIREFIGHTER-EMT │\n2 │ POLICE OFFICER  │\n3 │ SERGEANT        │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"However, Unique is not sufficient because positions are not associated to the respective employees. To associate employee records to their positions, we use Group combinator:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.employee >> Group(It.position)]\n#=>\n  │ position         employee{name,position,salary}                   │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ FIREFIGHTER-EMT  DANIEL A, FIREFIGHTER-EMT, 95484; ROBERT K, FIRE…│\n2 │ POLICE OFFICER   ANTHONY A, POLICE OFFICER, 72510; NANCY A, POLIC…│\n3 │ SERGEANT         JEFFERY A, SERGEANT, 101442                      │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The query Group(It.position) rearranges the dataset into a new hierarchy: position to employee. We can use the new arrangement to show employee names for each unique position.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[It.department.employee >>\n        Group(It.position) >>\n        Record(It.position, It.employee.name)]\n#=>\n  │ position         name               │\n──┼─────────────────────────────────────┼\n1 │ FIREFIGHTER-EMT  DANIEL A; ROBERT K │\n2 │ POLICE OFFICER   ANTHONY A; NANCY A │\n3 │ SERGEANT         JEFFERY A          │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We could further use summary combinators, which lets us answer the original question: What is the number of employees for each position?","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department.employee >>\n    Group(It.position) >>\n    Record(It.position,\n           :count => Count(It.employee))]\n#=>\n  │ position         count │\n──┼────────────────────────┼\n1 │ FIREFIGHTER-EMT      2 │\n2 │ POLICE OFFICER       2 │\n3 │ SERGEANT             1 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Moreover, we could reuse the previously defined employee measures.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Salary = It.employee.salary\nPayGap = :paygap => Max(Salary) .- Min(Salary)\nAvgPay = :avgpay => Sum(Salary) ./ Count(It.employee)\n\nchicago[\n    It.department.employee >>\n    Group(It.position) >>\n    Record(It.position, PayGap, AvgPay)]\n#=>\n  │ position         paygap  avgpay   │\n──┼───────────────────────────────────┼\n1 │ FIREFIGHTER-EMT    7788   99378.0 │\n2 │ POLICE OFFICER     7506   76263.0 │\n3 │ SERGEANT              0  101442.0 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"One could group by any query; here we group employees based upon a salary threshold.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"GT100K = :gt100k => (It.salary .> 100000)\n\nchicago[\n    It.department.employee >>\n    Group(GT100K) >>\n    Record(It.gt100k, It.employee.name)]\n#=>\n  │ gt100k  name                         │\n──┼──────────────────────────────────────┼\n1 │  false  ANTHONY A; NANCY A; DANIEL A │\n2 │   true  JEFFERY A; ROBERT K          │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We could also group by several queries.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department.employee >>\n    Group(It.position, GT100K) >>\n    Record(It.position, It.gt100k, It.employee.name)]\n#=>\n  │ position         gt100k  name               │\n──┼─────────────────────────────────────────────┼\n1 │ FIREFIGHTER-EMT   false  DANIEL A           │\n2 │ FIREFIGHTER-EMT    true  ROBERT K           │\n3 │ POLICE OFFICER    false  ANTHONY A; NANCY A │\n4 │ SERGEANT           true  JEFFERY A          │\n=#","category":"page"},{"location":"tutorial/#Broadcasting-over-Queries-1","page":"Tutorial","title":"Broadcasting over Queries","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Any function could be applied to query arguments using Julia's broadcasting notation.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department.employee >>\n    titlecase.(It.name)]\n#=>\n──┼───────────┼\n1 │ Anthony A │\n2 │ Jeffery A │\n3 │ Nancy A   │\n4 │ Daniel A  │\n5 │ Robert K  │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Broadcasting can also used with operators. For example, let's compute and display a 2% Cost Of Living Adjustment (\"COLA\").","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"COLA = trunc.(Int, It.salary .* 0.02)\n\nchicago[\n    It.department.employee >>\n    Record(It.name,\n           :old_salary => It.salary,\n           :COLA       => \"+\" .* string.(COLA),\n           :new_salary => It.salary .+ COLA)]\n#=>\n  │ employee                                 │\n  │ name       old_salary  COLA   new_salary │\n──┼──────────────────────────────────────────┼\n1 │ ANTHONY A       72510  +1450       73960 │\n2 │ JEFFERY A      101442  +2028      103470 │\n3 │ NANCY A         80016  +1600       81616 │\n4 │ DANIEL A        95484  +1909       97393 │\n5 │ ROBERT K       103272  +2065      105337 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Functions taking a vector argument, such as mean, can also be applied to queries. In this example, mean computes the average employee salary by department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Statistics: mean\n\nchicago[\n    It.department >>\n    Record(\n        It.name,\n        :mean_salary => mean.(It.employee.salary))]\n#=>\n  │ department          │\n  │ name    mean_salary │\n──┼─────────────────────┼\n1 │ POLICE      84656.0 │\n2 │ FIRE        99378.0 │\n=#","category":"page"},{"location":"tutorial/#Keeping-Values-1","page":"Tutorial","title":"Keeping Values","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Suppose we'd like to list employee names together with their department. The naive approach won't work because department is not available in the context of an employee.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    It.employee >>\n    Record(It.name, It.department.name)]\n#-> ERROR: cannot find \"department\" ⋮","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This can be overcome by using Keep to label an expression's result, so that it is available within subsequent computations.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Keep(:dept_name => It.name) >>\n    It.employee >>\n    Record(It.name, It.dept_name)]\n#=>\n  │ employee             │\n  │ name       dept_name │\n──┼──────────────────────┼\n1 │ ANTHONY A  POLICE    │\n2 │ JEFFERY A  POLICE    │\n3 │ NANCY A    POLICE    │\n4 │ DANIEL A   FIRE      │\n5 │ ROBERT K   FIRE      │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This pattern also emerges when a filter condition uses a parameter calculated in a parent context. For example, let's list employees with a higher than average salary for their department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[\n    It.department >>\n    Keep(:mean_salary => mean.(It.employee.salary)) >>\n    It.employee >>\n    Filter(It.salary .> It.mean_salary)]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT         101442 │\n2 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#Query-Parameters-1","page":"Tutorial","title":"Query Parameters","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Parameters let us reuse complex queries without changing their definition. Here we construct a query that depends upon the parameter AMT, which is capitalized by convention.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"PaidOverAmt =\n    It.department >>\n    It.employee >>\n    Filter(It.salary .> It.AMT) >>\n    It.name","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Query parameters are passed as keyword arguments.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[AMT=100000, PaidOverAmt]\n#=>\n  │ name      │\n──┼───────────┼\n1 │ JEFFERY A │\n2 │ ROBERT K  │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"What if we want to return employees who have a greater than average salary? This average could be computed first.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"MeanSalary = mean.(It.department.employee.salary)\n\nmean_salary = chicago[MeanSalary]\n#=>\n┼─────────┼\n│ 90544.8 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Then, this value could be passed as our parameter.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[PaidOverAmt, AMT=mean_salary]\n#=>\n  │ name      │\n──┼───────────┼\n1 │ JEFFERY A │\n2 │ DANIEL A  │\n3 │ ROBERT K  │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This approach performs composition outside of the query language. To evaluate a query and immediately use it as a parameter within the same query expression, we could use the Given combinator.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Given(:AMT => MeanSalary, PaidOverAmt)]\n#=>\n  │ name      │\n──┼───────────┼\n1 │ JEFFERY A │\n2 │ DANIEL A  │\n3 │ ROBERT K  │\n=#","category":"page"},{"location":"tutorial/#Query-Functions-1","page":"Tutorial","title":"Query Functions","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's make a function EmployeesOver that produces employees with a salary greater than the given threshold. The threshold value AMT is evaluated and then made available in the context of each employee with the Given combinator.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EmployeesOver(X) =\n    Given(:AMT => X,\n        It.department >>\n        It.employee >>\n        Filter(It.salary .> It.AMT))\n\nchicago[EmployeesOver(100000)]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT         101442 │\n2 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EmployeesOver can take a query as an argument. For example, let's find employees with higher than average salary.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"MeanSalary = mean.(It.department.employee.salary)\n\nchicago[EmployeesOver(MeanSalary)]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT         101442 │\n2 │ DANIEL A   FIREFIGHTER-EMT   95484 │\n3 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that this combination is yet another query that could be further refined.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[EmployeesOver(MeanSalary) >> It.name]\n#=>\n  │ name      │\n──┼───────────┼\n1 │ JEFFERY A │\n2 │ DANIEL A  │\n3 │ ROBERT K  │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Alternatively, this query function could have been defined using Keep. We use Given because it doesn't leak parameters. Specifically, It.AMT is not available outside EmployeesOver().","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[EmployeesOver(MeanSalary) >> It.AMT]\n#-> ERROR: cannot find \"AMT\" ⋮","category":"page"},{"location":"tutorial/#Paging-Data-1","page":"Tutorial","title":"Paging Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Sometimes query results can be quite large. In this case it's helpful to Take or Drop items from the input. Let's start by listing all 5 employees of our toy database.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Employee = It.department.employee\nchicago[Employee]\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER    72510 │\n2 │ JEFFERY A  SERGEANT         101442 │\n3 │ NANCY A    POLICE OFFICER    80016 │\n4 │ DANIEL A   FIREFIGHTER-EMT   95484 │\n5 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To return only the first 2 records, we use Take.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Employee >> Take(2)]\n#=>\n  │ employee                          │\n  │ name       position        salary │\n──┼───────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER   72510 │\n2 │ JEFFERY A  SERGEANT        101442 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A negative index counts records from the end of the input. So, to return all the records but the last two, we write:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Employee >> Take(-2)]\n#=>\n  │ employee                          │\n  │ name       position        salary │\n──┼───────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER   72510 │\n2 │ JEFFERY A  SERGEANT        101442 │\n3 │ NANCY A    POLICE OFFICER   80016 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To skip the first two records, returning the rest, we use Drop.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Employee >> Drop(2)]\n#=>\n  │ employee                          │\n  │ name      position         salary │\n──┼───────────────────────────────────┼\n1 │ NANCY A   POLICE OFFICER    80016 │\n2 │ DANIEL A  FIREFIGHTER-EMT   95484 │\n3 │ ROBERT K  FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To return the 1st half of the employees in the database, we could use Take with an argument that computes how many to take.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[Employee >> Take(Count(Employee) .÷ 2)]\n#=>\n  │ employee                          │\n  │ name       position        salary │\n──┼───────────────────────────────────┼\n1 │ ANTHONY A  POLICE OFFICER   72510 │\n2 │ JEFFERY A  SERGEANT        101442 │\n=#","category":"page"},{"location":"tutorial/#Extracting-Data-1","page":"Tutorial","title":"Extracting Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Given any DataKnot, its content can be extracted using get. For singular output, get returns a scalar value.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"get(chicago[Count(It.department)])\n#-> 2","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For plural output, get returns a Vector.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"get(chicago[It.department.employee.name])\n#-> [\"ANTHONY A\", \"JEFFERY A\", \"NANCY A\", \"DANIEL A\", \"ROBERT K\"]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For more complex outputs, get may return a @VectorTree, which is an AbstractVector specialized for column-oriented storage.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"query = It.department >>\n        Record(It.name,\n               :size => Count(It.employee))\nvt = get(chicago[query])\ndisplay(vt)\n#=>\n@VectorTree of 2 × (name = (1:1) × String, size = (1:1) × Int64):\n (name = \"POLICE\", size = 3)\n (name = \"FIRE\", size = 2)\n=#","category":"page"},{"location":"tutorial/#The-@query-Notation-1","page":"Tutorial","title":"The @query Notation","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Queries could be written using a convenient path-like notation provided by the @query macro. In this notation:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"bare identifiers are translated to navigation with Get;\nquery combinators, such as Count(X), use lower-case names;\nthe period (.) is used for query composition (>>);\naggregate queries, such as Count, require parentheses;\nrecords can be constructed using curly brackets, {}; and\nfunctions and operators are lifted automatically.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The @query Notation Equivalent Query\ndepartment Get(:department)\ncount(department) Count(Get(:department))\ndepartment.count() Get(:department) >> Count\ndepartment.employee Get(:department) >> Get(:employee)\ndepartment.count(employee) Get(:department) >> Count(Get(:employee))\ndepartment{name} Get(:department) >> Record(Get(:name))","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A @query macro with one argument creates a query object.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@query department.name\n#-> Get(:department) >> Get(:name)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This query object could be used to query a DataKnot as usual.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago[@query department.name]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Alternatively, we can provide the input dataset as an argument to @query.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@query chicago department.name\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Queries could also be composed by placing the query components in a begin/end block.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@query begin\n    department\n    count(employee)\nend\n#-> Get(:department) >> Count(Get(:employee))","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Curly brackets {} are used to construct Record queries.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@query department{name, count(employee)}\n#-> Get(:department) >> Record(Get(:name), Count(Get(:employee)))\n\n@query chicago department{name, count(employee)}\n#=>\n  │ department │\n  │ name    #B │\n──┼────────────┼\n1 │ POLICE   3 │\n2 │ FIRE     2 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Combinators, such as Filter and Keep, are available, using lower-case names. Operators and functions are automatically lifted to queries.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Statistics: mean\n\n@query chicago begin\n           department\n           keep(avg_salary => mean(employee.salary))\n           employee\n           filter(salary > avg_salary)\n           {name, salary}\n       end\n#=>\n  │ employee          │\n  │ name       salary │\n──┼───────────────────┼\n1 │ JEFFERY A  101442 │\n2 │ ROBERT K   103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In @query notation, query aggregates, such as Count and Unique, are lower-case and require parentheses.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@query chicago department.employee.position.unique().count()\n#=>\n┼───┼\n│ 3 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Query parameters are passed as keyword arguments to @query.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@query chicago begin\n    department\n    employee\n    filter(salary>threshold)\nend threshold=90544.8\n#=>\n  │ employee                           │\n  │ name       position         salary │\n──┼────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT         101442 │\n2 │ DANIEL A   FIREFIGHTER-EMT   95484 │\n3 │ ROBERT K   FIREFIGHTER-EMT  103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To embed regular Julia variables and expressions from within a @query, use the interpolation syntax ($).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"threshold = 90544.8\n\n@query chicago begin\n           department.employee\n           filter(salary>$threshold)\n           {name, salary,\n            over => salary - $(trunc(Int, threshold))}\n       end\n#=>\n  │ employee                 │\n  │ name       salary  over  │\n──┼──────────────────────────┼\n1 │ JEFFERY A  101442  10898 │\n2 │ DANIEL A    95484   4940 │\n3 │ ROBERT K   103272  12728 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can use @query to define reusable queries and combinators.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"salary = @query department.employee.salary\n\nstats(x) = @query {min=>min($x),\n                   max=>max($x),\n                   count=>count($x)}\n\n@query chicago stats($salary)\n#=>\n│ min    max     count │\n┼──────────────────────┼\n│ 72510  103272      5 │\n=#","category":"page"},{"location":"tutorial/#Importing-and-Exporting-Data-1","page":"Tutorial","title":"Importing & Exporting Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can import directly from systems that support the Tables.jl interface. Here is a tabular variant of the chicago dataset.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using CSV\n\nemployee_data = \"\"\"\n    name,department,position,salary,rate\n    \"JEFFERY A\",\"POLICE\",\"SERGEANT\",101442,\n    \"NANCY A\",\"POLICE\",\"POLICE OFFICER\",80016,\n    \"ANTHONY A\",\"POLICE\",\"POLICE OFFICER\",72510,\n    \"ALBA M\",\"POLICE\",\"POLICE CADET\",,9.46\n    \"JAMES A\",\"FIRE\",\"FIRE ENGINEER-EMT\",103350,\n    \"DANIEL A\",\"FIRE\",\"FIREFIGHTER-EMT\",95484,\n    \"ROBERT K\",\"FIRE\",\"FIREFIGHTER-EMT\",103272,\n    \"LAKENYA A\",\"OEMC\",\"CROSSING GUARD\",,17.68\n    \"DORIS A\",\"OEMC\",\"CROSSING GUARD\",,19.38\n    \"BRENDA B\",\"OEMC\",\"TRAFFIC CONTROL AIDE\",64392,\n    \"\"\" |> IOBuffer |> CSV.File\n\nchicago′ = DataKnot(:employee => employee_data)\n\nchicago′[It.employee]\n#=>\n   │ employee                                                   │\n   │ name       department  position              salary  rate  │\n───┼────────────────────────────────────────────────────────────┼\n 1 │ JEFFERY A  POLICE      SERGEANT              101442        │\n 2 │ NANCY A    POLICE      POLICE OFFICER         80016        │\n 3 │ ANTHONY A  POLICE      POLICE OFFICER         72510        │\n 4 │ ALBA M     POLICE      POLICE CADET                   9.46 │\n 5 │ JAMES A    FIRE        FIRE ENGINEER-EMT     103350        │\n 6 │ DANIEL A   FIRE        FIREFIGHTER-EMT        95484        │\n 7 │ ROBERT K   FIRE        FIREFIGHTER-EMT       103272        │\n 8 │ LAKENYA A  OEMC        CROSSING GUARD                17.68 │\n 9 │ DORIS A    OEMC        CROSSING GUARD                19.38 │\n10 │ BRENDA B   OEMC        TRAFFIC CONTROL AIDE   64392        │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tabular data could be filtered to show employees that are paid more than average. Let's also prune the rate column.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Statistics: mean\n\nhighly_compensated =\n    chicago′[Keep(:avg_salary => mean.(It.employee.salary)) >>\n             It.employee >>\n             Filter(It.salary .> It.avg_salary) >>\n             Collect(:rate => nothing)]\n#=>\n  │ employee                                         │\n  │ name       department  position           salary │\n──┼──────────────────────────────────────────────────┼\n1 │ JEFFERY A  POLICE      SERGEANT           101442 │\n2 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350 │\n3 │ DANIEL A   FIRE        FIREFIGHTER-EMT     95484 │\n4 │ ROBERT K   FIRE        FIREFIGHTER-EMT    103272 │\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can then export this data.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using DataFrames\n\nhighly_compensated |> DataFrame\n#=>\n4×4 DataFrames.DataFrame\n│ Row │ name      │ department │ position          │ salary │\n│     │ String    │ String     │ String            │ Int64⍰ │\n├─────┼───────────┼────────────┼───────────────────┼────────┤\n│ 1   │ JEFFERY A │ POLICE     │ SERGEANT          │ 101442 │\n│ 2   │ JAMES A   │ FIRE       │ FIRE ENGINEER-EMT │ 103350 │\n│ 3   │ DANIEL A  │ FIRE       │ FIREFIGHTER-EMT   │ 95484  │\n│ 4   │ ROBERT K  │ FIRE       │ FIREFIGHTER-EMT   │ 103272 │\n=#","category":"page"},{"location":"tutorial/#Restructuring-Imported-Data-1","page":"Tutorial","title":"Restructuring Imported Data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After importing tabular data, it is sometimes helpful to restructure hierarchically to make queries more convenient. We've seen earlier how this could be done with Group combinator.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago′[It.employee >> Group(It.department)]\n#=>\n  │ department  employee{name,department,position,salary,rate}        │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ FIRE        JAMES A, FIRE, FIRE ENGINEER-EMT, 103350, missing; DA…│\n2 │ OEMC        LAKENYA A, OEMC, CROSSING GUARD, missing, 17.68; DORI…│\n3 │ POLICE      JEFFERY A, POLICE, SERGEANT, 101442, missing; NANCY A…│\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"With a some labeling, this hierarchy could be transformed so that its structure is compatible with our initial chicago dataset.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Restructure =\n    :department =>\n        It.employee >>\n        Group(It.department) >>\n        Record(\n           :name => It.department,\n           :employee =>\n               It.employee >>\n               Collect(:department => nothing))\n\nchicago′[Restructure]\n#=>\n  │ department                                                        │\n  │ name    employee{name,position,salary,rate}                       │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ FIRE    JAMES A, FIRE ENGINEER-EMT, 103350, missing; DANIEL A, FI…│\n2 │ OEMC    LAKENYA A, CROSSING GUARD, missing, 17.68; DORIS A, CROSS…│\n3 │ POLICE  JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLICE OFF…│\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using Collect we could save this restructured dataset as a top-level field, department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chicago″ = chicago′[Restructure >> Collect]\n#=>\n│ employee{name,department,positio… department{name,employee{name,pos…│\n┼─────────────────────────────────────────────────────────────────────┼\n│ JEFFERY A, POLICE, SERGEANT, 101… FIRE, [JAMES A, FIRE ENGINEER-EMT…│\n=#","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Then, queries that originally worked with our hierarchical chicago dataset would now work with this imported and then restructured chicago″ data. For example, we could once again compute the average employee salary by department.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Statistics: mean\n\nchicago″[\n    It.department >>\n    Record(\n        It.name,\n        :mean_salary => mean.(It.employee.salary))]\n#=>\n  │ department          │\n  │ name    mean_salary │\n──┼─────────────────────┼\n1 │ FIRE       100702.0 │\n2 │ OEMC        64392.0 │\n3 │ POLICE      84656.0 │\n=#","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"DocTestSetup = quote\n    using DataKnots\nend","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [DataKnots]\nPrivate = false","category":"page"},{"location":"reference/#DataKnots.It","page":"Reference","title":"DataKnots.It","text":"It :: AbstractQuery\n\nIn a query expression, use It to refer to the query's input.\n\njulia> unitknot[Lift(3) >> (It .+ 1)]\n┼───┼\n│ 4 │\n\nIt is the identity with respect to query composition.\n\njulia> unitknot[Lift('a':'c') >> It]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\nIt provides a shorthand notation for data navigation using Get, so that It.a.x is equivalent to Get(:a) >> Get(:x).\n\njulia> unitknot[Lift((a=(x=1,y=2),)) >> It.a]\n│ a    │\n│ x  y │\n┼──────┼\n│ 1  2 │\n\njulia> unitknot[Lift((a=(x=1,y=2),)) >> It.a.x]\n│ x │\n┼───┼\n│ 1 │\n\n\n\n\n\n","category":"constant"},{"location":"reference/#DataKnots.unitknot","page":"Reference","title":"DataKnots.unitknot","text":"unitknot\n\nThe unit knot holds an empty tuple.\n\njulia> unitknot\n┼──┼\n│  │\n\nThe unitknot is useful for constructing queries that do not originate from another datasource.\n\njulia> unitknot[\"Hello\"]\n┼───────┼\n│ Hello │\n\n\n\n\n\n","category":"constant"},{"location":"reference/#DataKnots.DataKnot","page":"Reference","title":"DataKnots.DataKnot","text":"DataKnot(Pair{Symbol}...)\n\nThis constructor binds names to datasets, so that they could be used to start a query. The knot created has a single top-level record, each with its own value.\n\njulia> test_knot = DataKnot(:dataset=>'a':'c')\n│ dataset │\n┼─────────┼\n│ a; b; c │\n\njulia> test_knot[It.dataset]\n  │ dataset │\n──┼─────────┼\n1 │ a       │\n2 │ b       │\n3 │ c       │\n\nArguments to this constructor are run though convert.\n\n\n\nconvert(DataKnot, val)\n\nThis converter wraps a given value so that it could be used to start a query.\n\nAn empty knot can be constructed with missing.\n\njulia> convert(DataKnot, missing)\n(empty)\n\nA plural knot is constructed from a vector.\n\njulia> convert(DataKnot, 'a':'c')\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\nAn object that complies with the Table interface, such as a CSV file, can be converted to a DataKnot.\n\njulia> using CSV;\n\njulia> csv_file = \"k,v\\na,1\\nb\" |> IOBuffer |> CSV.File;\n\njulia> convert(DataKnot, csv_file)\n  │ k  v │\n──┼──────┼\n1 │ a  1 │\n2 │ b    │\n\n\n\nget(::DataKnot)\n\nUse get to extract the underlying value held by a knot.\n\njulia> get(convert(DataKnot, \"Hello World\"))\n\"Hello World\"\n\n\n\ngetindex(::DataKnot, X; kwargs...)\n\nWe can query a knot using array indexing notation.\n\njulia> convert(DataKnot, (dataset='a':'c',))[Count(It.dataset)]\n┼───┼\n│ 3 │\n\nQuery parameters are provided as keyword arguments.\n\njulia> convert(DataKnot, 1:3)[PWR=2, It .^ It.PWR]\n──┼───┼\n1 │ 1 │\n2 │ 4 │\n3 │ 9 │\n\n\n\n\n\n","category":"type"},{"location":"reference/#DataKnots.Collect-Tuple{Any,Vararg{Any,N} where N}","page":"Reference","title":"DataKnots.Collect","text":"Collect(X₁, X₂ … Xₙ) :: Query\n\nIn the combinator form, Collect(X₁, X₂ … Xₙ) adds fields X₁, X₂ … Xₙ to the input record.\n\njulia> unitknot[Record(:x => 1) >> Collect(:y => 2 .* It.x)]\n│ x  y │\n┼──────┼\n│ 1  2 │\n\nIf a field already exists, it is replaced.\n\njulia> unitknot[Record(:x => 1) >> Collect(:x => 2 .* It.x)]\n│ x │\n┼───┼\n│ 2 │\n\nTo remove a field, assign it the value nothing.\n\njulia> unitknot[Record(:x => 1) >> Collect(:y => 2 .* It.x, :x => nothing)]\n│ y │\n┼───┼\n│ 2 │\n\n\n\nEach(X >> Record) :: Query\n\nIn the query form, Collect appends a field to the source record.\n\njulia> unitknot[Lift(1) >> Label(:x) >> Collect]\n│ x │\n┼───┼\n│ 1 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Count-Tuple{Any}","page":"Reference","title":"DataKnots.Count","text":"Count(X) :: Query\n\nIn the combinator form, Count(X) emits the number of elements produced by X.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[Count(X)]\n┼───┼\n│ 3 │\n\n\n\nEach(X >> Count) :: Query\n\nIn the query form, Count emits the number of elements in its input.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[X >> Count]\n┼───┼\n│ 3 │\n\nTo limit the scope of aggregation, use Each.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[Lift(1:3) >> Each(X >> Count)]\n──┼───┼\n1 │ 3 │\n2 │ 3 │\n3 │ 3 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Drop-Tuple{Any}","page":"Reference","title":"DataKnots.Drop","text":"Drop(N) :: Query\n\nThis query drops the first N elements of its input, preserving the rest.\n\njulia> unitknot[Lift('a':'c') >> Drop(2)]\n──┼───┼\n1 │ c │\n\nDrop(-N) takes the last N elements.\n\njulia> unitknot[Lift('a':'c') >> Drop(-2)]\n──┼───┼\n1 │ b │\n2 │ c │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Each-Tuple{Any}","page":"Reference","title":"DataKnots.Each","text":"Each(X) :: Query\n\nThis evaluates X elementwise.\n\njulia> X = Lift('a':'c') >> Count;\n\njulia> unitknot[Lift(1:3) >> Each(X)]\n──┼───┼\n1 │ 3 │\n2 │ 3 │\n3 │ 3 │\n\nCompare this with the query without Each.\n\njulia> X = Lift('a':'c') >> Count;\n\njulia> unitknot[Lift(1:3) >> X]\n┼───┼\n│ 9 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Exists-Tuple{Any}","page":"Reference","title":"DataKnots.Exists","text":"Exists(X) :: Query\n\nIn the combinator form, Exists(X) emits a boolean testing if X produces any elements.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[Exists(X)]\n┼──────┼\n│ true │\n\nWhen the query argument X is empty, Exists(X) produces false.\n\njulia> X = Lift([]);\n\njulia> unitknot[Exists(X)]\n┼───────┼\n│ false │\n\n\n\nEach(X >> Exists) :: Query\n\nIn the query form, Exists emits a boolean testing if its input has any elements.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[X >> Exists]\n┼──────┼\n│ true │\n\nWhen the query input is empty, Exists produces false.\n\njulia> X = Lift([]);\n\njulia> unitknot[X >> Exists]\n┼───────┼\n│ false │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Filter-Tuple{Any}","page":"Reference","title":"DataKnots.Filter","text":"Filter(X) :: Query\n\nThis query emits the elements from its input that satisfy a given condition.\n\njulia> unitknot[Lift(1:5) >> Filter(isodd.(It))]\n──┼───┼\n1 │ 1 │\n2 │ 3 │\n3 │ 5 │\n\nWhen the predicate query produces an empty output, the condition is presumed to have failed.\n\njulia> unitknot[Lift('a':'c') >> Filter(missing)]\n(empty)\n\nWhen the predicate produces plural output, the condition succeeds if at least one output value is true.\n\njulia> unitknot[Lift('a':'c') >> Filter([true,false])]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.First-Tuple{Any}","page":"Reference","title":"DataKnots.First","text":"First(X) :: Query\n\nIn the combinator form, First(X) emits the first element produced by its argument X.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[First(X)]\n┼───┼\n│ a │\n\n\n\nEach(X >> First) :: Query\n\nIn the query form, First emits the first element of its input.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[X >> First]\n┼───┼\n│ a │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Get-Tuple{Any}","page":"Reference","title":"DataKnots.Get","text":"Get(lbl::Symbol) :: Query\n\nThis query extracts a field value by its label.\n\njulia> unitknot[Lift((x=1, y=2)) >> Get(:x)]\n│ x │\n┼───┼\n│ 1 │\n\nThis has a shorthand form using It.\n\njulia> unitknot[Lift((x=1, y=2)) >> It.x]\n│ x │\n┼───┼\n│ 1 │\n\nWith unlabeled fields, ordinal labels (A, B, ...) can be used.\n\njulia> unitknot[Lift((1,2)) >> It.B]\n┼───┼\n│ 2 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Given-Tuple{Any,Vararg{Any,N} where N}","page":"Reference","title":"DataKnots.Given","text":"Given(X₁, X₂ … Xₙ, Q) :: Query\n\nThis evaluates Q in a context augmented with named parameters added by a set of queries.\n\njulia> unitknot[Given(:x => 2, It.x .+ 1)]\n┼───┼\n│ 3 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Group-Tuple","page":"Reference","title":"DataKnots.Group","text":"Group(X₁, X₂ … Xₙ) :: Query\n\nThis query groups the input data by the keys X₁, X₂ … Xₙ.\n\njulia> unitknot[Lift(1:5) >> Group(isodd.(It))]\n  │ #A     #B      │\n──┼────────────────┼\n1 │ false  2; 4    │\n2 │  true  1; 3; 5 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Is0to1-Tuple{Any}","page":"Reference","title":"DataKnots.Is0to1","text":"Is0to1(X) :: Query\n\nThis query asserts that X emits 0 or 1 element.\n\n\n\nEach(X >> Is0to1) :: Query\n\nIn this form, Is0to1 asserts that its input contains 0 or 1 element.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Is0toN-Tuple{Any}","page":"Reference","title":"DataKnots.Is0toN","text":"Is0toN(X) :: Query\n\nThis query asserts that X may emit any number of elements.\n\n\n\nEach(X >> Is0toN) :: Query\n\nIn this form, Is0toN asserts that its input contains any number of elements.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Is1to1-Tuple{Any}","page":"Reference","title":"DataKnots.Is1to1","text":"Is1to1(X) :: Query\n\nThis query asserts that X emits 1 element.\n\n\n\nEach(X >> Is1to1) :: Query\n\nIn this form, Is1to1 asserts that its input contains 1 element.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Is1toN-Tuple{Any}","page":"Reference","title":"DataKnots.Is1toN","text":"Is1toN(X) :: Query\n\nThis query asserts that X emits 1 or more elements.\n\n\n\nEach(X >> Is1toN) :: Query\n\nIn this form, Is1toN asserts that its input contains 1 or more elements.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Join-Tuple{Any}","page":"Reference","title":"DataKnots.Join","text":"Join(X) :: Query\n\nJoin(X) evaluates X in the source context and adds it as a field to the input record.\n\njulia> unitknot[Record(:x => 1) >> Each(Record(:y => 2 .* It.x) >> Join(It.x))]\n│ y  x │\n┼──────┼\n│ 2  1 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Keep-Tuple{Any,Vararg{Any,N} where N}","page":"Reference","title":"DataKnots.Keep","text":"Keep(X₁, X₂ … Xₙ) :: Query\n\nKeep evaluates named queries, making their results available for subsequent computation.\n\njulia> unitknot[Keep(:x => 2) >> It.x]\n│ x │\n┼───┼\n│ 2 │\n\nKeep does not otherwise change its input.\n\njulia> unitknot[Lift(1) >> Keep(:x => 2) >> (It .+ It.x)]\n┼───┼\n│ 3 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Label-Tuple{Symbol}","page":"Reference","title":"DataKnots.Label","text":"Label(lbl::Symbol) :: Query\n\nThis assigns a label to the output.\n\njulia> unitknot[Lift(\"Hello World\") >> Label(:greeting)]\n│ greeting    │\n┼─────────────┼\n│ Hello World │\n\nA label could also be assigned using the => operator.\n\njulia> unitknot[:greeting => Lift(\"Hello World\")]\n│ greeting    │\n┼─────────────┼\n│ Hello World │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Last-Tuple{Any}","page":"Reference","title":"DataKnots.Last","text":"Last(X) :: Query\n\nIn the combinator form, Last(X) emits the last element produced by its argument X.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[Last(X)]\n┼───┼\n│ c │\n\n\n\nEach(X >> Last) :: Query\n\nIn the query form, Last emits the last element of its input.\n\njulia> X = Lift('a':'c');\n\njulia> unitknot[X >> Last]\n┼───┼\n│ c │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Lift-Tuple{Any,Tuple}","page":"Reference","title":"DataKnots.Lift","text":"Lift(f, (X₁, X₂ … Xₙ)) :: Query\n\nLift lets you use a function as a query combinator.\n\njulia> unitknot[Lift((x=1, y=2)) >> Lift(+, (It.x, It.y))]\n┼───┼\n│ 3 │\n\nLift is implicitly used when a function is broadcast over queries.\n\njulia> unitknot[Lift((x=1, y=2)) >> (It.x .+ It.y)]\n┼───┼\n│ 3 │\n\nFunctions accepting a AbstractVector can be used with plural queries.\n\njulia> unitknot[sum.(Lift(1:3))]\n┼───┼\n│ 6 │\n\nFunctions returning AbstractVector become plural queries.\n\njulia> unitknot[Lift((x='a', y='c')) >> Lift(:, (It.x, It.y))]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Lift-Tuple{Any}","page":"Reference","title":"DataKnots.Lift","text":"Lift(val) :: Query\n\nThis converts any value to a constant query.\n\njulia> unitknot[Lift(\"Hello\")]\n┼───────┼\n│ Hello │\n\nAbstractVector objects become plural queries.\n\njulia> unitknot[Lift('a':'c')]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\nTo specify the vector cardinality, add :x0to1, :x0toN, :x1to1, or :x1toN.\n\njulia> unitknot[Lift('a':'c', :x1toN)]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\nThe missing value makes an query with no output.\n\njulia> unitknot[Lift(missing)]\n(empty)\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Max-Tuple{Any}","page":"Reference","title":"DataKnots.Max","text":" Max(X) :: Query\n\nIn the combinator form, Max(X) finds the maximum among the elements produced by X.\n\njulia> X = Lift(1:3);\n\njulia> unitknot[Max(X)]\n┼───┼\n│ 3 │\n\nThe Max of an empty input is empty.\n\njulia> unitknot[Max(Int[])]\n(empty)\n\n\n\nEach(X >> Max) :: Query\n\nIn the query form, Max finds the maximum of its input elements.\n\njulia> X = Lift(1:3);\n\njulia> unitknot[X >> Max]\n┼───┼\n│ 3 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Min-Tuple{Any}","page":"Reference","title":"DataKnots.Min","text":" Min(X) :: Query\n\nIn the combinator form, Min(X) finds the minimum among the elements produced by X.\n\njulia> X = Lift(1:3);\n\njulia> unitknot[Min(X)]\n┼───┼\n│ 1 │\n\nThe Min of an empty input is empty.\n\njulia> unitknot[Min(Int[])]\n(empty)\n\n\n\nEach(X >> Min) :: Query\n\nIn the query form, Min finds the minimum of its input elements.\n\njulia> X = Lift(1:3);\n\njulia> unitknot[X >> Min]\n┼───┼\n│ 1 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Mix-Tuple","page":"Reference","title":"DataKnots.Mix","text":"Mix(X₁, X₂ … Xₙ) :: Query\n\nThis query emits records containing every combination of elements generated by X₁, X₂ … Xₙ.\n\njulia> unitknot[Mix(Lift(1:2), Lift('a':'c'))]\n  │ #A  #B │\n──┼────────┼\n1 │  1  a  │\n2 │  1  b  │\n3 │  1  c  │\n4 │  2  a  │\n5 │  2  b  │\n6 │  2  c  │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Nth-Tuple{Any,Any}","page":"Reference","title":"DataKnots.Nth","text":"Nth(X, N) :: Query\n\nIn the combinator form, Nth(X, N) emits the Nth element produced by its argument X.\n\njulia> X = Lift('a':'d');\n\njulia> N = Count(X) .÷ 2;\n\njulia> unitknot[Nth(X, N)]\n┼───┼\n│ b │\n\n\n\nEach(X >> Nth(N)) :: Query\n\nIn the query form, Nth(N) emits the Nth element produced by its input.\n\njulia> X = Lift('a':'d');\n\njulia> N = Count(X) .÷ 2;\n\njulia> unitknot[X >> Nth(N)]\n┼───┼\n│ b │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Record-Tuple","page":"Reference","title":"DataKnots.Record","text":"Record(X₁, X₂ … Xₙ) :: Query\n\nThis query emits a record with fields generated by X₁, X₂ … Xₙ.\n\njulia> unitknot[Lift(1:3) >> Record(It, It .* It)]\n  │ #A  #B │\n──┼────────┼\n1 │  1   1 │\n2 │  2   4 │\n3 │  3   9 │\n\nField labels are inherited from queries.\n\njulia> unitknot[Lift(1:3) >> Record(:x => It,\n                                    :x² => It .* It)]\n  │ x  x² │\n──┼───────┼\n1 │ 1   1 │\n2 │ 2   4 │\n3 │ 3   9 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Sum-Tuple{Any}","page":"Reference","title":"DataKnots.Sum","text":"Sum(X) :: Query\n\nIn the combinator form, Sum(X) emits the sum of elements produced by X.\n\njulia> X = Lift(1:3);\n\njulia> unitknot[Sum(X)]\n┼───┼\n│ 6 │\n\nThe Sum of an empty input is 0.\n\njulia> unitknot[Sum(Int[])]\n┼───┼\n│ 0 │\n\n\n\nEach(X >> Sum) :: Query\n\nIn the query form, Sum emits the sum of input elements.\n\njulia> X = Lift(1:3);\n\njulia> unitknot[X >> Sum]\n┼───┼\n│ 6 │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Tag-Tuple{Symbol,Any}","page":"Reference","title":"DataKnots.Tag","text":"Tag(name::Symbol, F) :: Query\n\nThis provides a substitute name for a query.\n\njulia> IncIt = It .+ 1\nIt .+ 1\n\njulia> IncIt = Tag(:IncIt, It .+ 1)\nIncIt\n\n\n\nTag(name::Symbol, (X₁, X₂ … Xₙ), F) :: Query\n\nThis provides a substitute name for a query combinator.\n\njulia> Inc(X) = Lift(+, (X, 1));\n\njulia> Inc(It)\nLift(+, (It, 1))\n\njulia> Inc(X) = Tag(:Inc, (X,), Lift(+, (X, 1)));\n\njulia> Inc(It)\nInc(It)\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Take-Tuple{Any}","page":"Reference","title":"DataKnots.Take","text":"Take(N) :: Query\n\nThis query preserves the first N elements of its input, dropping the rest.\n\njulia> unitknot[Lift('a':'c') >> Take(2)]\n──┼───┼\n1 │ a │\n2 │ b │\n\nTake(-N) drops the last N elements.\n\njulia> unitknot[Lift('a':'c') >> Take(-2)]\n──┼───┼\n1 │ a │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.Unique-Tuple{Any}","page":"Reference","title":"DataKnots.Unique","text":"Unique(X) :: Query\n\nThis query produces all distinct elements emitted by X.\n\njulia> unitknot[Unique(['a','b','b','c','c','c'])]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\n\n\nEach(X >> Unique) :: Query\n\nIn the query form, Unique produces all distinct elements of its input.\n\njulia> unitknot[Lift(['a','b','b','c','c','c']) >> Unique]\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n\n\n\n\n\n","category":"method"},{"location":"reference/#DataKnots.@query-Tuple{Any,Vararg{Any,N} where N}","page":"Reference","title":"DataKnots.@query","text":" @query dataset expr param=...\n\nApplies the query to a dataset with a given set of parameters.\n\njulia> @query unitknot 2x+1 x=1\n┼───┼\n│ 3 │\n\n\n\n\n\n","category":"macro"},{"location":"reference/#DataKnots.@query-Tuple{Any}","page":"Reference","title":"DataKnots.@query","text":" @query expr\n\nCreates a query object from a specialized path-like notation:\n\nbare identifiers are translated to navigation with Get;\nquery combinators, such as Count(X), use lower-case names;\nthe period (.) is used for query composition (>>);\naggregate queries, such as Count, require parentheses;\nrecords can be constructed using curly brackets, {}; and\nfunctions and operators are lifted automatically.\n\njulia> @query 2x+1\nLift(+, (Lift(*, (Lift(2), Get(:x))), Lift(1)))\n\n\n\n\n\n","category":"macro"},{"location":"primer/#Thinking-in-Queries-1","page":"Thinking in Queries","title":"Thinking in Queries","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots is a Julia library for building database queries. This conceptual guide provides a deeper look at DataKnots beyond what is available in the tutorial. We'll start with a quick overview of the query algebra, then we'll move on to the structure of knots, then pipelines, and finally back to query combinators.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"There are four layers in the DataKnots package. At the lowest level are DataKnot objects, which are the input and output of a Query. At the highest level are combinators, such as Count, which are used to build queries from other queries. The Pipeline layer is an implementation detail, pipelines can be seen as a detailed query plan describing just how data should be processed. This layer helpful for explaining the semantics of queries and is helpful for those building custom queries and combinators.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Layer Function\nCombinator builds a Query from other queries\nQuery assembles Pipeline extensions\nPipeline transforms one DataKnot to another\nDataKnot provides block-oriented storage model","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To start working with DataKnots, we import the package:","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"using DataKnots","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This statement imports common query constructors such as Lift, and combinators, such as Count. Further, it imports the constructor for DataKnot objects. That said, pipeline functions, such as DataKnots.assemble are not imported, but they would only be used by those curious about the workings of queries.","category":"page"},{"location":"primer/#Query-Algebra-1","page":"Thinking in Queries","title":"Query Algebra","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"In DataKnots, queries are assembled algebraically: they either come from a set of atomic primitives or are built from other queries using combinators.","category":"page"},{"location":"primer/#The-Unit-Knot-1","page":"Thinking in Queries","title":"The Unit Knot","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A DataKnot, or just knot, is a container for structured, vectorized data. The unitknot is a trivial knot used as the starting point for constructing other knots.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot\n#=>\n┼──┼\n│  │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The unit knot has a single value, an empty tuple. You could get the value of any knot using Julia's get function.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"get(unitknot)\n#-> ()","category":"page"},{"location":"primer/#Constant-Queries-1","page":"Thinking in Queries","title":"Constant Queries","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Any Julia value could be converted to a query using the Lift constructor. Queries constructed this way are constant: for each input element they receive, they output the given value. Consider the query Hello, lifted from the string value \"Hello World\".","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Hello = Lift(\"Hello World\")","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To query unitknot with Hello, we use indexing notation unitknot[Hello]. In this case, Hello receives () from unitknot and produces the value, \"Hello World\".","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Hello]\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A Tuple lifted to a constant query is displayed as a table.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift((name=\"DataKnots\", version=\"0.1\"))]\n#=>\n│ name       version │\n┼────────────────────┼\n│ DataKnots  0.1     │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A missing value lifted to a constant query produces no output.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(missing)]\n#=>\n(empty)\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A Vector lifted to a constant query will produce plural output.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift('a':'c')]\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We call queries constructed this way primitives, as they do not rely upon any other query. There are also combinators, which build new queries from existing ones.","category":"page"},{"location":"primer/#Composition-and-Identity-1","page":"Thinking in Queries","title":"Composition & Identity","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Two queries can be connected sequentially using the composition combinator (>>). Consider the composition Lift(1:3) >> Hello. Since Hello produces a value for each input element, preceding it with Lift(1:3) generates three copies of \"Hello World\".","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Hello]\n#=>\n──┼─────────────┼\n1 │ Hello World │\n2 │ Hello World │\n3 │ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"If we compose two plural queries, Lift(1:2) and Lift('a':'c'), the output will contain the elements of 'a':'c' repeated twice.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:2) >> Lift('a':'c')]\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n4 │ a │\n5 │ b │\n6 │ c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The identity with respect to query composition is called It. This primitive can be composed with any query without changing the query's output.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Hello >> It]\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The identity primitive, It, can be used to construct queries which rely upon the output from previous processing.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Increment = It .+ 1\nunitknot[Lift(1:3) >> Increment]\n#=>\n──┼───┼\n1 │ 2 │\n2 │ 3 │\n3 │ 4 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"In DataKnots, queries are built algebraically, starting with query primitives, such as constants (Lift) or the identity (It), and then arranged with with combinators, such as composition (>>). This lets us define sophisticated query components and remix them in creative ways.","category":"page"},{"location":"primer/#The-Shape-of-Data-1","page":"Thinking in Queries","title":"The Shape of Data","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To discuss the structure and function of queries, we must first describe the shape of DataKnot objects. Shapes are used to track value types, cardinality constraints, field labels, and other properties.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To obtain the shape of a knot, use the shape function.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(unitknot)\n#-> BlockOf(TupleOf(), x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Here we discover that the shape of the unitknot is a singular block of empty tuples.","category":"page"},{"location":"primer/#Blocks-1","page":"Thinking in Queries","title":"Blocks","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A block is a collection of elements of a particular type, with the number of its elements satisfying a certain cardinality constraint. Query results are always packaged as a block.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Consider the knot produced by the query Lift('a':'c').","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"abc = unitknot[Lift('a':'c')]\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The knot abc contains several character elements wrapped in a single block.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(abc)\n#-> BlockOf(Char)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Now consider the output of a singular query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"hello = unitknot[Lift(\"Hello World\")]\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This knot contains a single string wrapped in a block. Since this block contains exactly one element, its cardinality is :x1to1.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(hello)\n#-> BlockOf(String, x1to1)","category":"page"},{"location":"primer/#Cardinality-1","page":"Thinking in Queries","title":"Cardinality","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Cardinality restricts the possible number of elements per block: singular means there is at most one value in each block; mandatory means there must be at least one value in each block.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Cardinality Mandatory Singular Description\n:x0to1 no yes optional, singular value\n:x0toN no no optional, plural values\n:x1to1 yes yes exactly one value\n:x1toN yes no at least one plural value","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"When an AbstractVector is converted to queries via Lift, the default cardinality is :x0toN. Values of Missing type are treated as :x0to1. Otherwise, the cardinality is :x1to1.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"For more detail on how Lift constructs queries, see the section entitled cardinality of lift.","category":"page"},{"location":"primer/#Values-1","page":"Thinking in Queries","title":"Values","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"So that we could declare the use of native Julia values as block elements, we wrap their type in a value shape. In particular, BlockOf(String) abbreviates BlockOf(ValueOf(String)).","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.BlockOf(DataKnots.ValueOf(String))\n#-> BlockOf(String)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"When a Julia value is lifted to queries, the outer Vector is used to represent block elements. Its element type is then wrapped with ValueOf to become the block's shape. Hence, a block of Vector could be constructed:","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"numbers = unitknot[Lift([[1,2],[3]])]\n#=>\n──┼──────┼\n1 │ 1; 2 │\n2 │ 3    │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The shape of numbers this is a block of ValueOf(Vector).","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(numbers)\n#-> BlockOf(Array{Int64,1})","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Once could also construct this shape directly.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.BlockOf(DataKnots.ValueOf(Vector{Int64}))\n#-> BlockOf(Array{Int64,1})","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Some queries may produce empty output, that is, a single block that happens to not have any values in it.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"empty = unitknot[Lift(missing)]\n#=>\n(empty)\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The shape of this empty knot indicates its block could have at most one value (:x0to1). Further, missing is treated as the lack of value. Hence, rather than a ValueOf(Missing) shape, it has the bottom shape, NoShape().","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(empty)\n#-> BlockOf(NoShape(), x0to1)","category":"page"},{"location":"primer/#Labels-1","page":"Thinking in Queries","title":"Labels","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Shape is also used to track query labels. A label can be given to a query using the Label primitive.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"labeled = unitknot[Lift(\"Hello World\") >> Label(:message)]\n#=>\n│ message     │\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"When the Label primitive is composed with a query, it doesn't change how data is processed, but instead modifies output shape.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(labeled)\n#-> BlockOf(String, x1to1) |> IsLabeled(:message)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We use the Pair constructor as a convenient syntax for the assignment of labels.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[:message => \"Hello World\"]\n#=>\n│ message     │\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The label shape is used when displaying titles. It also is used by the Record combinator when constructing tuples.","category":"page"},{"location":"primer/#Tuples-1","page":"Thinking in Queries","title":"Tuples","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Besides blocks that structure data sequentially, data could also be organized in parallel as a named tuple.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"message = unitknot[Record(:message=>\"Hello World\")]\n#=>\n│ message     │\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The Record combinator converts query labels, such as message, into field names. In a tuple constructed by Record, field values are always wrapped in a block. Hence, the shape of this query is a block of tuples, with elements being a block of strings.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(message)\n#-> BlockOf(TupleOf(:message => BlockOf(String, x1to1)), x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The only structural difference between this query and a table is the cardinality of the outer block.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"table = unitknot[Lift(1:3) >> Record(:n => It, :n² => It .* It)]\n#=>\n  │ n  n² │\n──┼───────┼\n1 │ 1   1 │\n2 │ 2   4 │\n3 │ 3   9 │\n=#\n\nDataKnots.shape(table)\n#=>\nBlockOf(TupleOf(:n => BlockOf(Int64, x1to1),\n                :n² => BlockOf(Int64, x1to1)))\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The combination of blocks, values, labels, and tuples permit structured hierararchies to be represented as a DataKnot.","category":"page"},{"location":"primer/#Pipeline-Processing-1","page":"Thinking in Queries","title":"Pipeline Processing","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"So far we've discussed knots, queries and combinators. What we've not discussed are pipelines, which transform one knot to another. Normally one doesn't interact with pipelines unless you are building novel query combinators.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To start, how does unitknot[Lift(\"Hello\")] function?","category":"page"},{"location":"primer/#Assembling-Pipelines-1","page":"Thinking in Queries","title":"Assembling Pipelines","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Before we can assemble a pipeline, we first need the shape of the input source. Since we're going to be running our query against the unitknot, let's obtain its shape.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitshape = DataKnots.shape(unitknot)\n#-> BlockOf(TupleOf(), x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We could then assemble the pipeline for Lift(\"Hello\").","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"hello_pipe = DataKnots.assemble(unitshape, Lift(\"Hello\"))\n#-> with_elements(filler(\"Hello\"))","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This pipeline has two phases: it loops though each element of the input block (with_elements); then, for each of those elements, it produces the string value \"Hello\" (filler).","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Once assembled, we could run the pipeline against the unitknot.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"hello_pipe(unitknot)\n#=>\n┼───────┼\n│ Hello │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Observe that pipeline assembly doesn't depend upon the exact input data, but it does depends upon shape of the input source.","category":"page"},{"location":"primer/#Pipeline-Signature-1","page":"Thinking in Queries","title":"Pipeline Signature","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A pipeline is a function that maps data blocks from an input source to blocks in its output target. We could inquire about the pipeline's input and output shapes.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.source(hello_pipe)\n#-> BlockOf(TupleOf(), x1to1)\n\nDataKnots.target(hello_pipe)\n#-> BlockOf(String, x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"One needs both the source and the target shapes to define the signature of the pipeline function.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.signature(hello_pipe)\n#-> Signature(BlockOf(TupleOf(), x1to1), BlockOf(String, x1to1))","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Here we see that hello_pipe expects its input source to provide an empty tuple, and that it'll produce a string.","category":"page"},{"location":"primer/#Trivial-Pipelines-1","page":"Thinking in Queries","title":"Trivial Pipelines","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Internally, any DataKnot can be converted into a Pipeline capable of reproducing itself.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitpipe = DataKnots.trivial_pipe(unitknot)\n#-> pass()","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The signature of a trivial pipeline has both the source and the target being the shape of the knot it was derived from.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.signature(unitpipe)\n#=>\nSignature(BlockOf(TupleOf(), x1to1),\n          BlockOf(TupleOf(), x1to1) |> IsFlow)\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We could use this unitpipe on itself.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitpipe(unitknot)\n#=>\n┼──┼\n│  │\n=#","category":"page"},{"location":"primer/#Queries-are-Pipeline-Extensions-1","page":"Thinking in Queries","title":"Queries are Pipeline Extensions","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Previously we saw how we could assemble a Query to a Pipeline by providing a given shape. In the more nominal case, one builds pipelines by extending previous pipelines. Let's recall our unitpipe.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitpipe = DataKnots.trivial_pipe(unitknot)\n#-> pass()","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Let's extend the this pipeline with the query Lift(\"Hello\").","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"hello_pipe = DataKnots.assemble(nothing, unitpipe, Lift(\"Hello\"))\n#-> chain_of(with_elements(chain_of(filler(\"Hello\"), wrap())), flatten())","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This pipeline could then be run.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"hello_pipe(unitknot)\n#=>\n┼───────┼\n│ Hello │\n=#","category":"page"},{"location":"primer/#Combinators-1","page":"Thinking in Queries","title":"Combinators","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Now that we've covered shapes and pipelines, we could go further into detail how things work at a higher level.","category":"page"},{"location":"primer/#Lifting-Functions-1","page":"Thinking in Queries","title":"Lifting Functions","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Any function could be used in a query. Consider the function double(x) that, when applied to a Number, produces a Number:","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"double(x) = 2x\ndouble(3) #-> 6","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"What we want is an analogue to double which, instead of operating on numbers, operates on queries. Such functions are called query combinators. We can convert any function to a combinator by passing the function and its arguments to Lift.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Double(X) = Lift(double, (X,))","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"For a given query X, the combinator Double(X) evaluates X and then runs each output element though the double function.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Double(It)]\n#=>\n──┼───┼\n1 │ 2 │\n2 │ 4 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Alternatively, instead of Lift we could use broadcasting. For example, double.(It) is equivalent to Lift(double, (It,)).","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> double.(It)]\n#=>\n──┼───┼\n1 │ 2 │\n2 │ 4 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Broadcasting also works with operators.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> (It .+ 1)]\n#=>\n──┼───┼\n1 │ 2 │\n2 │ 3 │\n3 │ 4 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Unary operators can be broadcast as well.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> (√).(It)]\n#=>\n──┼─────────┼\n1 │ 1.0     │\n2 │ 1.41421 │\n3 │ 1.73205 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Broadcasting could only be used when at least one argument is a query. For this reason, when defining a combinator, it is recommended to use Lift over broadcasting.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Sqrt(X) = Lift(√, (X,))\n\nunitknot[Sqrt(2)]\n#=>\n┼─────────┼\n│ 1.41421 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Vector-valued functions give rise to plural queries. Here, the unit range constructor is lifted to a query combinator that builds plural queries.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"OneTo(X) = Lift(:, (1, X))\n\nunitknot[OneTo(3)]\n#=>\n──┼───┼\n1 │ 1 │\n2 │ 2 │\n3 │ 3 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Since later in this guide we'll want to enumerate the alphabet, let's define a combinator for that as well. In this definition, anonymous function syntax (->) is used to build an expression that is then lifted to queries.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Chars(N) = Lift(n -> 'a':'a'+n-1, (N,))\n\nunitknot[Chars(3)]\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Lifting lets us use rich statistical and data processing functions from within our queries.","category":"page"},{"location":"primer/#Aggregate-Queries-1","page":"Thinking in Queries","title":"Aggregate Queries","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"So far queries have been elementwise; that is, for each input element, they produce zero or more output elements. Consider the Count primitive; it returns the number of its input elements.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Count]\n#=>\n┼───┼\n│ 3 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"An aggregate query such as Count is computed over the input as a whole, and not for each individual element. The semantics of aggregates require discussion. Consider Lift(1:3) >> OneTo(It).","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"OneTo(X) = Lift(:, (1, X))\n\nunitknot[Lift(1:3) >> OneTo(It)]\n#=>\n──┼───┼\n1 │ 1 │\n2 │ 1 │\n3 │ 2 │\n4 │ 1 │\n5 │ 2 │\n6 │ 3 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"By appending >> Sum we could aggregate the entire input flow, producing a single output element.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> OneTo(It) >> Sum]\n#=>\n┼────┼\n│ 10 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"What if we wanted to produce sums by the outer query, Lift(1:3)? Since query composition (>>) is associative, adding parenthesis around OneTo(It) >> Sum will not change the result.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> (OneTo(It) >> Sum)]\n#=>\n┼────┼\n│ 10 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We could use Record to create this elementwise barrier. However, it introduces an intermediate, unwanted structure: we asked for sums, not a table with sums.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >>\n         Record(:data => OneTo(It),\n                :sum => OneTo(It) >> Sum)]\n#=>\n  │ data     sum │\n──┼──────────────┼\n1 │ 1          1 │\n2 │ 1; 2       3 │\n3 │ 1; 2; 3    6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We need the Each combinator, which much the same as Record, acts as an elementwise barrier. For each input element, Each evaluates its argument, and then collects the outputs.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Each(OneTo(It) >> Sum)]\n#=>\n──┼───┼\n1 │ 1 │\n2 │ 3 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Normally, one wouldn't need to use Each — for aggregates such as Sum or Count, the query Y >> Each(X >> Count) is equivalent to Y >> Count(X). Hence, we could use the combinator form of Sum to do this relative summation.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Sum(OneTo(It))]\n#=>\n──┼───┼\n1 │ 1 │\n2 │ 3 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Julia functions taking a vector argument, such as mean, can be lifted to a combinator taking a plural query. When performed, the plural output is converted into the function's vector argument.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"using Statistics\nMean(X) = mean.(X)\n\nunitknot[Mean(Lift(1:3) >> Sum(OneTo(It)))]\n#=>\n┼─────────┼\n│ 3.33333 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To use Mean as a query primitive, we use Then to build a query that aggregates elements from its input. Next, we register this query aggregate so it is used when Mean is treated as a query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.Lift(::typeof(Mean)) = DataKnots.Then(Mean)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Once these are done, one could take an average of sums as follows:","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Sum(OneTo(It)) >> Mean]\n#=>\n┼─────────┼\n│ 3.33333 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"In DataKnots, summary operations are expressed as aggregate query primitives or as query combinators taking a plural query argument. Moreover, custom aggregates can be constructed from native Julia functions and lifted into the query algebra.","category":"page"},{"location":"primer/#Take-1","page":"Thinking in Queries","title":"Take","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Unlike Filter which evaluates its argument for each input element, the argument to Take is evaluated once, and in the context of the input's source.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> Each(Lift('a':'c') >> Take(It))]\n#=>\n──┼───┼\n1 │ a │\n2 │ a │\n3 │ b │\n4 │ a │\n5 │ b │\n6 │ c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"In this example, the argument of Take evaluates in the context of Lift(1:3). Therefore, Take will be performed three times, where It has the values 1, 2, and 3.","category":"page"},{"location":"primer/#Group-1","page":"Thinking in Queries","title":"Group","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Before we can demonstrate Group, we need an interesting dataset. Let's create a flat list of numbers with two characteristics.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataRow = :data=> Record(:no => It,\n                         :even => iseven.(It),\n                         :char => Char.((It .+ 2) .% 3 .+ 97))\nDataSet = Lift(1:9) >> DataRow\n\nunitknot[DataSet]\n#=>\n  │ data            │\n  │ no  even   char │\n──┼─────────────────┼\n1 │  1  false  a    │\n2 │  2   true  b    │\n3 │  3  false  c    │\n4 │  4   true  a    │\n5 │  5  false  b    │\n6 │  6   true  c    │\n7 │  7  false  a    │\n8 │  8   true  b    │\n9 │  9  false  c    │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The Group combinator rearranges the dataset to bucket unique values of a particular expression together with its matching data.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[DataSet >> Group(It.char)]\n#=>\n  │ char  data{no,even,char}                   │\n──┼────────────────────────────────────────────┼\n1 │ a     1, false, a; 4, true, a; 7, false, a │\n2 │ b     2, true, b; 5, false, b; 8, true, b  │\n3 │ c     3, false, c; 6, true, c; 9, false, c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"With this rearrangement, we could summarize data with respect to the grouping expression.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[DataSet >>\n         Group(It.char) >>\n         Record(It.char,\n                It.data.no,\n                :count => Count(It.data),\n                :mean => mean.(It.data.no))]\n#=>\n  │ char  no       count  mean │\n──┼────────────────────────────┼\n1 │ a     1; 4; 7      3   4.0 │\n2 │ b     2; 5; 8      3   5.0 │\n3 │ c     3; 6; 9      3   6.0 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"It's possible to group by more than one expression.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[DataSet >>\n         Group(It.even, It.char) >>\n         Record(It.even, It.char, It.data.no)]\n#=>\n  │ even   char  no   │\n──┼───────────────────┼\n1 │ false  a     1; 7 │\n2 │ false  b     5    │\n3 │ false  c     3; 9 │\n4 │  true  a     4    │\n5 │  true  b     2; 8 │\n6 │  true  c     6    │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The Group combinator lets you adapt the structure of a dataset to form a hierarchy suitable to a particular analysis.","category":"page"},{"location":"primer/#Query-Parameters-1","page":"Thinking in Queries","title":"Query Parameters","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"With DataKnots, parameters can be provided so that static data can be used within query expressions. By convention, we use upper case, singular labels for query parameters.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[\"Hello \" .* Get(:WHO), WHO=\"World\"]\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To make Get convenient, It provides a shorthand syntax.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[\"Hello \" .* It.WHO, WHO=\"World\"]\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Query parameters are available anywhere in the query. They could, for example be used within a filter.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"query = OneTo(6) >> Filter(It .> It.START)\n\nunitknot[query, START=3]\n#=>\n──┼───┼\n1 │ 4 │\n2 │ 5 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Parameters can also be defined as part of a query using Given. This combinator takes set of pairs (=>) that map symbols (:name) onto query expressions. The subsequent argument is then evaluated in a naming context where the defined parameters are available for reuse.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Given(:WHO => \"World\", \"Hello \" .* Get(:WHO))]\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Query parameters can be especially useful when managing aggregates, or with expressions that one may wish to repeat more than once.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"GreaterThanAverage(X) =\n  Given(:AVG => Mean(X),\n        X >> Filter(It .> Get(:AVG)))\n\nunitknot[GreaterThanAverage(OneTo(6))]\n#=>\n──┼───┼\n1 │ 4 │\n2 │ 5 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"With Given the parameter provided, AVG does not leak into the surrounding context.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[GreaterThanAverage(OneTo(6)) >> It.AVG]\n#-> ERROR: cannot find \"AVG\" at ⋮","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"In DataKnots, query parameters permit external data to be used within query expressions. Parameters that are defined with Given can be used to remember values and reuse them.","category":"page"},{"location":"primer/#Julia-Integration-1","page":"Thinking in Queries","title":"Julia Integration","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots is a query algebra embedded in the Julia programming language. We should discuss the interaction between the semantics of the query algebra and the semantics of Julia.","category":"page"},{"location":"primer/#Precedence-of-Composition-1","page":"Thinking in Queries","title":"Precedence of Composition","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots uses Julia's bitshift operator (>>) for composition.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This works visually, but the precedence of this operator does not match user expectations. Specifically, common binary operators such as addition (+) have a lower precedence.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This expectation mismatch could lead a user to write:","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> It .+ It]\n#-> ERROR: cannot apply + to Tuple{Array{Int64,1},Tuple{}}⋮","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To fix this query, we add parentheses.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> (It .+ It)]\n#=>\n──┼───┼\n1 │ 2 │\n2 │ 4 │\n3 │ 6 │\n=#","category":"page"},{"location":"primer/#Composition-of-Queries-1","page":"Thinking in Queries","title":"Composition of Queries","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"For bitshift operator (>>) to work as composition, the first operand must be a query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[1:3 >> \"Hello\"]\n#-> ERROR: MethodError: no method matching >>(::Int64, ::String)⋮","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"To fix this query, we use Lift to convert the first operand to a query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> \"Hello\"]\n#=>\n──┼───────┼\n1 │ Hello │\n2 │ Hello │\n3 │ Hello │\n=#","category":"page"},{"location":"primer/#Support-for-Tuple-1","page":"Thinking in Queries","title":"Support for Tuple","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"A Tuple lifted to a constant query is displayed as a table.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift((msg=\"Hello\",))]\n#=>\n│ msg   │\n┼───────┼\n│ Hello │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"When they are lifted, native vectors are automatically converted into our block vector. However, native tuples are left unwrapped.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(unitknot[Lift((msg=\"Hello\",))])\n#-> BlockOf(NamedTuple{(:msg,),Tuple{String}}, x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"That said, tuple entries can be directly accessed using It.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift((msg=\"Hello\",)) >> It.msg]\n#=>\n│ msg   │\n┼───────┼\n│ Hello │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Although it looks the same visually, this has a different shape.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(unitknot[Lift((msg=\"Hello\",)) >> It.msg])\n#-> BlockOf(String, x1to1) |> IsLabeled(:msg)","category":"page"},{"location":"primer/#Cardinality-of-Lift-1","page":"Thinking in Queries","title":"Cardinality of Lift","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"For constant queries produced by Lift, the cardinality is guessed based upon the type of the underlying data.  If the type is Missing, then it is x0to1. If the type is a kind of AbstractVector, then Lift guesses it should be unconstrained (:x0toN). All other data types are assumed to have a mandatory, singular cardinality (:x1to1).","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Type Cardinality Mandatory Singular\nMissing :x0to1 no yes\nAbstractVector :x0toN no no\nAny :x1to1 yes yes\n :x1toN yes no","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We can cause a constant query produced by Lift to produce knots having a specific cardinality.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"greetings = unitknot[Lift([\"Hello\"], :x1toN)]\n#=>\n──┼───────┼\n1 │ Hello │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The shape of the greetings knot will then indicate that it has a plural block with at least one element.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(greetings)\n#-> BlockOf(String, x1toN)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Observe that specifying the cardinality works even for singular values, even if the value lifted happens to be a vector.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"greeting = unitknot[Lift([\"Hello\"], :x1to1)]\n#=>\n┼───────┼\n│ Hello │\n=#\n\nDataKnots.shape(greeting)\n#-> BlockOf(String, x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Just because a Vector is automatically converted into a block doesn't mean a block can't contain a vector.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"opaque = [\"HELLO\", \"WORLD\"]\n\nsingle = unitknot[Lift([opaque], :x1to1)]\n#=>\n┼──────────────┼\n│ HELLO; WORLD │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"The value of this knot is actually a Vector, even if it may be shown in a convenient way.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"DataKnots.shape(single)\n#-> BlockOf(Array{String,1}, x1to1)","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"This value can be retrieved using get.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"get(single)\n#-> [\"HELLO\", \"WORLD\"]","category":"page"},{"location":"primer/#Broadcasting-over-Queries-1","page":"Thinking in Queries","title":"Broadcasting over Queries","text":"","category":"section"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Broadcasting can be used to convert function calls into query expressions. For broadcasting to build a query, at least one argument must be a query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Even when the argument isn't a query, the result often works as expected.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[iseven.(2)]\n#=>\n┼──────┼\n│ true │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"In this case, iseven.(2) is evaluated to the constant true, which is automatically lifted to a constant query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"For some functions this may lead to unexpected results. Suppose we need to generate 3 random characters.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"using Random: seed!, rand\nseed!(1)\nrand('a':'z')\n#-> 'o'","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"We could try to make the following query.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> rand('a':'z')]\n#=>\n──┼───┼\n1 │ c │\n2 │ c │\n3 │ c │\n=#","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"Unfortunately, the function rand evaluated once, which gives us the same value repeated 3 times. Let's try broadcasting.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> rand.('a':'z')]\n#-> ERROR: ArgumentError: Sampler for this object is not defined⋮","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"For broadcasting to generate a query, we need at least one argument to be a query. If we don't have a query argument, we could make one using Lift.","category":"page"},{"location":"primer/#","page":"Thinking in Queries","title":"Thinking in Queries","text":"unitknot[Lift(1:3) >> rand.(Lift('a':'z'))]\n#=>\n──┼───┼\n1 │ h │\n2 │ b │\n3 │ v │\n=#","category":"page"},{"location":"vectors/#Column-Store-1","page":"Column Store","title":"Column Store","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"This section describes how DataKnots implements an in-memory column store. We will need the following definitions:","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"using DataKnots:\n    @VectorTree,\n    BlockVector,\n    Cardinality,\n    TupleVector,\n    cardinality,\n    column,\n    columns,\n    elements,\n    ismandatory,\n    issingular,\n    labels,\n    offsets,\n    width,\n    x0to1,\n    x0toN,\n    x1to1,\n    x1toN","category":"page"},{"location":"vectors/#Tabular-Data-and-TupleVector-1","page":"Column Store","title":"Tabular Data and TupleVector","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Structured data can often be represented in a tabular form.  For example, information about city employees can be arranged in the following table.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"name position salary\nJEFFERY A SERGEANT 101442\nJAMES A FIRE ENGINEER-EMT 103350\nTERRY A POLICE OFFICER 93354","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Internally, a database engine stores tabular data using composite data structures such as tuples and vectors.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"A tuple is a fixed-size collection of heterogeneous values and can represent a table row.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"A vector is a variable-size collection of homogeneous values and can store a table column.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"[\"JEFFERY A\", \"JAMES A\", \"TERRY A\"]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"For a table as a whole, we have two options: either store it as a vector of tuples or store it as a tuple of vectors.  The former is called a row-oriented format, commonly used in programming and traditional database engines.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"[(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442),\n (name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350),\n (name = \"TERRY A\", position = \"POLICE OFFICER\", salary = 93354)]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"The other option, \"tuple of vectors\" layout, is called a column-oriented format.  It is often used by analytical databases as it is more suited for processing complex analytical queries.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"The DataKnots package implements data structures to support column-oriented data format.  In particular, tabular data is represented using TupleVector objects.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(:name => [\"JEFFERY A\", \"JAMES A\", \"TERRY A\"],\n            :position => [\"SERGEANT\", \"FIRE ENGINEER-EMT\", \"POLICE OFFICER\"],\n            :salary => [101442, 103350, 93354])","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Since creating TupleVector objects by hand is tedious and error prone, DataKnots provides a convenient macro @VectorTree, which lets you create column-oriented data using regular tuple and vector literals.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree (name = String, position = String, salary = Int) [\n    (name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442),\n    (name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350),\n    (name = \"TERRY A\", position = \"POLICE OFFICER\", salary = 93354),\n]","category":"page"},{"location":"vectors/#Hierarchical-Data-and-BlockVector-1","page":"Column Store","title":"Hierarchical Data and BlockVector","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Structured data could also be organized in hierarchical fashion.  For example, consider a collection of departments, where each department contains a list of associated employees.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"name employee\nPOLICE JEFFERY A; NANCY A\nFIRE JAMES A; DANIEL A\nOEMC LAKENYA A; DORIS A","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"In the row-oriented format, this data is represented using nested vectors.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"[(name = \"POLICE\", employee = [\"JEFFERY A\", \"NANCY A\"]),\n (name = \"FIRE\", employee = [\"JAMES A\", \"DANIEL A\"]),\n (name = \"OEMC\", employee = [\"LAKENYA A\", \"DORIS A\"])]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"To represent this data in column-oriented format, we need to serialize name and employee as column vectors.  The name column is straightforward.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"name_col = [\"POLICE\", \"FIRE\", \"OEMC\"]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"As for the employee column, naively, we could store it as a vector of vectors.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"[[\"JEFFERY A\", \"NANCY A\"], [\"JAMES A\", \"DANIEL A\"], [\"LAKENYA A\", \"DORIS A\"]]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"However, this representation loses the advantages of the column-oriented format since the data is no longer serialized with a fixed number of vectors. Instead, we should keep the column data in a tightly-packed vector of elements.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"employee_elts = [\"JEFFERY A\", \"NANCY A\", \"JAMES A\", \"DANIEL A\", \"LAKENYA A\", \"DORIS A\"]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"This vector could be partitioned into separate blocks by the vector of offsets.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"employee_offs = [1, 3, 5, 7]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Each pair of adjacent offsets corresponds a slice of the element vector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"employee_elts[employee_offs[1]:employee_offs[2]-1]\n#-> [\"JEFFERY A\", \"NANCY A\"]\nemployee_elts[employee_offs[2]:employee_offs[3]-1]\n#-> [\"JAMES A\", \"DANIEL A\"]\nemployee_elts[employee_offs[3]:employee_offs[4]-1]\n#-> [\"LAKENYA A\", \"DORIS A\"]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Together, elements and offsets faithfully reproduce the layout of the column. A pair of the offset and the element vectors is encapsulated with a BlockVector object, which represents a column-oriented encoding of a vector of variable-size blocks.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"employee_col = BlockVector(employee_offs, employee_elts)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Now we can wrap the columns using TupleVector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(:name => name_col, :employee => employee_col)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree provides a convenient way to create BlockVector objects from regular vector literals.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree (name = String, employee = (0:N)String) [\n    (name = \"POLICE\", employee = [\"JEFFERY A\", \"NANCY A\"]),\n    (name = \"FIRE\", employee = [\"JAMES A\", \"DANIEL A\"]),\n    (name = \"OEMC\", employee = [\"LAKENYA A\", \"DORIS A\"]),\n]","category":"page"},{"location":"vectors/#Optional-Values-1","page":"Column Store","title":"Optional Values","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"As we arrange data in a tabular form, we may need to leave some cells blank.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"For example, consider that a city employee could be compensated either with salary or with hourly pay.  To display the compensation data in a table, we add two columns: the annual salary and the hourly rate.  However, only one of the columns per each row is filled.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"name position salary rate\nJEFFERY A SERGEANT 101442 \nJAMES A FIRE ENGINEER-EMT 103350 \nTERRY A POLICE OFFICER 93354 \nLAKENYA A CROSSING GUARD  17.68","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"As in the previous section, the cells in this table may contain a variable number of values.  Therefore, the table columns could be represented using BlockVector objects.  We start with packing the column data as element vectors.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"salary_elts = [101442, 103350, 93354]\nrate_elts = [17.68]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Element vectors are partitioned into table cells by offset vectors.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"salary_offs = [1, 2, 3, 4, 4]\nrate_offs = [1, 1, 1, 1, 2]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"The pairs of element and offset vectors are wrapped as BlockVector objects.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"salary_col = BlockVector(salary_offs, salary_elts, x0to1)\nrate_col = BlockVector(rate_offs, rate_elts, x0to1)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Here, the last parameter of the BlockVector constructor is the cardinality constraint on the size of the blocks.  The constraint x0to1 indicates that each block should contain from 0 to 1 elements.  The default constraint x0toN does not restrict the block size.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"The first two columns of the table do not contain empty cells, and therefore could be represented by regular vectors.  If we choose to wrap these columns with BlockVector, we should use the constraint x1to1 to indicate that each block must contain exactly one element.  Alternatively, BlockVector provides the following shorthand notation.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"name_col = BlockVector(:, [\"JEFFERY A\", \"JAMES A\", \"TERRY A\", \"LAKENYA A\"])\nposition_col = BlockVector(:, [\"SERGEANT\", \"FIRE ENGINEER-EMT\", \"POLICE OFFICER\", \"CROSSING GUARD\"])","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"To represent the whole table, the columns should be wrapped with a TupleVector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(\n    :name => name_col,\n    :position => position_col,\n    :salary => salary_col,\n    :rate => rate_col)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"As usual, we could create this data from tuple and vector literals.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree (name = (1:1)String,\n             position = (1:1)String,\n             salary = (0:1)Int,\n             rate = (0:1)Float64) [\n    (name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing),\n    (name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350, rate = missing),\n    (name = \"TERRY A\", position = \"POLICE OFFICER\", salary = 93354, rate = missing),\n    (name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68),\n]","category":"page"},{"location":"vectors/#Nested-Data-1","page":"Column Store","title":"Nested Data","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"When data does not fit a single table, it can often be presented in a top-down fashion.  For example, HR data can be seen as a collection of departments, each of which containing the associated employees.  Such data is serialized using nested data structures, which, in row-oriented format, may look as follows:","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"[(name = \"POLICE\",\n  employee = [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing),\n              (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016, rate = missing)]),\n (name = \"FIRE\",\n  employee = [(name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350, rate = missing),\n              (name = \"DANIEL A\", position = \"FIRE FIGHTER-EMT\", salary = 95484, rate = missing)]),\n (name = \"OEMC\",\n  employee = [(name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68),\n              (name = \"DORIS A\", position = \"CROSSING GUARD\", salary = missing, rate = 19.38)])]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"To store this data in a column-oriented format, we should use nested TupleVector and BlockVector instances.  We start with representing employee data.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"employee_elts =\n    TupleVector(\n        :name => [\"JEFFERY A\", \"NANCY A\", \"JAMES A\", \"DANIEL A\", \"LAKENYA A\", \"DORIS A\"],\n        :position => [\"SERGEANT\", \"POLICE OFFICER\", \"FIRE ENGINEER-EMT\", \"FIRE FIGHTER-EMT\", \"CROSSING GUARD\", \"CROSSING GUARD\"],\n        :salary => BlockVector([1, 2, 3, 4, 5, 5, 5], [101442, 80016, 103350, 95484], x0to1),\n        :rate => BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], x0to1))","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Then we partition employee data by departments:","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"employee_col = BlockVector([1, 3, 5, 7], employee_elts)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Adding a column of department names, we obtain HR data in a column-oriented format.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(\n    :name => [\"POLICE\", \"FIRE\", \"OEMC\"],\n    :employee => employee_col)","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Another way to assemble this data in column-oriented format is to use @VectorTree.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree (name = String,\n             employee = [(name = String,\n                          position = String,\n                          salary = (0:1)Int,\n                          rate = (0:1)Float64)]) [\n    (name = \"POLICE\",\n     employee = [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing),\n                 (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016, rate = missing)]),\n    (name = \"FIRE\",\n     employee = [(name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350, rate = missing),\n                 (name = \"DANIEL A\", position = \"FIRE FIGHTER-EMT\", salary = 95484, rate = missing)]),\n    (name = \"OEMC\",\n     employee = [(name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68),\n                 (name = \"DORIS A\", position = \"CROSSING GUARD\", salary = missing, rate = 19.38)])\n]","category":"page"},{"location":"vectors/#API-Reference-1","page":"Column Store","title":"API Reference","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Modules = [DataKnots]\nPages = [\"vectors.jl\"]\nPublic = false","category":"page"},{"location":"vectors/#DataKnots.BlockVector","page":"Column Store","title":"DataKnots.BlockVector","text":"BlockVector(offs::AbstractVector{Int}, elts::AbstractVector, card::Cardinality=x0toN)\nBlockVector(:, elts::AbstractVector, card::Cardinality=x1to1)\n\nVector of data blocks stored as a vector of elements partitioned by a vector of offsets.\n\nelts is a continuous vector of block elements.\noffs is a vector of indexes that subdivide elts into separate blocks. Should be monotonous with offs[1] == 1 and offs[end] == length(elts)+1. Use : if the offset vector is a unit range.\ncard is the cardinality constraint on the blocks.\n\n\n\n\n\n","category":"type"},{"location":"vectors/#DataKnots.Cardinality","page":"Column Store","title":"DataKnots.Cardinality","text":"x1to1::Cardinality\nx0to1::Cardinality\nx1toN::Cardinality\nx0toN::Cardinality\n\nCardinality constraints on a block of data.\n\n\n\n\n\n","category":"type"},{"location":"vectors/#DataKnots.TupleVector","page":"Column Store","title":"DataKnots.TupleVector","text":"TupleVector([lbls::Vector{Symbol},] len::Int, cols::Vector{AbstractVector})\nTupleVector([lbls::Vector{Symbol},] idxs::AbstractVector{Int}, cols::Vector{AbstractVector})\nTupleVector(lcols::Pair{<:Union{Symbol,AbstractString},<:AbstractVector}...)\n\nVector of tuples stored as a collection of column vectors.\n\ncols is a vector of columns; optional lbls is a vector of column labels. Alternatively, labels and columns could be provided as a list of pairs lcols.\nlen is the vector length, which must coincide with the length of all the columns.  Alternatively, the vector could be constructed from a subset of the column data using a vector of indexes idxs.\n\n\n\n\n\n","category":"type"},{"location":"vectors/#Base.getindex-Tuple{DataKnots.BlockVector,AbstractArray{T,1} where T}","page":"Column Store","title":"Base.getindex","text":"(::BlockVector)[ks::AbstractVector{Int}] :: BlockVector\n\nReturns a new BlockVector with a selection of blocks specified by indexes ks.\n\n\n\n\n\n","category":"method"},{"location":"vectors/#Base.getindex-Tuple{DataKnots.TupleVector,AbstractArray{T,1} where T}","page":"Column Store","title":"Base.getindex","text":"(::TupleVector)[ks::AbstractVector{Int}] :: TupleVector\n\nReturns a new TupleVector with a subset of rows specified by indexes ks.\n\n\n\n\n\n","category":"method"},{"location":"vectors/#DataKnots.@VectorTree-Tuple{Any,Any}","page":"Column Store","title":"DataKnots.@VectorTree","text":"@VectorTree sig vec\n\nConstructs a tree of columnar vectors from a plain vector literal.\n\nThe first parameter, sig, describes the tree structure.  It is defined recursively:\n\nJulia type T indicates a regular vector of type T.\nTuple (col₁, col₂, ...) indicates a TupleVector instance.\nNamed tuple (lbl₁ = col₁, lbl₂ = col₂, ...) indicates a TupleVector instance with the given labels.\nPrefixes (0:N), (1:N), (0:1), (1:1) indicate a BlockVector instance with the respective cardinality constraints (no constraints, mandatory, singular, mandatory+singular).\n\nThe second parameter, vec, is a vector literal in row-oriented format:\n\nTupleVector data is specified either by a matrix or by a vector of (regular or named) tuples.\nBlockVector data is specified by a vector of vectors.  A one-element block could be represented by its element; an empty block by missing literal.\n\n\n\n\n\n","category":"macro"},{"location":"vectors/#Test-Suite-1","page":"Column Store","title":"Test Suite","text":"","category":"section"},{"location":"vectors/#TupleVector-1","page":"Column Store","title":"TupleVector","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector is a vector of tuples stored as a collection of parallel vectors.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"tv = TupleVector(:name => [\"GARRY M\", \"ANTHONY R\", \"DANA A\"],\n                 :salary => [260004, 185364, 170112])\n#-> @VectorTree (name = String, salary = Int64) [(name = \"GARRY M\", salary = 260004) … ]\n\ndisplay(tv)\n#=>\n@VectorTree of 3 × (name = String, salary = Int64):\n (name = \"GARRY M\", salary = 260004)\n (name = \"ANTHONY R\", salary = 185364)\n (name = \"DANA A\", salary = 170112)\n=#","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Labels could be specified by strings.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(:salary => [260004, 185364, 170112], \"#B\" => [true, false, false])\n#-> @VectorTree (salary = Int64, \"#B\" = Bool) [(salary = 260004, #B = 1) … ]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"It is also possible to construct a TupleVector without labels.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(length(tv), columns(tv))\n#-> @VectorTree (String, Int64) [(\"GARRY M\", 260004) … ]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"An error is reported in case of duplicate labels or columns of different height.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector(:name => [\"GARRY M\", \"ANTHONY R\"],\n            :name => [\"DANA A\", \"JUAN R\"])\n#-> ERROR: duplicate column label :name\n\nTupleVector(:name => [\"GARRY M\", \"ANTHONY R\"],\n            :salary => [260004, 185364, 170112])\n#-> ERROR: unexpected column height","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"We can access individual components of the vector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"labels(tv)\n#-> Symbol[:name, :salary]\n\nwidth(tv)\n#-> 2\n\ncolumn(tv, 2)\n#-> [260004, 185364, 170112]\n\ncolumn(tv, :salary)\n#-> [260004, 185364, 170112]\n\ncolumns(tv)\n#-> …[[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [260004, 185364, 170112]]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"When indexed by another vector, we get a new instance of TupleVector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"tv′ = tv[[3,1]]\ndisplay(tv′)\n#=>\n@VectorTree of 2 × (name = String, salary = Int64):\n (name = \"DANA A\", salary = 170112)\n (name = \"GARRY M\", salary = 260004)\n=#","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Note that the new instance wraps the index and the original column vectors. Updated column vectors are generated on demand.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"column(tv′, 2)\n#-> [170112, 260004]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"A labeled TupleVector supports a Tables.jl export interface.  For example, we can convert a TupleVector instance to a DataFrame.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"using DataFrames\n\ntv |> DataFrame |> display\n#=>\n3×2 DataFrames.DataFrame\n│ Row │ name      │ salary │\n│     │ String    │ Int64  │\n├─────┼───────────┼────────┤\n│ 1   │ GARRY M   │ 260004 │\n│ 2   │ ANTHONY R │ 185364 │\n│ 3   │ DANA A    │ 170112 │\n=#","category":"page"},{"location":"vectors/#Cardinality-1","page":"Column Store","title":"Cardinality","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Enumerated type Cardinality is used to constrain the cardinality of a data block.  There are four different cardinality constraints: just one (1:1), zero or one (0:1), one or many (1:N), and zero or many (0:N).","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"display(Cardinality)\n#=>\nEnum Cardinality:\nx1to1 = 0x00\nx0to1 = 0x01\nx1toN = 0x02\nx0toN = 0x03\n=#","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Cardinality values could be obtained from the matching symbols.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"convert(Cardinality, :x1toN)\n#-> x1toN","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Cardinality values support bitwise operations.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"x1to1|x0to1|x1toN           #-> x0toN\nx1toN&~x1toN                #-> x1to1","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"We can use predicates ismandatory() and issingular() to check if a constraint is present.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"ismandatory(x0to1)          #-> false\nismandatory(x1toN)          #-> true\nissingular(x1toN)           #-> false\nissingular(x0to1)           #-> true","category":"page"},{"location":"vectors/#BlockVector-1","page":"Column Store","title":"BlockVector","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"BlockVector is a vector of homogeneous vectors (blocks) stored as a vector of elements partitioned into individual blocks by a vector of offsets.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"bv = BlockVector([1, 3, 5, 7], [\"JEFFERY A\", \"NANCY A\", \"JAMES A\", \"DANIEL A\", \"LAKENYA A\", \"DORIS A\"])\n#-> @VectorTree (0:N) × String [[\"JEFFERY A\", \"NANCY A\"], [\"JAMES A\", \"DANIEL A\"], [\"LAKENYA A\", \"DORIS A\"]]\n\ndisplay(bv)\n#=>\n@VectorTree of 3 × (0:N) × String:\n [\"JEFFERY A\", \"NANCY A\"]\n [\"JAMES A\", \"DANIEL A\"]\n [\"LAKENYA A\", \"DORIS A\"]\n=#","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"We can indicate that each block should contain at most one element or at least one element.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"BlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], x0to1)\n#-> @VectorTree (0:1) × Float64 [missing, missing, missing, missing, 17.68, 19.38]\n\nBlockVector([1, 3, 5, 7], [\"JEFFERY A\", \"NANCY A\", \"JAMES A\", \"DANIEL A\", \"LAKENYA A\", \"DORIS A\"], x1toN)\n#-> @VectorTree (1:N) × String [[\"JEFFERY A\", \"NANCY A\"], [\"JAMES A\", \"DANIEL A\"], [\"LAKENYA A\", \"DORIS A\"]]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"If each block contains exactly one element, we could use : in place of the offset vector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"BlockVector(:, [\"POLICE\", \"FIRE\", \"OEMC\"])\n#-> @VectorTree (1:1) × String [\"POLICE\", \"FIRE\", \"OEMC\"]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"The BlockVector constructor verifies that the offset vector is well-formed.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"BlockVector(Base.OneTo(0), [])\n#-> ERROR: offsets must be non-empty\n\nBlockVector(Int[], [])\n#-> ERROR: offsets must be non-empty\n\nBlockVector([0], [])\n#-> ERROR: offsets must start with 1\n\nBlockVector([1,2,2,1], [\"HEALTH\"])\n#-> ERROR: offsets must be monotone\n\nBlockVector(Base.OneTo(4), [\"HEALTH\", \"FINANCE\"])\n#-> ERROR: offsets must enclose the elements\n\nBlockVector([1,2,3,6], [\"HEALTH\", \"FINANCE\"])\n#-> ERROR: offsets must enclose the elements","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"The constructor also validates the cardinality constraint.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"BlockVector([1, 3, 5, 7], [\"JEFFERY A\", \"NANCY A\", \"JAMES A\", \"DANIEL A\", \"LAKENYA A\", \"DORIS A\"], x0to1)\n#-> ERROR: singular blocks must have at most one element\n\nBlockVector([1, 1, 1, 1, 1, 2, 3], [17.68, 19.38], x1toN)\n#-> ERROR: mandatory blocks must have at least one element","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"We can access individual components of the vector.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"offsets(bv)\n#-> [1, 3, 5, 7]\n\nelements(bv)\n#-> [\"JEFFERY A\", \"NANCY A\", \"JAMES A\", \"DANIEL A\", \"LAKENYA A\", \"DORIS A\"]\n\ncardinality(bv)\n#-> x0toN","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"When indexed by a vector of indexes, an instance of BlockVector is returned.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"elts = [\"POLICE\", \"FIRE\", \"HEALTH\", \"AVIATION\", \"WATER MGMNT\", \"FINANCE\"]\n\nreg_bv = BlockVector(:, elts)\n#-> @VectorTree (1:1) × String [\"POLICE\", \"FIRE\", \"HEALTH\", \"AVIATION\", \"WATER MGMNT\", \"FINANCE\"]\n\nopt_bv = BlockVector([1, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7], elts, x0to1)\n#-> @VectorTree (0:1) × String [\"POLICE\", \"FIRE\", missing, \"HEALTH\", missing, \"AVIATION\", \"WATER MGMNT\", missing, missing, \"FINANCE\"]\n\nplu_bv = BlockVector([1, 1, 1, 2, 2, 4, 4, 6, 7], elts)\n#-> @VectorTree (0:N) × String [[], [], [\"POLICE\"], [], [\"FIRE\", \"HEALTH\"], [], [\"AVIATION\", \"WATER MGMNT\"], [\"FINANCE\"]]\n\nreg_bv[[1,3,5,3]]\n#-> @VectorTree (1:1) × String [\"POLICE\", \"HEALTH\", \"WATER MGMNT\", \"HEALTH\"]\n\nplu_bv[[1,3,5,3]]\n#-> @VectorTree (0:N) × String [[], [\"POLICE\"], [\"FIRE\", \"HEALTH\"], [\"POLICE\"]]\n\nreg_bv[Base.OneTo(4)]\n#-> @VectorTree (1:1) × String [\"POLICE\", \"FIRE\", \"HEALTH\", \"AVIATION\"]\n\nreg_bv[Base.OneTo(6)]\n#-> @VectorTree (1:1) × String [\"POLICE\", \"FIRE\", \"HEALTH\", \"AVIATION\", \"WATER MGMNT\", \"FINANCE\"]\n\nplu_bv[Base.OneTo(6)]\n#-> @VectorTree (0:N) × String [[], [], [\"POLICE\"], [], [\"FIRE\", \"HEALTH\"], []]\n\nopt_bv[Base.OneTo(10)]\n#-> @VectorTree (0:1) × String [\"POLICE\", \"FIRE\", missing, \"HEALTH\", missing, \"AVIATION\", \"WATER MGMNT\", missing, missing, \"FINANCE\"]","category":"page"},{"location":"vectors/#@VectorTree-1","page":"Column Store","title":"@VectorTree","text":"","category":"section"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"We can use @VectorTree macro to convert vector literals to the columnar form assembled with TupleVector and BlockVector objects.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"TupleVector is created from a matrix or a vector of (named) tuples.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree (name = String, salary = Int) [\n    \"GARRY M\"   260004\n    \"ANTHONY R\" 185364\n    \"DANA A\"    170112\n]\n#-> @VectorTree (name = String, salary = Int64) [(name = \"GARRY M\", salary = 260004) … ]\n\n@VectorTree (name = String, salary = Int) [\n    (\"GARRY M\", 260004),\n    (\"ANTHONY R\", 185364),\n    (\"DANA A\", 170112),\n]\n#-> @VectorTree (name = String, salary = Int64) [(name = \"GARRY M\", salary = 260004) … ]\n\n@VectorTree (name = String, salary = Int) [\n    (name = \"GARRY M\", salary = 260004),\n    (name = \"ANTHONY R\", salary = 185364),\n    (name = \"DANA A\", salary = 170112),\n]\n#-> @VectorTree (name = String, salary = Int64) [(name = \"GARRY M\", salary = 260004) … ]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Column labels are optional.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree (String, Int) [\"GARRY M\" 260004; \"ANTHONY R\" 185364; \"DANA A\" 170112]\n#-> @VectorTree (String, Int64) [(\"GARRY M\", 260004) … ]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"BlockVector is constructed from a vector of vector literals.  A one-element block could be represented by the element itself; an empty block by missing.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree [String] [\n    \"HEALTH\",\n    [\"FINANCE\", \"HUMAN RESOURCES\"],\n    missing,\n    [\"POLICE\", \"FIRE\"],\n]\n#-> @VectorTree (0:N) × String [[\"HEALTH\"], [\"FINANCE\", \"HUMAN RESOURCES\"], [], [\"POLICE\", \"FIRE\"]]","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Ill-formed @VectorTree constructors are rejected.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"@VectorTree \"String\" [\"POLICE\", \"FIRE\"]\n#=>\nERROR: expected a type; got \"String\"\n=#\n\n@VectorTree (String, Int) (\"GARRY M\", 260004)\n#=>\nERROR: LoadError: expected a vector literal; got :((\"GARRY M\", 260004))\n⋮\n=#\n\n@VectorTree (String, Int) [(position = \"SUPERINTENDENT OF POLICE\", salary = 260004)]\n#=>\nERROR: LoadError: expected no label; got :(position = \"SUPERINTENDENT OF POLICE\")\n⋮\n=#\n\n@VectorTree (name = String, salary = Int) [(position = \"SUPERINTENDENT OF POLICE\", salary = 260004)]\n#=>\nERROR: LoadError: expected label :name; got :(position = \"SUPERINTENDENT OF POLICE\")\n⋮\n=#\n\n@VectorTree (name = String, salary = Int) [(\"GARRY M\", \"SUPERINTENDENT OF POLICE\", 260004)]\n#=>\nERROR: LoadError: expected 2 column(s); got :((\"GARRY M\", \"SUPERINTENDENT OF POLICE\", 260004))\n⋮\n=#\n\n@VectorTree (name = String, salary = Int) [\"GARRY M\"]\n#=>\nERROR: LoadError: expected a tuple or a row literal; got \"GARRY M\"\n⋮\n=#","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"Using @VectorTree, we can easily construct hierarchical data.","category":"page"},{"location":"vectors/#","page":"Column Store","title":"Column Store","text":"hier_data = @VectorTree (name = (1:1)String, employee = (0:N)(name = (1:1)String, salary = (0:1)Int)) [\n    \"POLICE\"    [\"GARRY M\" 260004; \"ANTHONY R\" 185364; \"DANA A\" 170112]\n    \"FIRE\"      [\"JOSE S\" 202728; \"CHARLES S\" 197736]\n]\ndisplay(hier_data)\n#=>\n@VectorTree of 2 × (name = (1:1) × String,\n                    employee = (0:N) × (name = (1:1) × String,\n                                        salary = (0:1) × Int64)):\n (name = \"POLICE\", employee = [(name = \"GARRY M\", salary = 260004) … ])\n (name = \"FIRE\", employee = [(name = \"JOSE S\", salary = 202728) … ])\n=#","category":"page"},{"location":"pipelines/#Pipeline-Algebra-1","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"This section describes the Pipeline interface of vectorized data transformations.  We will use the following definitions:","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"using DataKnots:\n    @VectorTree,\n    Pipeline,\n    Runtime,\n    adapt_missing,\n    adapt_tuple,\n    adapt_vector,\n    block_any,\n    block_cardinality,\n    block_filler,\n    block_length,\n    block_lift,\n    block_not_empty,\n    chain_of,\n    column,\n    distribute,\n    distribute_all,\n    filler,\n    flatten,\n    get_by,\n    group_by,\n    lift,\n    null_filler,\n    pass,\n    sieve_by,\n    slice_by,\n    tuple_lift,\n    tuple_of,\n    unique_by,\n    with_column,\n    with_elements,\n    wrap,\n    x0toN,\n    x1to1,\n    x1toN","category":"page"},{"location":"pipelines/#Lifting-and-Fillers-1","page":"Pipeline Algebra","title":"Lifting and Fillers","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"DataKnots stores structured data in a column-oriented format, serialized using specialized composite vector types.  Consequently, operations on data must also be adapted to the column-oriented format.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"In DataKnots, operations on column-oriented data are called pipelines.  A pipeline is a vectorized transformation: it takes a vector of input values and produces a vector of the same size containing output values.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Any unary scalar function could be vectorized, which gives us a simple method for creating new pipelines.  Consider, for example, function titlecase(), which transforms the input string by capitalizing the first letter of each word and converting every other character to lowercase.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"titlecase(\"JEFFERY A\")      #-> \"Jeffery A\"","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"This function can be converted to a pipeline or lifted, using the lift pipeline constructor.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = lift(titlecase)\np([\"JEFFERY A\", \"JAMES A\", \"TERRY A\"])\n#-> [\"Jeffery A\", \"James A\", \"Terry A\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"A scalar function with N arguments could be lifted by tuple_lift to make a pipeline that transforms a TupleVector with N columns.  For example, a binary predicate > gives rise to a pipeline tuple_lift(>) that transforms a TupleVector with two columns into a Boolean vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = tuple_lift(>)\np(@VectorTree (Int, Int) [260004 200000; 185364 200000; 170112 200000])\n#-> Bool[1, 0, 0]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"In a similar manner, a function with a vector argument can be lifted by block_lift to make a pipeline that expects a BlockVector input.  For example, function length(), which returns the length of a vector, could be converted to a pipeline block_lift(length) that transforms a block vector to an integer vector containing block lengths.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_lift(length)\np(@VectorTree [String] [[\"JEFFERY A\", \"NANCY A\"], [\"JAMES A\"]])\n#-> [2, 1]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Not just functions, but also regular values could give rise to pipelines.  The filler constructor makes a pipeline from any scalar value.  This pipeline maps any input vector to a vector filled with the given scalar.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = filler(200000)\np([\"JEFFERY A\", \"JAMES A\", \"TERRY A\"])\n#-> [200000, 200000, 200000]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Similarly, block_filler makes a pipeline from any vector value.  This pipeline produces a BlockVector filled with the given vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_filler([\"POLICE\", \"FIRE\"])\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> @VectorTree (0:N) × String [[\"POLICE\", \"FIRE\"], [\"POLICE\", \"FIRE\"], [\"POLICE\", \"FIRE\"]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"A variant of block_filler called null_filler makes a pipeline that produces a BlockVector filled with empty blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = null_filler()\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> @VectorTree (0:1) × Bottom [missing, missing, missing]","category":"page"},{"location":"pipelines/#Chaining-Pipelines-1","page":"Pipeline Algebra","title":"Chaining Pipelines","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Given a series of pipelines, the chain_of constructor creates their composition pipeline, which transforms the input vector by sequentially applying the given pipelines.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = chain_of(lift(split), lift(first), lift(titlecase))\np([\"JEFFERY A\", \"JAMES A\", \"TERRY A\"])\n#-> [\"Jeffery\", \"James\", \"Terry\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The degenerate composition of an empty sequence of pipelines has its own name, pass(). It passes its input to the output unchanged.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"chain_of()\n#-> pass()\n\np = pass()\np([\"JEFFERY A\", \"JAMES A\", \"TERRY A\"])\n#-> [\"JEFFERY A\", \"JAMES A\", \"TERRY A\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"In general, pipeline constructors that take one or more pipelines as arguments are called pipeline combinators.  Combinators are used to assemble elementary pipelines into complex pipeline expressions.","category":"page"},{"location":"pipelines/#Composite-Vectors-1","page":"Pipeline Algebra","title":"Composite Vectors","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"In DataKnots, composite data is represented as a tree of vectors with regular Vector objects at the leaves and composite vectors, such as TupleVector and BlockVector, at the intermediate nodes. Pipelines that operate and rearrange this tree are described here.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The tuple_of pipeline combinator permits us to construct a TupleVector. TupleVector is a vector of tuples composed of a sequence of column vectors. Any collection of vectors could be used as columns as long as they all have the same length.  One way to obtain N columns for a TupleVector is to apply N pipelines to the same input vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = tuple_of(:first => chain_of(lift(split), lift(first), lift(titlecase)),\n             :last => lift(last))\np([\"JEFFERY A\", \"JAMES A\", \"TERRY A\"])\n#-> @VectorTree (first = String, last = Char) [(first = \"Jeffery\", last = 'A') … ]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"In the opposite direction, the column constructor makes a pipeline that extracts the specified column from the input TupleVector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = column(:salary)\np(@VectorTree (name=String, salary=Int) [(\"JEFFERY A\", 101442), (\"JAMES A\", 103350), (\"TERRY A\", 93354)])\n#-> [101442, 103350, 93354]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The wrap() pipeline primitive is used to create a BlockVector. BlockVector is a vector of vectors serialized as a partitioned vector of elements.  Any input vector could be transformed to a BlockVector by partitioning its elements into one-element blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = wrap()\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> @VectorTree (1:1) × String [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Dual to wrap() is the pipeline flatten(), which transforms a nested BlockVector by flattening its nested blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = flatten()\np(@VectorTree [[String]] [[[\"GARRY M\"], [\"ANTHONY R\", \"DANA A\"]], [[], [\"JOSE S\"], [\"CHARLES S\"]]])\n#-> @VectorTree (0:N) × String [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The distribute constructor makes a pipeline that rearranges a TupleVector with a BlockVector column. This operation exchanges their positions, pushing tuples down and pulling blocks up. Specifically, it takes each tuple, where a specific field must contain a block value, and transforms it to a block of tuples by distributing the block value over the tuple.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = distribute(:employee)\np(@VectorTree (department = String, employee = [String]) [\n    \"POLICE\"    [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]\n    \"FIRE\"      [\"JOSE S\", \"CHARLES S\"]]) |> display\n#=>\n@VectorTree of 2 × (0:N) × (department = String, employee = String):\n [(department = \"POLICE\", employee = \"GARRY M\"), (department = \"POLICE\", employee = \"ANTHONY R\"), (department = \"POLICE\", employee = \"DANA A\")]\n [(department = \"FIRE\", employee = \"JOSE S\"), (department = \"FIRE\", employee = \"CHARLES S\")]\n=#","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Often we need to transform only a part of a composite vector, leaving the rest of the structure intact.  This can be achieved using with_column and with_elements combinators.  Specifically, with_column transforms a specific column of a TupleVector while with_elements transforms the vector of elements of a BlockVector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = with_column(:employee, with_elements(lift(titlecase)))\np(@VectorTree (department = String, employee = [String]) [\n    \"POLICE\"    [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]\n    \"FIRE\"      [\"JOSE S\", \"CHARLES S\"]]) |> display\n#=>\n@VectorTree of 2 × (department = String, employee = (0:N) × String):\n (department = \"POLICE\", employee = [\"Garry M\", \"Anthony R\", \"Dana A\"])\n (department = \"FIRE\", employee = [\"Jose S\", \"Charles S\"])\n=#","category":"page"},{"location":"pipelines/#Specialized-Pipelines-1","page":"Pipeline Algebra","title":"Specialized Pipelines","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Not every data transformation can be implemented with lifting.  DataKnots provide pipeline constructors for some common transformation tasks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"For example, data filtering is implemented with the pipeline sieve_by().  As input, it expects a TupleVector of pairs containing a value and a Bool flag.  sieve_by() transforms the input to a BlockVector containing 0- and 1-element blocks.  When the flag is false, it is mapped to an empty block, otherwise, it is mapped to a one-element block containing the data value.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = sieve_by()\np(@VectorTree (String, Bool) [(\"JEFFERY A\", true), (\"JAMES A\", true), (\"TERRY A\", false)])\n#-> @VectorTree (0:1) × String [\"JEFFERY A\", \"JAMES A\", missing]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"If DataKnots does not provide a specific transformation, it is easy to create a new one.  For example, let us create a pipeline constructor double which makes a pipeline that doubles the elements of the input vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"We need to provide two definitions: to create a Pipeline object and to perform the tranformation on the given input vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"double() = Pipeline(double)\ndouble(::Runtime, input::AbstractVector{<:Number}) = input .* 2\n\np = double()\np([260004, 185364, 170112])\n#-> [520008, 370728, 340224]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"It is also easy to create new pipeline combinators.  Let us create a combinator twice, which applies the given pipeline to the input two times.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"twice(p) = Pipeline(twice, p)\ntwice(rt::Runtime, input, p) = p(rt, p(rt, input))\n\np = twice(double())\np([260004, 185364, 170112])\n#-> [1040016, 741456, 680448]","category":"page"},{"location":"pipelines/#API-Reference-1","page":"Pipeline Algebra","title":"API Reference","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Modules = [DataKnots]\nPages = [\"pipelines.jl\"]\nPublic = false","category":"page"},{"location":"pipelines/#DataKnots.Pipeline","page":"Pipeline Algebra","title":"DataKnots.Pipeline","text":"Pipeline(op, args...)\n\nA pipeline object represents a vectorized data transformation.\n\nParameter op is a function that performs the transformation; args are extra arguments to be passed to the function.\n\nThe pipeline transforms any input vector by invoking op with the following arguments:\n\nop(rt::Runtime, input::AbstractVector, args...)\n\nThe result of op must be the output vector, which should be of the same length as the input vector.\n\n\n\n\n\n","category":"type"},{"location":"pipelines/#DataKnots.Runtime","page":"Pipeline Algebra","title":"DataKnots.Runtime","text":"Runtime()\n\nRuntime state for pipeline evaluation.\n\n\n\n\n\n","category":"type"},{"location":"pipelines/#DataKnots.adapt_missing-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.adapt_missing","text":"adapt_missing() :: Pipeline\n\nThis pipeline transforms a vector that contains missing elements to a block vector with missing elements replaced by empty blocks.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.adapt_tuple-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.adapt_tuple","text":"adapt_tuple() :: Pipeline\n\nThis pipeline transforms a vector of tuples to a tuple vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.adapt_vector-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.adapt_vector","text":"adapt_vector() :: Pipeline\n\nThis pipeline transforms a vector with vector elements to a block vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.block_any-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.block_any","text":"block_any() :: Pipeline\n\nThis pipeline applies any to a block vector with Bool elements.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.block_cardinality-Tuple{DataKnots.Cardinality,Union{Nothing, Symbol},Union{Nothing, Symbol}}","page":"Pipeline Algebra","title":"DataKnots.block_cardinality","text":"block_cardinality(card::Cardinality, src_lbl, tgt_lbl) :: Pipeline\n\nThis pipeline asserts the cardinality of the input block vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.block_filler","page":"Pipeline Algebra","title":"DataKnots.block_filler","text":"block_filler(block::AbstractVector, card::Cardinality) :: Pipeline\n\nThis pipeline produces a block vector filled with the given block.\n\n\n\n\n\n","category":"function"},{"location":"pipelines/#DataKnots.block_length-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.block_length","text":"block_length() :: Pipeline\n\nThis pipeline converts a block vector to a vector of block lengths.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.block_lift","page":"Pipeline Algebra","title":"DataKnots.block_lift","text":"block_lift(f) :: Pipeline\nblock_lift(f, default) :: Pipeline\n\nf is a function that expects a vector argument.\n\nThe pipeline applies f to each block of the input block vector.  When a block is empty, default (if specified) is used as the output value.\n\n\n\n\n\n","category":"function"},{"location":"pipelines/#DataKnots.block_not_empty-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.block_not_empty","text":"block_not_empty() :: Pipeline\n\nThis pipeline converts a block vector to a vector of Boolean values, where each value indicates whether the corresponding block is empty or not.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.chain_of","page":"Pipeline Algebra","title":"DataKnots.chain_of","text":"chain_of(p₁::Pipeline, p₂::Pipeline … pₙ::Pipeline) :: Pipeline\n\nThis pipeline sequentially applies p₁, p₂ … pₙ.\n\n\n\n\n\n","category":"function"},{"location":"pipelines/#DataKnots.column-Tuple{Union{Int64, Symbol}}","page":"Pipeline Algebra","title":"DataKnots.column","text":"column(lbl::Union{Int,Symbol}) :: Pipeline\n\nThis pipeline extracts the specified column of a tuple vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.designate","page":"Pipeline Algebra","title":"DataKnots.designate","text":"designate(::Pipeline, ::Signature) :: Pipeline\ndesignate(::Pipeline, ::AbstractShape, ::AbstractShape) :: Pipeline\np::Pipeline |> designate(::Signature) :: Pipeline\np::Pipeline |> designate(::AbstractShape, ::AbstractShape) :: Pipeline\n\nSets the pipeline signature.\n\n\n\n\n\n","category":"function"},{"location":"pipelines/#DataKnots.distribute-Tuple{Any}","page":"Pipeline Algebra","title":"DataKnots.distribute","text":"distribute(lbl::Union{Int,Symbol}) :: Pipeline\n\nThis pipeline transforms a tuple vector with a column of blocks to a block vector with tuple elements.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.distribute_all-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.distribute_all","text":"distribute_all() :: Pipeline\n\nThis pipeline transforms a tuple vector with block columns to a block vector with tuple elements.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.filler-Tuple{Any}","page":"Pipeline Algebra","title":"DataKnots.filler","text":"filler(val) :: Pipeline\n\nThis pipeline produces a vector filled with the given value.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.flatten-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.flatten","text":"flatten() :: Pipeline\n\nThis pipeline flattens a nested block vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.get_by-Tuple{Int64}","page":"Pipeline Algebra","title":"DataKnots.get_by","text":"get_by(N::Int) :: Pipeline\n\nThis pipeline extracts the N-th element from the given block vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.get_by-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.get_by","text":"get_by() :: Pipeline\n\nThis pipeline takes a pair vector of blocks and integers, and returns the first column indexed by the second column.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.lift-Tuple{Any}","page":"Pipeline Algebra","title":"DataKnots.lift","text":"lift(f) :: Pipeline\n\nf is any scalar unary function.\n\nThe pipeline applies f to each element of the input vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.null_filler-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.null_filler","text":"null_filler() :: Pipeline\n\nThis pipeline produces a block vector with empty blocks.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.optimize-Tuple{DataKnots.Pipeline}","page":"Pipeline Algebra","title":"DataKnots.optimize","text":"optimize(::Pipeline) :: Pipeline\n\nRewrites the pipeline to make it (hopefully) faster.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.pass-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.pass","text":"pass() :: Pipeline\n\nThis pipeline returns its input unchanged.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.sieve_by-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.sieve_by","text":"sieve_by() :: Pipeline\n\nThis pipeline filters a vector of pairs by the second column.  It expects a pair vector, whose second column is a Bool vector, and produces a block vector with 0- or 1-element blocks containing the elements of the first column.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.signature-Tuple{DataKnots.Pipeline}","page":"Pipeline Algebra","title":"DataKnots.signature","text":"signature(::Pipeline) :: Signature\n\nReturns the pipeline signature.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.slice_by","page":"Pipeline Algebra","title":"DataKnots.slice_by","text":"slice_by(inv::Bool=false) :: Pipeline\n\nThis pipeline takes a pair vector of blocks and integers, and returns the first column sliced by the second column.\n\n\n\n\n\n","category":"function"},{"location":"pipelines/#DataKnots.slice_by","page":"Pipeline Algebra","title":"DataKnots.slice_by","text":"slice_by(N::Int, inv::Bool=false) :: Pipeline\n\nThis pipeline transforms a block vector by keeping the first N elements of each block.  If inv is true, the pipeline drops the first N elements of each block.\n\n\n\n\n\n","category":"function"},{"location":"pipelines/#DataKnots.tuple_lift-Tuple{Any}","page":"Pipeline Algebra","title":"DataKnots.tuple_lift","text":"tuple_lift(f) :: Pipeline\n\nf is an n-ary function.\n\nThe pipeline applies f to each row of an n-tuple vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.tuple_of-Tuple","page":"Pipeline Algebra","title":"DataKnots.tuple_of","text":"tuple_of(p₁::Pipeline, p₂::Pipeline … pₙ::Pipeline) :: Pipeline\n\nThis pipeline produces an n-tuple vector, whose columns are generated by applying p₁, p₂ … pₙ to the input vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.with_column-Tuple{Union{Int64, Symbol},Any}","page":"Pipeline Algebra","title":"DataKnots.with_column","text":"with_column(lbl::Union{Int,Symbol}, p::Pipeline) :: Pipeline\n\nThis pipeline transforms a tuple vector by applying p to the specified column.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.with_elements-Tuple{Any}","page":"Pipeline Algebra","title":"DataKnots.with_elements","text":"with_elements(p::Pipeline) :: Pipeline\n\nThis pipeline transforms a block vector by applying p to its vector of elements.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#DataKnots.wrap-Tuple{}","page":"Pipeline Algebra","title":"DataKnots.wrap","text":"wrap() :: Pipeline\n\nThis pipeline produces a block vector with one-element blocks wrapping the values of the input vector.\n\n\n\n\n\n","category":"method"},{"location":"pipelines/#Test-Suite-1","page":"Pipeline Algebra","title":"Test Suite","text":"","category":"section"},{"location":"pipelines/#Lifting-1","page":"Pipeline Algebra","title":"Lifting","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The lift constructor makes a pipeline by vectorizing a unary function.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = lift(titlecase)\n#-> lift(titlecase)\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> [\"Garry M\", \"Anthony R\", \"Dana A\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The block_lift constructor makes a pipeline on block vectors by vectorizing a unary vector function.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_lift(length)\n#-> block_lift(length)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"]])\n#-> [3, 2]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Some vector functions may expect a non-empty vector as an argument.  In this case, we should provide the value to replace empty blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_lift(maximum, missing)\n#-> block_lift(maximum, missing)\n\np(@VectorTree [Int] [[260004, 185364, 170112], [], [202728, 197736]])\n#-> Union{Missing, Int64}[260004, missing, 202728]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The tuple_lift constructor makes a pipeline on tuple vectors by vectorizing a function of several arguments.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = tuple_lift(>)\n#-> tuple_lift(>)\n\np(@VectorTree (Int, Int) [260004 200000; 185364 200000; 170112 200000])\n#-> Bool[1, 0, 0]","category":"page"},{"location":"pipelines/#Fillers-1","page":"Pipeline Algebra","title":"Fillers","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline filler(val) ignores its input and produces a vector filled with val.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = filler(200000)\n#-> filler(200000)\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> [200000, 200000, 200000]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline block_filler(blk, card) produces a block vector filled with the given block.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_filler([\"POLICE\", \"FIRE\"], x1toN)\n#-> block_filler([\"POLICE\", \"FIRE\"], x1toN)\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> @VectorTree (1:N) × String [[\"POLICE\", \"FIRE\"], [\"POLICE\", \"FIRE\"], [\"POLICE\", \"FIRE\"]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline null_filler() produces a block vector with empty blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = null_filler()\n#-> null_filler()\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> @VectorTree (0:1) × Bottom [missing, missing, missing]","category":"page"},{"location":"pipelines/#Adapting-row-oriented-data-1","page":"Pipeline Algebra","title":"Adapting row-oriented data","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline adapt_missing() transforms a vector containing missing values to a block vector with missing replaced by an empty block and other values wrapped in 1-element block.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = adapt_missing()\n#-> adapt_missing()\n\np([260004, 185364, 170112, missing, 202728, 197736])\n#-> @VectorTree (0:1) × Int64 [260004, 185364, 170112, missing, 202728, 197736]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline adapt_vector() transforms a vector of vectors to a block vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = adapt_vector()\n#-> adapt_vector()\n\np([[260004, 185364, 170112], Int[], [202728, 197736]])\n#-> @VectorTree (0:N) × Int64 [[260004, 185364, 170112], [], [202728, 197736]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline adapt_tuple() transforms a vector of tuples to a tuple vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = adapt_tuple()\n#-> adapt_tuple()\n\np([(\"GARRY M\", 260004), (\"ANTHONY R\", 185364), (\"DANA A\", 170112)]) |> display\n#=>\n@VectorTree of 3 × (String, Int64):\n (\"GARRY M\", 260004)\n (\"ANTHONY R\", 185364)\n (\"DANA A\", 170112)\n=#","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Vectors of named tuples are also supported.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p([(name=\"GARRY M\", salary=260004), (name=\"ANTHONY R\", salary=185364), (name=\"DANA A\", salary=170112)]) |> display\n#=>\n@VectorTree of 3 × (name = String, salary = Int64):\n (name = \"GARRY M\", salary = 260004)\n (name = \"ANTHONY R\", salary = 185364)\n (name = \"DANA A\", salary = 170112)\n=#","category":"page"},{"location":"pipelines/#Composition-1","page":"Pipeline Algebra","title":"Composition","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The chain_of combinator composes a sequence of pipelines.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = chain_of(lift(split), lift(first), lift(titlecase))\n#-> chain_of(lift(split), lift(first), lift(titlecase))\n\np([\"JEFFERY A\", \"JAMES A\", \"TERRY A\"])\n#-> [\"Jeffery\", \"James\", \"Terry\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The empty chain chain_of() has an alias pass().","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = pass()\n#-> pass()\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]","category":"page"},{"location":"pipelines/#Tuple-vectors-1","page":"Pipeline Algebra","title":"Tuple vectors","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline tuple_of(p₁, p₂ … pₙ) produces a tuple vector, whose columns are generated by applying p₁, p₂ … pₙ to the input vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = tuple_of(:title => lift(titlecase), :last => lift(last))\n#-> tuple_of(:title => lift(titlecase), :last => lift(last))\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"]) |> display\n#=>\n@VectorTree of 3 × (title = String, last = Char):\n (title = \"Garry M\", last = 'M')\n (title = \"Anthony R\", last = 'R')\n (title = \"Dana A\", last = 'A')\n=#","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline column(lbl) extracts the specified column from a tuple vector.  The column constructor accepts either the column position or the column label.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = column(1)\n#-> column(1)\n\np(@VectorTree (name = String, salary = Int) [\"GARRY M\" 260004; \"ANTHONY R\" 185364; \"DANA A\" 170112])\n#-> [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]\n\np = column(:salary)\n#-> column(:salary)\n\np(@VectorTree (name = String, salary = Int) [\"GARRY M\" 260004; \"ANTHONY R\" 185364; \"DANA A\" 170112])\n#-> [260004, 185364, 170112]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The with_column combinator lets us apply the given pipeline to a selected column of a tuple vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = with_column(:name, lift(titlecase))\n#-> with_column(:name, lift(titlecase))\n\np(@VectorTree (name = String, salary = Int) [\"GARRY M\" 260004; \"ANTHONY R\" 185364; \"DANA A\" 170112]) |> display\n#=>\n@VectorTree of 3 × (name = String, salary = Int64):\n (name = \"Garry M\", salary = 260004)\n (name = \"Anthony R\", salary = 185364)\n (name = \"Dana A\", salary = 170112)\n=#","category":"page"},{"location":"pipelines/#Block-vectors-1","page":"Pipeline Algebra","title":"Block vectors","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline wrap() wraps the elements of the input vector to one-element blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = wrap()\n#-> wrap()\n\np([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n@VectorTree (1:1) × String [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline flatten() flattens a nested block vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = flatten()\n#-> flatten()\n\np(@VectorTree [[String]] [[[\"GARRY M\"], [\"ANTHONY R\", \"DANA A\"]], [missing, [\"JOSE S\"], [\"CHARLES S\"]]])\n@VectorTree (0:N) × String [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The with_elements combinator lets us apply the given pipeline to transform the elements of a block vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = with_elements(lift(titlecase))\n#-> with_elements(lift(titlecase))\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"]])\n@VectorTree (0:N) × String [[\"Garry M\", \"Anthony R\", \"Dana A\"], [\"Jose S\", \"Charles S\"]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline distribute(lbl) transforms a tuple vector with a certain block column to a block vector of tuples by distributing the block elements over the tuple.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = distribute(1)\n#-> distribute(1)\n\np(@VectorTree ([Int], [Int]) [\n    [260004, 185364, 170112]    200000\n    missing                     200000\n    [202728, 197736]            [200000, 200000]]\n) |> display\n#=>\n@VectorTree of 3 × (0:N) × (Int64, (0:N) × Int64):\n [(260004, [200000]), (185364, [200000]), (170112, [200000])]\n []\n [(202728, [200000, 200000]), (197736, [200000, 200000])]\n=#","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline distribute_all() takes a tuple vector with block columns and distribute all of the block columns.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = distribute_all()\n#-> distribute_all()\n\np(@VectorTree ([Int], [Int]) [\n    [260004, 185364, 170112]    200000\n    missing                     200000\n    [202728, 197736]            [200000, 200000]]\n) |> display\n#=>\n@VectorTree of 3 × (0:N) × (Int64, Int64):\n [(260004, 200000), (185364, 200000), (170112, 200000)]\n []\n [(202728, 200000), (202728, 200000), (197736, 200000), (197736, 200000)]\n=#","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"This pipeline is equivalent to chain_of(distribute(1), with_elements(distribute(2)), flatten()).","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline block_length() calculates the lengths of blocks in a block vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_length()\n#-> block_length()\n\np(@VectorTree [String] [missing, \"GARRY M\", [\"ANTHONY R\", \"DANA A\"]])\n#-> [0, 1, 2]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline block_not_empty() produces a vector of Boolean values indicating whether the input block is empty or not.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_not_empty()\n#-> block_not_empty()\n\np(@VectorTree [String] [missing, \"GARRY M\", [\"ANTHONY R\", \"DANA A\"]])\n#-> Bool[0, 1, 1]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline block_any() checks whether the blocks in a Bool block vector have any true values.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_any()\n#-> block_any()\n\np(@VectorTree [Bool] [missing, true, false, [true, false], [false, false], [false, true]])\n#-> Bool[0, 1, 0, 1, 0, 1]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline block_cardinality() asserts the cardinality of a block vector.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_cardinality(x1to1, :employee, :name)\n#-> block_cardinality(x1to1, :employee, :name)\n\np(@VectorTree [String] [[\"GARRY M\"], [\"ANTHONY R\"], [\"DANA A\"]])\n#-> @VectorTree (1:1) × String [\"GARRY M\", \"ANTHONY R\", \"DANA A\"]\n\np(@VectorTree [String] [[\"GARRY M\"], [\"ANTHONY R\", \"DANA A\"]])\n#-> ERROR: \"name\": expected a singular value, relative to \"employee\"\n\np(@VectorTree [String] [[\"GARRY M\"], [], [\"DANA A\"]])\n#-> ERROR: \"name\": expected a mandatory value, relative to \"employee\"","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The source and/or target labels could be omitted.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_cardinality(x1to1, :employee, nothing)\n\np(@VectorTree [String] [[]])\n#-> ERROR: expected a mandatory value, relative to \"employee\"\n\np = block_cardinality(x1to1, nothing, :name)\n\np(@VectorTree [String] [[]])\n#-> ERROR: \"name\": expected a mandatory value\n\np = block_cardinality(x1to1, nothing, nothing)\n\np(@VectorTree [String] [[]])\n#-> ERROR: expected a mandatory value","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The block_cardinality() pipeline could also be used to widen the cardinality constraint.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = block_cardinality(x0toN)\n#-> block_cardinality(x0toN)\n\np(@VectorTree [String] [[\"GARRY M\"], [\"ANTHONY R\"], [\"DANA A\"]])\n#-> @VectorTree (0:N) × String [[\"GARRY M\"], [\"ANTHONY R\"], [\"DANA A\"]]\n\np(@VectorTree (1:1)String [\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> @VectorTree (0:N) × String [[\"GARRY M\"], [\"ANTHONY R\"], [\"DANA A\"]]","category":"page"},{"location":"pipelines/#Filtering-1","page":"Pipeline Algebra","title":"Filtering","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline sieve_by() filters a vector of pairs by the second column.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = sieve_by()\n#-> sieve_by()\n\np(@VectorTree (Int, Bool) [260004 true; 185364 false; 170112 false])\n#-> @VectorTree (0:1) × Int64 [260004, missing, missing]","category":"page"},{"location":"pipelines/#Indexing-1","page":"Pipeline Algebra","title":"Indexing","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline get_by(N) transforms a block vector by extracting the N-th element of each block.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = get_by(2)\n#-> get_by(2)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"], missing])\n#-> @VectorTree (0:1) × String [\"ANTHONY R\", \"CHARLES S\", missing]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline get_by(-N) takes the N-th element from the end.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = get_by(-1)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"], missing])\n#-> @VectorTree (0:1) × String [\"DANA A\", \"CHARLES S\", missing]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"It is possible to explicitly specify the cardinality of the output.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = get_by(1, x1to1)\n#-> get_by(1, x1to1)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"]])\n#-> @VectorTree (1:1) × String [\"GARRY M\", \"JOSE S\"]\n\np = get_by(-1, x1to1)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"]])\n#-> @VectorTree (1:1) × String [\"DANA A\", \"CHARLES S\"]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"A variant of this pipeline get_by() expects a tuple vector with two columns: the first column containing the blocks and the second column with the indexes.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = get_by()\n#-> get_by()\n\np(@VectorTree ([String], Int) [([\"GARRY M\", \"ANTHONY R\", \"DANA A\"], 1), ([\"JOSE S\", \"CHARLES S\"], -1), (missing, 0)])\n#-> @VectorTree (0:1) × String [\"GARRY M\", \"CHARLES S\", missing]\n\np(@VectorTree ([String], Int) [([\"GARRY M\", \"ANTHONY R\", \"DANA A\"], 1), ([\"JOSE S\", \"CHARLES S\"], -1)])\n#-> @VectorTree (0:1) × String [\"GARRY M\", \"CHARLES S\"]","category":"page"},{"location":"pipelines/#Slicing-1","page":"Pipeline Algebra","title":"Slicing","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline slice_by(N) transforms a block vector by keeping the first N elements of each block.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = slice_by(2)\n#-> slice_by(2, false)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"], missing])\n#-> @VectorTree (0:N) × String [[\"GARRY M\", \"ANTHONY R\"], [\"JOSE S\", \"CHARLES S\"], []]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"When N is negative, slice_by(N) drops the last -N elements of each block.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = slice_by(-1)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"], missing])\n#-> @VectorTree (0:N) × String [[\"GARRY M\", \"ANTHONY R\"], [\"JOSE S\"], []]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline slice_by(N, true) drops the first N elements (or keeps the last -N elements if N is negative).","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = slice_by(2, true)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"], missing])\n#-> @VectorTree (0:N) × String [[\"DANA A\"], [], []]\n\np = slice_by(-1, true)\n\np(@VectorTree [String] [[\"GARRY M\", \"ANTHONY R\", \"DANA A\"], [\"JOSE S\", \"CHARLES S\"], missing])\n#-> @VectorTree (0:N) × String [[\"DANA A\"], [\"CHARLES S\"], []]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"A variant of this pipeline slice_by() expects a tuple vector with two columns: the first column containing the blocks and the second column with the number of elements to keep.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = slice_by()\n#-> slice_by(false)\n\np(@VectorTree ([String], Int) [([\"GARRY M\", \"ANTHONY R\", \"DANA A\"], 1), ([\"JOSE S\", \"CHARLES S\"], -1), (missing, 0)])\n#-> @VectorTree (0:N) × String [[\"GARRY M\"], [\"JOSE S\"], []]","category":"page"},{"location":"pipelines/#Grouping-1","page":"Pipeline Algebra","title":"Grouping","text":"","category":"section"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline unique_by() transforms a block vector by keeping one copy of each distinct value in each block.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = unique_by()\n#-> unique_by()\n\np(@VectorTree [String] [[\"FIRE\", \"POLICE\", \"POLICE\", \"FIRE\"], [\"FIRE\", \"OEMC\", \"OEMC\"], []])\n#-> @VectorTree (0:N) × String [[\"FIRE\", \"POLICE\"], [\"FIRE\", \"OEMC\"], []]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Compositve values are also supported.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p(@VectorTree [(0:1)String] [[\"POLICE\", \"FIRE\", missing, \"OEMC\", \"POLICE\", missing]])\n#-> @VectorTree (0:N) × ((0:1) × String) [[missing, \"FIRE\", \"OEMC\", \"POLICE\"]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The pipeline group_by() expects a block vector of pairs two columns values and keys.  The values are further partitioned into blocks by grouping the values with equal keys.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p = group_by()\n#-> group_by()\n\np(@VectorTree [(String, String)] [[(\"DANIEL A\", \"FIRE\"), (\"JEFFERY A\", \"POLICE\"), (\"JAMES A\", \"FIRE\"), (\"NANCY A\", \"POLICE\")]])\n#-> @VectorTree (0:N) × ((1:N) × String, String) [[([\"DANIEL A\", \"JAMES A\"], \"FIRE\"), ([\"JEFFERY A\", \"NANCY A\"], \"POLICE\")]]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"The keys could be assembled from tuples and blocks.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p(@VectorTree [(String, (0:1)((0:1)Int, (0:1)Int))] [[(\"JEFFERY A\", (10, missing)), (\"NANCY A\", (8, missing))], [(\"JAMES A\", (10, missing)), (\"DANIEL A\", (10, missing))], [(\"LAKENYA A\", (missing, 2)), (\"DORIS A\", (missing, 2)), (\"ASKEW A\", (6, missing)), (\"MARY Z\", missing)], []])\n#-> @VectorTree (0:N) × ((1:N) × String, (0:1) × ((0:1) × Int64, (0:1) × Int64)) [[([\"NANCY A\"], (8, missing)), ([\"JEFFERY A\"], (10, missing))], [([\"JAMES A\", \"DANIEL A\"], (10, missing))], [([\"MARY Z\"], missing), ([\"LAKENYA A\", \"DORIS A\"], (missing, 2)), ([\"ASKEW A\"], (6, missing))], []]","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"Plural blocks could also serve as keys.","category":"page"},{"location":"pipelines/#","page":"Pipeline Algebra","title":"Pipeline Algebra","text":"p(@VectorTree [(String, [String])] [[(\"ANTONIO\", [\"POLICE\", \"OEMC\"]), (\"DOLORES\", [\"FINANCE\"]), (\"MARY\", [\"FINANCE\"]), (\"CRYSTAL\", [\"POLICE\", \"OEMC\"]), (\"PIA\", [\"POLICE\"]), (\"CALVIN\", [])]])\n#-> @VectorTree (0:N) × ((1:N) × String, (0:N) × String) [[([\"CALVIN\"], []), ([\"DOLORES\", \"MARY\"], [\"FINANCE\"]), ([\"PIA\"], [\"POLICE\"]), ([\"ANTONIO\", \"CRYSTAL\"], [\"POLICE\", \"OEMC\"])]]","category":"page"},{"location":"shapes/#Shapes-and-Signatures-1","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"To describe data shapes and pipeline signatures, we need the following definitions.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"using DataKnots:\n    @VectorTree,\n    AnyShape,\n    BlockOf,\n    BlockVector,\n    IsFlow,\n    IsLabeled,\n    IsScope,\n    NoShape,\n    Signature,\n    TupleOf,\n    TupleVector,\n    ValueOf,\n    cardinality,\n    chain_of,\n    column,\n    columns,\n    compose,\n    context,\n    designate,\n    domain,\n    elements,\n    fits,\n    label,\n    labels,\n    print_graph,\n    replace_column,\n    replace_elements,\n    shapeof,\n    signature,\n    source,\n    subject,\n    target,\n    tuple_lift,\n    tuple_of,\n    wrap,\n    x0to1,\n    x0toN,\n    x1to1,\n    x1toN","category":"page"},{"location":"shapes/#Data-Shapes-1","page":"Shapes and Signatures","title":"Data Shapes","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"In DataKnots, the structure of composite data is represented using shape objects.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"For example, consider a collection of departments with associated employees.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"depts =\n    @VectorTree (name = (1:1)String,\n                 employee = (1:N)(name = (1:1)String,\n                                  position = (1:1)String,\n                                  salary = (0:1)Int64,\n                                  rate = (0:1)Float64)) [\n        (name = \"POLICE\",\n         employee = [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing),\n                     (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016, rate = missing)]),\n        (name = \"FIRE\",\n         employee = [(name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350, rate = missing),\n                     (name = \"DANIEL A\", position = \"FIRE FIGHTER-EMT\", salary = 95484, rate = missing)]),\n        (name = \"OEMC\",\n         employee = [(name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68),\n                     (name = \"DORIS A\", position = \"CROSSING GUARD\", salary = missing, rate = 19.38)])\n    ]","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"In this collection, each department record has two fields: name and employee.  Each employee record has four fields: name, position, salary, and rate.  The employee field is plural; salary and rate are optional.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Physically, this collection is stored as a tree of interleaving TupleVector and BlockVector objects with regular Vector objects as the leaves.  Its shape is described by a congruent tree composed of TupleOf, BlockOf and ValueOf objects.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"ValueOf corresponds to regular Julia Vector objects and specifies the type of the vector elements.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"ValueOf(String)\n#-> ValueOf(String)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"BlockOf specifies the shape of the elements and the cardinality of a BlockVector.  As a shorthand, a regular Julia type is accepted in place of a ValueOf shape, and the cardinality x0toN is assumed by default.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"BlockOf(ValueOf(String), x1to1)\n#-> BlockOf(String, x1to1)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"TupleOf describes a TupleVector object with the given labels and the shapes of the columns.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"emp_shp = TupleOf(:name => BlockOf(String, x1to1),\n                  :position => BlockOf(String, x1to1),\n                  :salary => BlockOf(Int, x0to1),\n                  :rate => BlockOf(Float64, x0to1))","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Using nested shape objects, we can accurately specify the structure of a nested collection.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"dept_shp = TupleOf(:name => BlockOf(String, x1to1),\n                   :employee => BlockOf(emp_shp, x1toN))\n#=>\nTupleOf(:name => BlockOf(String, x1to1),\n        :employee => BlockOf(TupleOf(\n                                 :name => BlockOf(String, x1to1),\n                                 :position => BlockOf(String, x1to1),\n                                 :salary => BlockOf(Int64, x0to1),\n                                 :rate => BlockOf(Float64, x0to1)),\n                             x1toN))\n=#","category":"page"},{"location":"shapes/#Traversing-Nested-Data-1","page":"Shapes and Signatures","title":"Traversing Nested Data","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"A field gives rise to a pipeline that maps the records to the field values.  For example, the field employee corresponds to a pipeline which maps a collection of departments to associated employees.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"dept_employee = column(:employee)\n\ndept_employee(depts) |> display\n#=>\n@VectorTree of 3 × (1:N) × (name = (1:1) × String,\n                            position = (1:1) × String,\n                            salary = (0:1) × Int64,\n                            rate = (0:1) × Float64):\n [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442, rate = missing), (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016, rate = missing)]\n [(name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350, rate = missing), (name = \"DANIEL A\", position = \"FIRE FIGHTER-EMT\", salary = 95484, rate = missing)]\n [(name = \"LAKENYA A\", position = \"CROSSING GUARD\", salary = missing, rate = 17.68), (name = \"DORIS A\", position = \"CROSSING GUARD\", salary = missing, rate = 19.38)]\n=#","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The expected input and output of a pipeline can be specified by its signature.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"dept_employee =\n    dept_employee |> designate(dept_shp, BlockOf(emp_shp, x1toN) |> IsFlow)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Here, we also annotate the output shape with IsFlow to indicate its special role in pipeline composition.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Two adjacent field pipelines may form a path.  For example, consider the rate pipeline.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"emp_rate =\n    column(:rate) |> designate(emp_shp, BlockOf(Float64, x0to1) |> IsFlow)\n\nsignature(emp_rate)\n#=>\nSignature(TupleOf(:name => BlockOf(String, x1to1),\n                  :position => BlockOf(String, x1to1),\n                  :salary => BlockOf(Int64, x0to1),\n                  :rate => BlockOf(Float64, x0to1)),\n          BlockOf(Float64, x0to1) |> IsFlow)\n=#","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"We wish to form a path through the fields employee and rate.  However, the pipelines dept_employee and emp_rate cannot be chained into chain_of(dept_employee, emp_rate) because their intermediate shapes do not match.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"fits(target(dept_employee), source(emp_rate))   #-> false","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"On the other hand, these pipelines could be composed using the elementwise composition combinator.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"dept_employee_rate = compose(dept_employee, emp_rate)\n#=>\nchain_of(column(:employee),\n         chain_of(with_elements(column(:rate)), flatten()))\n=#\n\ndept_employee_rate(depts)\n#-> @VectorTree (0:N) × Float64 [[], [], [17.68, 19.38]]\n\nsignature(dept_employee_rate)\n#=>\nSignature(TupleOf(:name => BlockOf(String, x1to1),\n                  :employee =>\n                      BlockOf(TupleOf(\n                                  :name => BlockOf(String, x1to1),\n                                  :position => BlockOf(String, x1to1),\n                                  :salary => BlockOf(Int64, x0to1),\n                                  :rate => BlockOf(Float64, x0to1)),\n                              x1toN)),\n          BlockOf(Float64) |> IsFlow)\n=#","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Elementwise composition connects the pipelines by fusing their output flows. The least upper bound of the flow cardinalities is the cardinality of the fused flow.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"dept_employee_card = cardinality(target(dept_employee))\n#-> x1toN\n\nemp_rate_card = cardinality(target(emp_rate))\n#-> x0to1\n\ndept_employee_rate_card = cardinality(target(dept_employee_rate))\n#-> x0toN\n\ndept_employee_card|emp_rate_card == dept_employee_rate_card\n#-> true","category":"page"},{"location":"shapes/#Flow-and-Scope-1","page":"Shapes and Signatures","title":"Flow and Scope","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Elementwise composition is a sequential composition with special handling of two types of containers: flow and scope.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The flow is a BlockVector that wraps the output of the pipeline.  When two pipelines are composed, their output flows are fused together.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The scope is a TupleVector that augments the input data with extra context parameters.  When pipelines are composed, the context is passed along the composition.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"For example, consider a pipeline that wraps the function round and expects the precision to be passed as a context parameter :P.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"round_digits(x, d) = round(x, digits=d)\n\nround_it =\n    chain_of(\n        tuple_of(column(1),\n                 chain_of(column(2), column(:P))),\n        tuple_lift(round_digits),\n        wrap())\n\nround_it(@VectorTree (Float64, (P = (1:1)Int,)) [(17.68, (P = 1,)), (19.38, (P = 1,))])\n#-> @VectorTree (1:1) × Float64 [17.7, 19.4]","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"To be able to use this pipeline in composition, we assign it its signature.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"round_it =\n    round_it |> designate(TupleOf(Float64, TupleOf(:P => Float64)) |> IsScope,\n                          BlockOf(Float64, x1to1) |> IsFlow)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"When two pipelines have compatible intermediate domains, they could be composed.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"domain(target(dept_employee_rate))\n#-> ValueOf(Float64)\n\ndomain(source(round_it))\n#-> ValueOf(Float64)\n\ndept_employee_round_rate = compose(dept_employee_rate, round_it)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The composition also has a signature assigned to it.  The input of the composition should contain the department data together with a parameter P.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"signature(dept_employee_round_rate)\n#=>\nSignature(TupleOf(TupleOf(\n                      :name => BlockOf(String, x1to1),\n                      :employee =>\n                          BlockOf(\n                              TupleOf(\n                                  :name => BlockOf(String, x1to1),\n                                  :position => BlockOf(String, x1to1),\n                                  :salary => BlockOf(Int64, x0to1),\n                                  :rate => BlockOf(Float64, x0to1)),\n                              x1toN)),\n                  TupleOf(:P => Float64)) |>\n          IsScope,\n          BlockOf(Float64) |> IsFlow)\n=#","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"To run this pipeline, we pack the input data together with parameters.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"slots = @VectorTree (P = Int,) [(P = 1,), (P = 1,), (P = 1,)]\n\ninput = TupleVector(:depts => depts, :slots => slots)\n\ndept_employee_round_rate(input)\n#-> @VectorTree (0:N) × Float64 [[], [], [17.7, 19.4]]","category":"page"},{"location":"shapes/#API-Reference-1","page":"Shapes and Signatures","title":"API Reference","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Modules = [DataKnots]\nPages = [\"shapes.jl\"]\nPublic = false","category":"page"},{"location":"shapes/#DataKnots.AbstractShape","page":"Shapes and Signatures","title":"DataKnots.AbstractShape","text":"AbstractShape\n\nDescribes the structure of column-oriented data.\n\n\n\n\n\n","category":"type"},{"location":"shapes/#DataKnots.AnyShape","page":"Shapes and Signatures","title":"DataKnots.AnyShape","text":"AnyShape()\n\nNothing is known about the data.\n\n\n\n\n\n","category":"type"},{"location":"shapes/#DataKnots.BlockOf","page":"Shapes and Signatures","title":"DataKnots.BlockOf","text":"BlockOf(elts::AbstractShape, card::Cardinality=x0toN)\n\nShape of a BlockVector.\n\n\n\n\n\n","category":"type"},{"location":"shapes/#DataKnots.IsLabeled","page":"Shapes and Signatures","title":"DataKnots.IsLabeled","text":"sub |> IsLabeled(::Symbol)\n\nThe shape has an attached label.\n\n\n\n\n\n","category":"type"},{"location":"shapes/#DataKnots.NoShape","page":"Shapes and Signatures","title":"DataKnots.NoShape","text":"NoShape()\n\nInconsistent constraints on the data.\n\n\n\n\n\n","category":"type"},{"location":"shapes/#DataKnots.Signature","page":"Shapes and Signatures","title":"DataKnots.Signature","text":"Signature(::AbstractShape, ::AbstractShape)\n\nShapes of a pipeline source and tagret.\n\n\n\n\n\n","category":"type"},{"location":"shapes/#DataKnots.fits","page":"Shapes and Signatures","title":"DataKnots.fits","text":"fits(x::T, y::T) :: Bool\n\nChecks if constraint x implies constraint y.\n\n\n\n\n\n","category":"function"},{"location":"shapes/#Test-Suite-1","page":"Shapes and Signatures","title":"Test Suite","text":"","category":"section"},{"location":"shapes/#Cardinality-1","page":"Shapes and Signatures","title":"Cardinality","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Cardinality constraints are partially ordered.  For two Cardinality constraints, we can determine whether one is more strict than the other.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"fits(x0to1, x1toN)          #-> false\nfits(x1to1, x0toN)          #-> true","category":"page"},{"location":"shapes/#Data-shapes-1","page":"Shapes and Signatures","title":"Data shapes","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The structure of composite data is specified with shape objects.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"A regular vector containing values of a specific type is indicated by the ValueOf shape.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"str_shp = ValueOf(String)\n#-> ValueOf(String)\n\neltype(str_shp)\n#-> String","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The structure of a BlockVector object is described using BlockOf shape.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"rate_shp = BlockOf(Float64, x0to1)\n#-> BlockOf(Float64, x0to1)\n\ncardinality(rate_shp)\n#-> x0to1\n\nelements(rate_shp)\n#-> ValueOf(Float64)\n\neltype(rate_shp)\n#-> Union{Missing, Float64}","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"For a TupleVector, the column shapes and their labels are described with TupleOf.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"emp_shp = TupleOf(:name => BlockOf(String, x1to1),\n                  :position => BlockOf(String, x1to1),\n                  :salary => BlockOf(Int, x0to1),\n                  :rate => BlockOf(Float64, x0to1))\n#=>\nTupleOf(:name => BlockOf(String, x1to1),\n        :position => BlockOf(String, x1to1),\n        :salary => BlockOf(Int64, x0to1),\n        :rate => BlockOf(Float64, x0to1))\n=#\n\nlabels(emp_shp)\n#-> Symbol[:name, :position, :salary, :rate]\n\nlabel(emp_shp, 4)\n#-> :rate\n\ncolumns(emp_shp)\n#-> DataKnots.AbstractShape[BlockOf(String, x1to1), BlockOf(String, x1to1), BlockOf(Int64, x0to1), BlockOf(Float64, x0to1)]\n\ncolumn(emp_shp, :rate)\n#-> BlockOf(Float64, x0to1)\n\ncolumn(emp_shp, 4)\n#-> BlockOf(Float64, x0to1)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"It is possible to specify the shape of a TupleVector without labels.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"cmp_shp = TupleOf(BlockOf(Int, x0to1), BlockOf(Int, x1to1))\n#-> TupleOf(BlockOf(Int64, x0to1), BlockOf(Int64, x1to1))","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"In this case, the columns will be assigned ordinal labels.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"label(cmp_shp, 1)   #-> Symbol(\"#A\")\nlabel(cmp_shp, 2)   #-> Symbol(\"#B\")","category":"page"},{"location":"shapes/#Annotations-1","page":"Shapes and Signatures","title":"Annotations","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Any shape can be assigned a label using IsLabeled annotation.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"lbl_shp = BlockOf(String, x1to1) |> IsLabeled(:name)\n\nsubject(lbl_shp)\n#-> BlockOf(String, x1to1)\n\nlabel(lbl_shp)\n#-> :name","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"A BlockOf shape is annotated with IsFlow to indicate that the container holds the output flow of a pipeline.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"flw_shp = BlockOf(String, x1to1) |> IsFlow\n\nsubject(flw_shp)\n#-> BlockOf(String, x1to1)","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"The shape of the flow elements could be easily accessed or replaced.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"elements(flw_shp)\n#-> ValueOf(String)\n\nreplace_elements(flw_shp, ValueOf(Int))\n#-> BlockOf(Int64, x1to1) |> IsFlow","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"A TupleOf shape is annotated with IsScope to indicate that the container holds the scoping context of a pipeline.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"scp_shp = TupleOf(Float64, TupleOf(:P => Int)) |> IsScope\n\nsubject(scp_shp)\n#-> TupleOf(Float64, TupleOf(:P => Int64))","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"We can get the shapes of the input data and the context parameters.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"context(scp_shp)\n#-> TupleOf(:P => Int64)\n\ncolumn(scp_shp)\n#-> ValueOf(Float64)\n\nreplace_column(scp_shp, ValueOf(Int))\n#-> TupleOf(Int64, TupleOf(:P => Int64)) |> IsScope","category":"page"},{"location":"shapes/#Shape-ordering-1","page":"Shapes and Signatures","title":"Shape ordering","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"A single vector instance may satisfy many different shape constraints.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"bv = BlockVector(:, [\"Chicago\"])\n\nfits(bv, BlockOf(String, x1to1))        #-> true\nfits(bv, BlockOf(AbstractString))       #-> true\nfits(bv, AnyShape())                    #-> true","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"We can tell, for any two shape constraints, if one of them is more specific than the other.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"fits(ValueOf(Int), ValueOf(Number))     #-> true\nfits(ValueOf(Int), ValueOf(String))     #-> false\n\nfits(BlockOf(Int, x1to1),\n     BlockOf(Number, x0to1))            #-> true\nfits(BlockOf(Int, x1toN),\n     BlockOf(Number, x0to1))            #-> false\nfits(BlockOf(Int, x1to1),\n     BlockOf(String, x0to1))            #-> false\n\nfits(TupleOf(BlockOf(Int, x1to1),\n             BlockOf(String, x0to1)),\n     TupleOf(BlockOf(Number, x1to1),\n             BlockOf(String, x0toN)))   #-> true\nfits(TupleOf(BlockOf(Int, x0to1),\n             BlockOf(String, x1to1)),\n     TupleOf(BlockOf(Number, x1to1),\n             BlockOf(String, x0toN)))   #-> false\nfits(TupleOf(BlockOf(Int, x1to1)),\n     TupleOf(BlockOf(Number, x1to1),\n             BlockOf(String, x0toN)))   #-> false","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Shapes of different kinds are typically not compatible with each other.  The exceptions are AnyShape() and NoShape().","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"fits(ValueOf(Int), BlockOf(Int))        #-> false\nfits(ValueOf(Int), AnyShape())          #-> true\nfits(NoShape(), ValueOf(Int))           #-> true","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Column labels are treated as additional shape constraints.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"fits(TupleOf(:name => String),\n     TupleOf(:name => String))          #-> true\nfits(TupleOf(String),\n     TupleOf(:position => String))      #-> false\nfits(TupleOf(:name => String),\n     TupleOf(String))                   #-> true\nfits(TupleOf(:name => String),\n     TupleOf(:position => String))      #-> false","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Similarly, annotations are treated as shape constraints.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"fits(String |> IsLabeled(:name),\n     String |> IsLabeled(:name))        #-> true\nfits(ValueOf(String),\n     String |> IsLabeled(:position))    #-> false\nfits(String |> IsLabeled(:name),\n     ValueOf(String))                   #-> true\nfits(String |> IsLabeled(:name),\n     String |> IsLabeled(:position))    #-> false\n\nfits(BlockOf(String, x1to1) |> IsFlow,\n     BlockOf(String, x0toN) |> IsFlow)  #-> true\nfits(BlockOf(String, x1to1),\n     BlockOf(String, x0toN) |> IsFlow)  #-> false\nfits(BlockOf(String, x1to1) |> IsFlow,\n     BlockOf(String, x0toN))            #-> true\n\nfits(TupleOf(Int, TupleOf(:X => Int))\n     |> IsScope,\n     TupleOf(Int, TupleOf(:X => Int))\n     |> IsScope)                        #-> true\nfits(TupleOf(Int, TupleOf(:X => Int)),\n     TupleOf(Int, TupleOf(:X => Int))\n     |> IsScope)                        #-> false\nfits(TupleOf(Int, TupleOf(:X => Int))\n     |> IsScope,\n     TupleOf(Int, TupleOf(:X => Int)))  #-> true","category":"page"},{"location":"shapes/#Shape-of-a-vector-1","page":"Shapes and Signatures","title":"Shape of a vector","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Function shapeof() determines the shape of a given vector.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"shapeof([\"GARRY M\", \"ANTHONY R\", \"DANA A\"])\n#-> ValueOf(String)\n\nshapeof(@VectorTree ((1:1)String, (0:1)Int) [])\n#-> TupleOf(BlockOf(String, x1to1), BlockOf(Int64, x0to1))\n\nshapeof(@VectorTree (name = String, employee = [String]) [])\n#-> TupleOf(:name => String, :employee => BlockOf(String))","category":"page"},{"location":"shapes/#Pipeline-signature-1","page":"Shapes and Signatures","title":"Pipeline signature","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"A Signature object describes the shapes of a pipeline's input and output.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"sig = Signature(ValueOf(UInt),\n                BlockOf(TupleOf(:name => BlockOf(String, x1to1),\n                                :employee => BlockOf(UInt, x0toN))) |> IsFlow)\n#=>\nSignature(ValueOf(UInt64),\n          BlockOf(TupleOf(:name => BlockOf(String, x1to1),\n                          :employee => BlockOf(UInt64))) |>\n          IsFlow)\n=#","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Components of the signature can be easily extracted.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"target(sig)\n#=>\nBlockOf(TupleOf(:name => BlockOf(String, x1to1),\n                :employee => BlockOf(UInt64))) |>\nIsFlow\n=#\n\nsource(sig)\n#-> ValueOf(UInt64)","category":"page"},{"location":"shapes/#Rendering-as-a-graph-1","page":"Shapes and Signatures","title":"Rendering as a graph","text":"","category":"section"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"Function print_graph() visualizes a shape constraint as a tree.","category":"page"},{"location":"shapes/#","page":"Shapes and Signatures","title":"Shapes and Signatures","text":"print_graph(ValueOf(String))\n#-> #  String\n\nprint_graph(BlockOf(String, x1to1))\n#-> #  1:1 × String\n\nprint_graph(BlockOf(String, x1to1) |> IsLabeled(:name))\n#-> name  1:1 × String\n\nprint_graph(\n    TupleOf(\n        :name => String,\n        :position => String,\n        :salary => Int) |> IsLabeled(:employee))\n#=>\nemployee\n├╴name      String\n├╴position  String\n└╴salary    Int64\n=#\n\nprint_graph(\n    BlockOf(\n        TupleOf(\n            TupleOf(\n                :name => BlockOf(String, x1to1),\n                :position => BlockOf(String, x1to1),\n                :salary => BlockOf(Int, x0to1),\n                :rate => BlockOf(Float64, x0to1)) |> IsLabeled(:employee),\n            TupleOf(:mean_salary => BlockOf(Float64, x0to1))) |> IsScope,\n        x0toN) |> IsFlow)\n#=>\n#                0:N\n├╴employee\n│ ├╴name         1:1 × String\n│ ├╴position     1:1 × String\n│ ├╴salary       0:1 × Int64\n│ └╴rate         0:1 × Float64\n└╴#B\n  └╴mean_salary  0:1 × Float64\n=#","category":"page"},{"location":"knots/#Data-Knots-1","page":"Data Knots","title":"Data Knots","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"A DataKnot object contains a single data value serialized in a column-oriented form.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"using DataKnots:\n    @VectorTree,\n    DataKnot,\n    Lift,\n    It,\n    Record,\n    ValueOf,\n    cell,\n    fromtable,\n    shape,\n    unitknot","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"To integrate with other tabular systems, we need the following:","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"using Tables\nusing CSV\nusing DataFrames","category":"page"},{"location":"knots/#Overview-1","page":"Data Knots","title":"Overview","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Any Julia value can be converted to a DataKnot.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"hello = convert(DataKnot, \"Hello World!\")\n#=>\n┼──────────────┼\n│ Hello World! │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"To obtain a Julia value from a DataKnot object, we use the get() function.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"get(hello)\n#-> \"Hello World!\"","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"To preserve the column-oriented structure of the data, DataKnot keeps the value in a one-element vector.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"cell(hello)\n#-> [\"Hello World!\"]","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"DataKnot also stores the shape of the data.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"shape(hello)\n#-> ValueOf(String)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"We use indexing notation to apply a Query to a DataKnot.  The output of a query is also a DataKnot object.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"hello[length.(It)]\n#=>\n┼────┼\n│ 12 │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"To place several datasets into a single DataKnot we use a special constructor that takes datasets with their names.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"sets = DataKnot(:main=>'a':'c', :more=>\"data\")\n#=>\n│ main     more │\n┼───────────────┼\n│ a; b; c  data │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"A specific dataset could be focused by navigating.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"sets[It.main]\n#=>\n  │ main │\n──┼──────┼\n1 │ a    │\n2 │ b    │\n3 │ c    │\n=#","category":"page"},{"location":"knots/#Importing-and-Exporting-1","page":"Data Knots","title":"Importing & Exporting","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"We support the conversion to/from objects with the Tables.jl interface. For example, we could import CSV data.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"chicago_file = \"\"\"\nname,department,position,salary,rate\n\"JEFFERY A\",\"POLICE\",\"SERGEANT\",101442,\n\"NANCY A\",\"POLICE\",\"POLICE OFFICER\",80016,\n\"JAMES A\",\"FIRE\",\"FIRE ENGINEER-EMT\",103350,\n\"DANIEL A\",\"FIRE\",\"FIRE FIGHTER-EMT\",95484,\n\"LAKENYA A\",\"OEMC\",\"CROSSING GUARD\",,17.68\n\"DORIS A\",\"OEMC\",\"CROSSING GUARD\",,19.38\n\"\"\" |> IOBuffer |> CSV.File\n\nchicago = DataKnot(:employee => chicago_file)\n\nchicago[It.employee]\n#=>\n  │ employee                                                │\n  │ name       department  position           salary  rate  │\n──┼─────────────────────────────────────────────────────────┼\n1 │ JEFFERY A  POLICE      SERGEANT           101442        │\n2 │ NANCY A    POLICE      POLICE OFFICER      80016        │\n3 │ JAMES A    FIRE        FIRE ENGINEER-EMT  103350        │\n4 │ DANIEL A   FIRE        FIRE FIGHTER-EMT    95484        │\n5 │ LAKENYA A  OEMC        CROSSING GUARD             17.68 │\n6 │ DORIS A    OEMC        CROSSING GUARD             19.38 │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"This knot could then be queried and exported to a DataFrame.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"chicago[It.employee >>\n        Record(It.name, It.department, It.salary)\n       ] |> DataFrame\n#=>\n6×3 DataFrames.DataFrame\n│ Row │ name      │ department │ salary  │\n│     │ String    │ String     │ Int64⍰  │\n├─────┼───────────┼────────────┼─────────┤\n│ 1   │ JEFFERY A │ POLICE     │ 101442  │\n│ 2   │ NANCY A   │ POLICE     │ 80016   │\n│ 3   │ JAMES A   │ FIRE       │ 103350  │\n│ 4   │ DANIEL A  │ FIRE       │ 95484   │\n│ 5   │ LAKENYA A │ OEMC       │ missing │\n│ 6   │ DORIS A   │ OEMC       │ missing │\n=#","category":"page"},{"location":"knots/#API-Reference-1","page":"Data Knots","title":"API Reference","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Modules = [DataKnots]\nPages = [\"knots.jl\"]\nPublic = false","category":"page"},{"location":"knots/#Base.show-Tuple{DataKnot}","page":"Data Knots","title":"Base.show","text":"show(::DataKnot[; as=:table])\n\nThis displays a DataKnot as a table, truncating the data to fit the current display.\n\njulia> using DataKnots\n\njulia> show(unitknot[Lift(1:3) >> Record(:x => It, :y => It .* It)])\n  │ x  y │\n──┼──────┼\n1 │ 1  1 │\n2 │ 2  4 │\n3 │ 3  9 │\n\nshow(::DataKnot; as=:shape)\n\nThis visualizes the shape of a DataKnot in a form of a tree.\n\njulia> using DataKnots\n\njulia> show(as=:shape, unitknot[Lift(1:3) >> Record(:x => It, :y => It .* It)])\n3-element DataKnot:\n  #    0:N\n  ├╴x  1:1 × Int64\n  └╴y  1:1 × Int64\n\n\n\n\n\n","category":"method"},{"location":"knots/#Test-Suite-1","page":"Data Knots","title":"Test Suite","text":"","category":"section"},{"location":"knots/#Constructors-1","page":"Data Knots","title":"Constructors","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"A DataKnot object is created from a one-element cell vector and its shape.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"hello = DataKnot(ValueOf(String), [\"Hello World\"])\n#=>\n┼─────────────┼\n│ Hello World │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"It is an error if the cell length is different from 1.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"DataKnot(ValueOf(String), String[])\n#-> ERROR: AssertionError: length(cell) == 1","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"The cell and its shape can be retrieved.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"cell(hello)\n#-> [\"Hello World\"]\n\nshape(hello)\n#-> ValueOf(String)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"The shape could be specified by the element type.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"hello = DataKnot(String, [\"Hello World\"])\n\nshape(hello)\n#-> ValueOf(String)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"The shape could also be introspected from the given cell.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"hello = DataKnot(Any, [\"Hello World\"])\n\nshape(hello)\n#-> ValueOf(String)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"To make a DataKnot with a block cell, we can provide the block elements and its cardinality.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"abc = DataKnot(Any, 'a':'c', :x1toN)\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#\n\ncell(abc)\n#-> @VectorTree (1:N) × Char ['a':'\\x01':'c']\n\nshape(abc)\n#-> BlockOf(Char, x1toN)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"The default constructor creates the unit DataKnot, which holds an empty tuple.  This knot is exported under the name unitknot.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"unitknot\n#=>\n┼──┼\n│  │\n=#\n\ncell(unitknot)\n#-> @VectorTree (1:1) × () [()]","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"We can also construct a DataKnot containing a single top-level named tuple with the given fields.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"recknot = DataKnot(:hello => \"Hello World!\", :main => 'a':'c')\n#=>\n│ hello         main    │\n┼───────────────────────┼\n│ Hello World!  a; b; c │\n=#\n\ncell(recknot)\n#-> @VectorTree (1:1) × (hello = String, main = (0:N) × Char) [(hello = \"Hello World!\", main = 'a':'\\x01':'c')]","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Any Julia value can be converted to a DataKnot object using the convert() function.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"hello = convert(DataKnot, \"Hello World!\")\n#=>\n┼──────────────┼\n│ Hello World! │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Scalar values are stored as is.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"shape(hello)\n#-> ValueOf(String)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"The value missing is converted to an empty DataKnot.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"nullknot = convert(DataKnot, missing)\n#=>\n(empty)\n=#\n\nshape(nullknot)\n#-> BlockOf(NoShape(), x0to1)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"A vector value is converted to a block.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"vecknot = convert(DataKnot, 'a':'c')\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#\n\nshape(vecknot)\n#-> BlockOf(Char)","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"A Ref object is converted into the referenced value.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"int_ty = convert(DataKnot, Base.broadcastable(Int))\n#=>\n┼───────┼\n│ Int64 │\n=#\n\nshape(int_ty)\n#-> ValueOf(Type{Int64})","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Tables.jl interface is used for conversion when it is supported by the given value.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"convert(DataKnot, DataFrame(:name => [\"JEFFERY A\", \"NANCY A\"],\n                            :position => [\"SERGEANT\", \"POLICE OFFICER\"],\n                            :salary => [101442, 80016]))\n#=>\n  │ name       position        salary │\n──┼───────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT        101442 │\n2 │ NANCY A    POLICE OFFICER   80016 │\n=#","category":"page"},{"location":"knots/#Rendering-1","page":"Data Knots","title":"Rendering","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"On output, a DataKnot object is rendered as a table.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"emp = convert(DataKnot,\n              [(name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442),\n               (name = \"NANCY A\", position = \"POLICE OFFICER\", salary = 80016),\n               (name = \"JAMES A\", position = \"FIRE ENGINEER-EMT\", salary = 103350),\n               (name = \"DANIEL A\", position = \"FIRE FIGHTER-EMT\", salary = 95484)])\n#=>\n  │ name       position           salary │\n──┼──────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT           101442 │\n2 │ NANCY A    POLICE OFFICER      80016 │\n3 │ JAMES A    FIRE ENGINEER-EMT  103350 │\n4 │ DANIEL A   FIRE FIGHTER-EMT    95484 │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"If the table columns do not fit the output screen, some table cells could be truncated.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"small = IOContext(stdout, :displaysize => (24, 35))\n\nshow(small, emp)\n#=>\n  │ name       position   salary │\n──┼──────────────────────────────┼\n1 │ JEFFERY A  SERGEANT   101442 │\n2 │ NANCY A    POLICE OF…  80016 │\n3 │ JAMES A    FIRE ENGI… 103350 │\n4 │ DANIEL A   FIRE FIGH…  95484 │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"If the screen is too small, the whole table needs to be truncated.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"tiny = IOContext(stdout, :displaysize => (6, 20))\n\nshow(tiny, emp)\n#=>\n  │ name      posit…\n──┼────────────────…\n1 │ JEFFERY … SERGE…\n⋮\n4 │ DANIEL A  FIRE …\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Top-level tuples are serialized as table columns while nested tuples are rendered as comma-separated lists of tuple elements.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"convert(DataKnot, (\"FIRE\", [(\"JEFFERY A\", (101442, missing)), (\"NANCY A\", (80016, missing))]))\n#=>\n│ #A    #B{#A,#B{#A,#B}}                                        │\n┼───────────────────────────────────────────────────────────────┼\n│ FIRE  JEFFERY A, (101442, missing); NANCY A, (80016, missing) │\n=#\n\nconvert(DataKnot, (name = \"FIRE\", employee = [(name = \"JEFFERY A\", compensation = (salary = 101442, rate = missing)),\n                                              (name = \"NANCY A\", compensation = (salary = 80016, rate = missing))]))\n#=>\n│ name  employee{name,compensation{salary,rate}}                │\n┼───────────────────────────────────────────────────────────────┼\n│ FIRE  JEFFERY A, (101442, missing); NANCY A, (80016, missing) │\n=#\n\nDataKnot(\n    Any,\n    @VectorTree((name = (1:1)String,\n                 employee = [(name = (1:1)String,\n                              compensation = (1:1)(salary = (0:1)Int,\n                                                   rate = (0:1)Float64))]), [\n        (name = \"FIRE\", employee = [(name = \"JEFFERY A\", compensation = (salary = 101442, rate = missing)),\n                                    (name = \"NANCY A\", compensation = (salary = 80016, rate = missing))])]),)\n#=>\n│ name  employee{name,compensation{salary,rate}}                │\n┼───────────────────────────────────────────────────────────────┼\n│ FIRE  JEFFERY A, (101442, missing); NANCY A, (80016, missing) │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Similarly, top-level vectors are represented as table rows while nested vectors are rendered as semicolon-separated lists.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"convert(DataKnot, [[\"JEFFERY A\", \"NANCY A\"], [\"JAMES A\", \"DANIEL A\"]])\n#=>\n──┼────────────────────┼\n1 │ JEFFERY A; NANCY A │\n2 │ JAMES A; DANIEL A  │\n=#\n\nconvert(DataKnot, @VectorTree [String] [[\"JEFFERY A\", \"NANCY A\"], [\"JAMES A\", \"DANIEL A\"]])\n#=>\n──┼────────────────────┼\n1 │ JEFFERY A; NANCY A │\n2 │ JAMES A; DANIEL A  │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"Integer numbers are right-aligned while decimal numbers are centered around the decimal point.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"convert(DataKnot, [true, false])\n#=>\n──┼───────┼\n1 │  true │\n2 │ false │\n=#\n\nconvert(DataKnot, [101442, 80016])\n#=>\n──┼────────┼\n1 │ 101442 │\n2 │  80016 │\n=#\n\nconvert(DataKnot, [35.6, 2.65])\n#=>\n──┼───────┼\n1 │ 35.6  │\n2 │  2.65 │\n=#","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"DataKnot objects provide alternative output modes.  For example, we can visualize the shape of a DataKnot as a tree.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"show(chicago, as=:shape)\n#=>\n1-element DataKnot:\n  #               1:1\n  └╴employee      0:N\n    ├╴name        String\n    ├╴department  String\n    ├╴position    String\n    ├╴salary      Union{Missing, Int64}\n    └╴rate        Union{Missing, Float64}\n=#","category":"page"},{"location":"knots/#Exporting-via-Table.jl-Interface-1","page":"Data Knots","title":"Exporting via Table.jl Interface","text":"","category":"section"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"When a knot has a tabular form, it can be exported via Tables.jl.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"This is the case when a DataKnot wraps a vector of named tuples.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"table = convert(DataKnot, [(x=\"A\", y=1.0), (x=\"B\", y=2.0)])\n\nTables.istable(table)\n#-> true\n\nTables.columnaccess(table)\n#-> true\n\ncols = Tables.columns(table)\n\ncols.x\n#-> [\"A\", \"B\"]\n\ncols.y\n#-> [1.0, 2.0]","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"A plural set of records will also be treated as a table.","category":"page"},{"location":"knots/#","page":"Data Knots","title":"Data Knots","text":"table = unitknot[Lift(1:3) >> Record(:idx => It, :val => \"Test\")]\n\nTables.istable(table)\n#-> true\n\nTables.columnaccess(table)\n#-> true\n\ncols = Tables.columns(table)\n\ncols.idx\n#-> [1, 2, 3]\n\ncols.val\n#-> [\"Test\", \"Test\", \"Test\"]","category":"page"},{"location":"queries/#Query-Algebra-1","page":"Query Algebra","title":"Query Algebra","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In this section, we sketch the design and implementation of the query algebra. We will need the following definitions.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"using DataKnots:\n    @VectorTree,\n    @query,\n    Collect,\n    Count,\n    DataKnot,\n    Drop,\n    Each,\n    Environment,\n    Exists,\n    Filter,\n    First,\n    Get,\n    Given,\n    Group,\n    Is0to1,\n    Is0toN,\n    Is1to1,\n    Is1toN,\n    It,\n    Join,\n    Keep,\n    Label,\n    Last,\n    Let,\n    Lift,\n    Max,\n    Min,\n    Mix,\n    Nth,\n    Record,\n    Sum,\n    Tag,\n    Take,\n    Unique,\n    assemble,\n    elements,\n    optimize,\n    shape,\n    trivial_pipe,\n    target_pipe,\n    uncover","category":"page"},{"location":"queries/#Example-Dataset-1","page":"Query Algebra","title":"Example Dataset","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"As a running example, we will use the following dataset of city departments with associated employees.  This dataset is serialized as a nested structure with a singleton root record, which holds all department records, each of which holds associated employee records.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago_data =\n    @VectorTree (department = [(name     = (1:1)String,\n                                employee = [(name     = (1:1)String,\n                                             position = (1:1)String,\n                                             salary   = (0:1)Int,\n                                             rate     = (0:1)Float64)])],) [\n        (department = [\n            (name     = \"POLICE\",\n             employee = [\"JEFFERY A\"    \"SERGEANT\"              101442      missing\n                         \"NANCY A\"      \"POLICE OFFICER\"        80016       missing\n                         \"ANTHONY A\"    \"POLICE OFFICER\"        72510       missing\n                         \"ALBA M\"       \"POLICE CADET\"          missing     9.46]),\n            (name     = \"FIRE\",\n             employee = [\"JAMES A\"      \"FIRE ENGINEER-EMT\"     103350      missing\n                         \"DANIEL A\"     \"FIREFIGHTER-EMT\"       95484       missing\n                         \"ROBERT K\"     \"FIREFIGHTER-EMT\"       103272      missing]),\n            (name     = \"OEMC\",\n             employee = [\"LAKENYA A\"    \"CROSSING GUARD\"        missing     17.68\n                         \"DORIS A\"      \"CROSSING GUARD\"        missing     19.38\n                         \"BRENDA B\"     \"TRAFFIC CONTROL AIDE\"  64392       missing])],\n        )\n    ]\n\nchicago = DataKnot(Any, chicago_data, :x1to1)\n#=>\n│ department{name,employee{name,position,salary,rate}}                │\n┼─────────────────────────────────────────────────────────────────────┼\n│ POLICE, [JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLICE OFFI…│\n=#","category":"page"},{"location":"queries/#Constructing-Queries-1","page":"Query Algebra","title":"Constructing Queries","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In DataKnots, we query data by assembling and running Query objects.  Queries are constructed algebraically: they either come a set of atomic primitive queries, or are built from other queries using query combinators.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"For example, consider the query:","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Employees = Get(:department) >> Get(:employee)\n#-> Get(:department) >> Get(:employee)","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"This query traverses the dataset through fields department and employee. It is constructed from two primitive queries Get(:department) and Get(:employee) connected using the query composition combinator >>.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Since attribute traversal is so common, DataKnots provides a shorthand notation.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Employees = It.department.employee\n#-> It.department.employee","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To apply a query to a DataKnot, we use indexing notation.  The output of a query is also a DataKnot.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[Employees]\n#=>\n   │ employee                                       │\n   │ name       position              salary  rate  │\n───┼────────────────────────────────────────────────┼\n 1 │ JEFFERY A  SERGEANT              101442        │\n 2 │ NANCY A    POLICE OFFICER         80016        │\n 3 │ ANTHONY A  POLICE OFFICER         72510        │\n 4 │ ALBA M     POLICE CADET                   9.46 │\n 5 │ JAMES A    FIRE ENGINEER-EMT     103350        │\n 6 │ DANIEL A   FIREFIGHTER-EMT        95484        │\n 7 │ ROBERT K   FIREFIGHTER-EMT       103272        │\n 8 │ LAKENYA A  CROSSING GUARD                17.68 │\n 9 │ DORIS A    CROSSING GUARD                19.38 │\n10 │ BRENDA B   TRAFFIC CONTROL AIDE   64392        │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Regular Julia values and functions could be used to create query components. Specifically, any Julia value could be converted to a query primitive, and any Julia function could be converted to a query combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"For example, let us find find employees whose salary is greater than $100k. For this purpose, we need to construct a predicate query that compares the salary field with a specific number.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If we were constructing an ordinary predicate function, we would write:","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"salary_over_100k(emp) = emp.salary > 100000","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"An equivalent query is constructed as follows:","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"SalaryOver100K = Lift(>, (Get(:salary), Lift(100000)))\n#-> Lift(>, (Get(:salary), Lift(100000)))","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"This query expression is constructed from two primitive components: Get(:salary) and Lift(100000), which serve as parameters of the Lift(>) combinator.  Here, Lift is used twice.  Lift applied to a regular Julia value converts it to a constant query primitive while Lift applied to a function lifts it to a query combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"As a shorthand notation for lifting functions and operators, DataKnots supports broadcasting syntax:","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"SalaryOver100K = It.salary .> 100000\n#-> It.salary .> 100000","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To test this query, we can append it to the Employees query using the composition combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[Employees >> SalaryOver100K]\n#=>\n──┼───────┼\n1 │  true │\n2 │ false │\n3 │ false │\n4 │  true │\n5 │ false │\n6 │  true │\n7 │ false │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"However, this only gives us a list of bare Boolean values disconnected from the respective employees.  To contextualize this output, we can use the Record combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[Employees >> Record(It.name,\n                            It.salary,\n                            :salary_over_100k => SalaryOver100K)]\n#=>\n   │ employee                            │\n   │ name       salary  salary_over_100k │\n───┼─────────────────────────────────────┼\n 1 │ JEFFERY A  101442              true │\n 2 │ NANCY A     80016             false │\n 3 │ ANTHONY A   72510             false │\n 4 │ ALBA M                              │\n 5 │ JAMES A    103350              true │\n 6 │ DANIEL A    95484             false │\n 7 │ ROBERT K   103272              true │\n 8 │ LAKENYA A                           │\n 9 │ DORIS A                             │\n10 │ BRENDA B    64392             false │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To actually filter the data using this predicate query, we need to use the Filter combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"EmployeesWithSalaryOver100K = Employees >> Filter(SalaryOver100K)\n#-> It.department.employee >> Filter(It.salary .> 100000)\n\nchicago[EmployeesWithSalaryOver100K]\n#=>\n  │ employee                                   │\n  │ name       position           salary  rate │\n──┼────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT           101442       │\n2 │ JAMES A    FIRE ENGINEER-EMT  103350       │\n3 │ ROBERT K   FIREFIGHTER-EMT    103272       │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"DataKnots provides a number of useful query constructors.  For example, to find the number of items produced by a query, we can use the Count combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[Count(EmployeesWithSalaryOver100K)]\n#=>\n┼───┼\n│ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In general, query algebra forms an XPath-like domain-specific language.  It is designed to let the user construct queries incrementally, with each step being individually crafted and tested.  It also encourages the user to create reusable query components and remix them in creative ways.","category":"page"},{"location":"queries/#Compiling-Queries-1","page":"Query Algebra","title":"Compiling Queries","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In DataKnots, applying a query to the input data is a two-phase process. First, the query generates a pipeline.  Second, this pipeline transforms the input data to the output data.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Let us elaborate on the role of pipelines and queries.  In DataKnots, just like pipelines are used to transform data, a query can transform pipelines.  That is, a query can be applied to a pipeline to produce a new pipeline.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To run a query on the given data, we apply the query to a trivial pipeline. The generated pipeline is used to actually transform the data.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To demonstrate how to apply a query, let us use EmployeesWithSalaryOver100K from the previous section.  Recall that it could be represented as follows:","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Get(:department) >> Get(:employee) >> Filter(Get(:salary) .> 100000)\n#-> Get(:department) >> Get(:employee) >> Filter(Get(:salary) .> 100000)","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"This query is constructed using a composition combinator.  A query composition transforms a pipeline by sequentially applying the component queries. Therefore, to find the pipeline of EmployeesWithSalaryOver100K, we need to start with a trivial pipeline and sequentially tranfrorm it with the queries Get(:department), Get(:employee) and Filter(SalaryOver100K).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The trivial pipeline can be obtained from the input data.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"p0 = trivial_pipe(chicago)\n#-> pass()","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use the function assemble() to apply a query to a pipeline.  To run assemble() we need to create the environment object.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"env = Environment()\n\np1 = assemble(env, p0, Get(:department))\n#-> chain_of(with_elements(column(:department)), flatten())","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The pipeline p1 fetches the attribute department from the input data.  In general, Get(name) maps a pipeline to its elementwise composition with column(name).  For example, when we apply Get(:employee) to p1, what we get is the result of compose(p1, column(:employee)).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"p2 = assemble(env, p1, Get(:employee))\n#=>\nchain_of(chain_of(with_elements(column(:department)), flatten()),\n         chain_of(with_elements(column(:employee)), flatten()))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To finish assembling the pipeline, we apply Filter(SalaryOver100K) to p2. Filter acts on the input pipeline as follows.  First, it assembles the predicate pipeline by applying the predicate query to a trivial pipeline.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"pc0 = target_pipe(p2)\n#-> wrap()\n\npc1 = assemble(env, pc0, SalaryOver100K)\n#=>\nchain_of(\n    wrap(),\n    chain_of(\n        with_elements(\n            chain_of(\n                chain_of(\n                    ⋮\n                    tuple_lift(>)),\n                adapt_missing())),\n        flatten()))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Filter(SalaryOver100K) then combines the pipelines p2 and pc1 using the pipeline primitive sieve_by().","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"p3 = assemble(env, p2, Filter(SalaryOver100K))\n#=>\nchain_of(\n    chain_of(chain_of(with_elements(column(:department)), flatten()),\n             chain_of(with_elements(column(:employee)), flatten())),\n    chain_of(\n        with_elements(\n            chain_of(\n                ⋮\n                sieve_by())),\n        flatten()))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The resulting pipeline could be compacted by simplifying the pipeline expression.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"p = optimize(uncover(p3))\n#=>\nchain_of(with_elements(chain_of(column(:department),\n                                with_elements(column(:employee)))),\n         flatten(),\n         flatten(),\n         with_elements(\n             chain_of(tuple_of(pass(),\n                               chain_of(tuple_of(\n                                            column(:salary),\n                                            chain_of(\n                                                wrap(),\n                                                with_elements(\n                                                    filler(100000)))),\n                                        tuple_lift(>),\n                                        adapt_missing(),\n                                        block_any())),\n                      sieve_by())),\n         flatten())\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Applying this pipeline to the input data gives us the output of the query.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"p(chicago)\n#=>\n  │ employee                                   │\n  │ name       position           salary  rate │\n──┼────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT           101442       │\n2 │ JAMES A    FIRE ENGINEER-EMT  103350       │\n3 │ ROBERT K   FIREFIGHTER-EMT    103272       │\n=#","category":"page"},{"location":"queries/#API-Reference-1","page":"Query Algebra","title":"API Reference","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Modules = [DataKnots]\nPages = [\"queries.jl\"]\nPublic = false","category":"page"},{"location":"queries/#DataKnots.Environment","page":"Query Algebra","title":"DataKnots.Environment","text":"Environment()\n\nQuery compilation state.\n\n\n\n\n\n","category":"type"},{"location":"queries/#DataKnots.Query","page":"Query Algebra","title":"DataKnots.Query","text":"Query(op, args...)\n\nA query is implemented as a pipeline transformation that preserves pipeline source.  Specifically, a query takes the input pipeline that maps the source to the input target and generates a pipeline that maps the source to the output target.\n\nParameter op is a function that performs the transformation; args are extra arguments passed to the function.\n\nThe query transforms an input pipeline p by invoking op with the following arguments:\n\nop(env::Environment, q::Pipeline, args...)\n\nThe result of op must be the output pipeline.\n\n\n\n\n\n","category":"type"},{"location":"queries/#Base.getindex-Tuple{DataKnot,Any}","page":"Query Algebra","title":"Base.getindex","text":"db::DataKnot[F::Query; params...] :: DataKnot\n\nQueries db with F.\n\n\n\n\n\n","category":"method"},{"location":"queries/#Test-Suite-1","page":"Query Algebra","title":"Test Suite","text":"","category":"section"},{"location":"queries/#Querying-1","page":"Query Algebra","title":"Querying","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"A Query is applied to a DataKnot using the array indexing syntax.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Count(It.department)\n\nchicago[Q]\n#=>\n┼───┼\n│ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Any parameters to the query should be be passed as keyword arguments.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Filter(Count(It.employee >> Filter(It.salary .> It.AMT)) .>= It.SZ) >>\n    Count\n\nchicago[Q, AMT=100000, SZ=1]\n#=>\n┼───┼\n│ 2 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We can use the function assemble() to see the query plan.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"p = assemble(chicago, Count(It.department))\n#=>\nchain_of(with_elements(\n             chain_of(column(:department), block_length(), wrap())),\n         flatten())\n=#\n\np(chicago)\n#=>\n┼───┼\n│ 3 │\n=#","category":"page"},{"location":"queries/#@query-1","page":"Query Algebra","title":"@query","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Query objects could be constructed using a convenient notation provided by the macro @query.  For example, the query Count(It.department) could also be written as:","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query count(department)\n#-> Count(Get(:department))","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The @query macro could also be used to apply the constructed query to a DataKnot.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query chicago count(department)\n#=>\n┼───┼\n│ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Query parameters could be passed as keyword arguments.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query chicago AMT=100000 SZ=1 begin\n    department\n    filter(count(employee.filter(salary > AMT)) >= SZ)\n    count()\nend\n#=>\n┼───┼\n│ 2 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Queries defined elsewhere could be embedded in a @query expression using interpolation syntax ($).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Size = @query count(employee)\n#-> Count(Get(:employee))\n\n@query department{name, $Size}\n#-> Get(:department) >> Record(Get(:name), Count(Get(:employee)))","category":"page"},{"location":"queries/#Composition-1","page":"Query Algebra","title":"Composition","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Queries can be composed sequentially using the >> combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Lift(3) >> (It .+ 4) >> (It .* 6)\n#-> Lift(3) >> (It .+ 4) >> It .* 6\n\nchicago[Q]\n#=>\n┼────┼\n│ 42 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The It query primitive is the identity with respect to >>.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It >> Q >> It\n#-> It >> Lift(3) >> (It .+ 4) >> It .* 6 >> It\n\nchicago[Q]\n#=>\n┼────┼\n│ 42 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, the identity query is called it.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query it\n#-> It","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Composition of queries is written as a sequence of statements in a begin/end block.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query begin\n    3\n    it + 4\n    it * 6\nend\n#-> Lift(3) >> Lift(+, (It, Lift(4))) >> Lift(*, (It, Lift(6)))\n\n@query (3; it + 4; it * 6)\n#-> Lift(3) >> Lift(+, (It, Lift(4))) >> Lift(*, (It, Lift(6)))","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Alternatively, the . symbol is used as the composition combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query (3).(it + 4).(it * 6)\n#-> Lift(3) >> Lift(+, (It, Lift(4))) >> Lift(*, (It, Lift(6)))","category":"page"},{"location":"queries/#Record-1","page":"Query Algebra","title":"Record","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The query Record(X₁, X₂ … Xₙ) emits records with the fields generated by X₁, X₂ … Xₙ.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Record(It.name,\n           :size => Count(It.employee))\n#-> It.department >> Record(It.name, :size => Count(It.employee))\n\nchicago[Q]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     4 │\n2 │ FIRE       3 │\n3 │ OEMC       3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If a field has no label, an ordinal label (#A, #B … #AA, #AB …) is assigned.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Record(It.name, Count(It.employee))\n#-> It.department >> Record(It.name, Count(It.employee))\n\nchicago[Q]\n#=>\n  │ department │\n  │ name    #B │\n──┼────────────┼\n1 │ POLICE   4 │\n2 │ FIRE     3 │\n3 │ OEMC     3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Similarly, when there are duplicate labels, only the last one survives.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Record(It.name, It.employee.name)\n#-> It.department >> Record(It.name, It.employee.name)\n\nchicago[Q]\n#=>\n  │ department                                    │\n  │ #A      name                                  │\n──┼───────────────────────────────────────────────┼\n1 │ POLICE  JEFFERY A; NANCY A; ANTHONY A; ALBA M │\n2 │ FIRE    JAMES A; DANIEL A; ROBERT K           │\n3 │ OEMC    LAKENYA A; DORIS A; BRENDA B          │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Record(X₁, X₂ … Xₙ) is written as record(X₁, X₂ … Xₙ).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.record(name, size => count(employee))\n#=>\nGet(:department) >> Record(Get(:name),\n                           Count(Get(:employee)) >> Label(:size))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Alternatively, we could use the {} brackets.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query {count(department), max(department.count(employee))}\n#=>\nRecord(Count(Get(:department)),\n       Max(Get(:department) >> Count(Get(:employee))))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"When {} is used in composition, the composition operator . could be omitted.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.{name, size => count(employee)}\n#=>\nGet(:department) >> Record(Get(:name),\n                           Count(Get(:employee)) >> Label(:size))\n=#\n\n@query department{name, size => count(employee)}\n#=>\nGet(:department) >> Record(Get(:name),\n                           Count(Get(:employee)) >> Label(:size))\n=#","category":"page"},{"location":"queries/#Collect-1","page":"Query Algebra","title":"Collect","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The query Collect(X) adds a new field to the input record.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Collect(:size => Count(It.employee))\n#-> It.department >> Collect(:size => Count(It.employee))\n\nchicago[Q]\n#=>\n  │ department                                                        │\n  │ name    employee{name,position,salary,rate}                  size │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ POLICE  JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLI…    4 │\n2 │ FIRE    JAMES A, FIRE ENGINEER-EMT, 103350, missing; DANIEL…    3 │\n3 │ OEMC    LAKENYA A, CROSSING GUARD, missing, 17.68; DORIS A,…    3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"More than one field could be added at the same time.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Collect(:size => Count(It.employee),\n            :avg_salary => Sum(It.employee.salary) ./ It.size)\n\nchicago[Q]\n#=>\n  │ department                                                        │\n  │ name    employee{name,position,salary,rate}      size  avg_salary │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ POLICE  JEFFERY A, SERGEANT, 101442, missing; N…    4     63492.0 │\n2 │ FIRE    JAMES A, FIRE ENGINEER-EMT, 103350, mis…    3    100702.0 │\n3 │ OEMC    LAKENYA A, CROSSING GUARD, missing, 17.…    3     21464.0 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If the new field has no label, an ordinal label will be assigned to it.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Collect(Count(It.employee))\n\nchicago[Q]\n#=>\n  │ department                                                        │\n  │ name    employee{name,position,salary,rate}                    #C │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ POLICE  JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLICE…  4 │\n2 │ FIRE    JAMES A, FIRE ENGINEER-EMT, 103350, missing; DANIEL A…  3 │\n3 │ OEMC    LAKENYA A, CROSSING GUARD, missing, 17.68; DORIS A, C…  3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If the record already has a field with the same name, that field is removed and the new field is added.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Collect(:employee => It.employee.name)\n\nchicago[Q]\n#=>\n  │ department                                    │\n  │ name    employee                              │\n──┼───────────────────────────────────────────────┼\n1 │ POLICE  JEFFERY A; NANCY A; ANTHONY A; ALBA M │\n2 │ FIRE    JAMES A; DANIEL A; ROBERT K           │\n3 │ OEMC    LAKENYA A; DORIS A; BRENDA B          │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"To remove a field from a record, replace it with the value nothing.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Collect(:size => Count(It.employee),\n                             :employee => nothing)\n\nchicago[Q]\n#=>\n  │ department   │\n  │ name    size │\n──┼──────────────┼\n1 │ POLICE     4 │\n2 │ FIRE       3 │\n3 │ OEMC       3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Collect can be used as an aggregate primitive.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee >> Collect\n\nchicago[Q]\n#=>\n│ department{name,employee{name,pos… employee{name,position,salary,ra…│\n┼─────────────────────────────────────────────────────────────────────┼\n│ POLICE, [JEFFERY A, SERGEANT, 101… JEFFERY A, SERGEANT, 101442, mis…│\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Collect(X) is written as collect(X).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.collect(size => count(employee), employee => nothing)\n#=>\nGet(:department) >> Collect(Count(Get(:employee)) >> Label(:size),\n                            Lift(nothing) >> Label(:employee))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The aggregate primitive Collect is written as collect().","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.employee.collect()\n#-> Get(:department) >> Get(:employee) >> Then(Collect)","category":"page"},{"location":"queries/#Join-1","page":"Query Algebra","title":"Join","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Join(X), just like Collect(X), adds a field to the input record.  As opposed to Collect, Join(X) evaluates its argument against the input source.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Each(It.employee >> Join(:dept_name => It.name))\n#-> It.department >> Each(It.employee >> Join(:dept_name => It.name))\n\nchicago[Q]\n#=>\n   │ employee                                                  │\n   │ name       position              salary  rate   dept_name │\n───┼───────────────────────────────────────────────────────────┼\n 1 │ JEFFERY A  SERGEANT              101442         POLICE    │\n 2 │ NANCY A    POLICE OFFICER         80016         POLICE    │\n 3 │ ANTHONY A  POLICE OFFICER         72510         POLICE    │\n 4 │ ALBA M     POLICE CADET                   9.46  POLICE    │\n 5 │ JAMES A    FIRE ENGINEER-EMT     103350         FIRE      │\n 6 │ DANIEL A   FIREFIGHTER-EMT        95484         FIRE      │\n 7 │ ROBERT K   FIREFIGHTER-EMT       103272         FIRE      │\n 8 │ LAKENYA A  CROSSING GUARD                17.68  OEMC      │\n 9 │ DORIS A    CROSSING GUARD                19.38  OEMC      │\n10 │ BRENDA B   TRAFFIC CONTROL AIDE   64392         OEMC      │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"At the same time, Join(X) uses the target source, which allows us to correlate the joined field with the input data.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee >>\n    Filter(Exists(It.salary)) >>\n    Keep(:the_salary => It.salary) >>\n    Join(:rank => Count(It.department.employee >> Filter(It.salary .>= It.the_salary)))\n\nchicago[Q]\n#=>\n  │ employee                                            │\n  │ name       position              salary  rate  rank │\n──┼─────────────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT              101442           3 │\n2 │ NANCY A    POLICE OFFICER         80016           5 │\n3 │ ANTHONY A  POLICE OFFICER         72510           6 │\n4 │ JAMES A    FIRE ENGINEER-EMT     103350           1 │\n5 │ DANIEL A   FIREFIGHTER-EMT        95484           4 │\n6 │ ROBERT K   FIREFIGHTER-EMT       103272           2 │\n7 │ BRENDA B   TRAFFIC CONTROL AIDE   64392           7 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If the new field has no label, it will have an ordinal label assigned to it.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(:the_size => Count(It.employee)) >>\n    Join(Count(It.department >> Filter(Count(It.employee) .>= It.the_size)))\n\nchicago[Q]\n#=>\n  │ department                                                        │\n  │ name    employee{name,position,salary,rate}                    #C │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ POLICE  JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLICE…  1 │\n2 │ FIRE    JAMES A, FIRE ENGINEER-EMT, 103350, missing; DANIEL A…  3 │\n3 │ OEMC    LAKENYA A, CROSSING GUARD, missing, 17.68; DORIS A, C…  3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If the record already has a field with the same name, that field is removed and the new field is added.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Each(It.employee >>\n         Keep(:the_position => It.position) >>\n         Join(:position => It.the_position .* \" (\" .* It.name .* \")\"))\n\nchicago[Q]\n#=>\n   │ employee                                              │\n   │ name       salary  rate   position                    │\n───┼───────────────────────────────────────────────────────┼\n 1 │ JEFFERY A  101442         SERGEANT (POLICE)           │\n 2 │ NANCY A     80016         POLICE OFFICER (POLICE)     │\n 3 │ ANTHONY A   72510         POLICE OFFICER (POLICE)     │\n 4 │ ALBA M              9.46  POLICE CADET (POLICE)       │\n 5 │ JAMES A    103350         FIRE ENGINEER-EMT (FIRE)    │\n 6 │ DANIEL A    95484         FIREFIGHTER-EMT (FIRE)      │\n 7 │ ROBERT K   103272         FIREFIGHTER-EMT (FIRE)      │\n 8 │ LAKENYA A          17.68  CROSSING GUARD (OEMC)       │\n 9 │ DORIS A            19.38  CROSSING GUARD (OEMC)       │\n10 │ BRENDA B    64392         TRAFFIC CONTROL AIDE (OEMC) │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Join(X) is written as join(X).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.each(employee.join(dept_name => name))\n#=>\nGet(:department) >> Each(Get(:employee) >> Join(Get(:name) >>\n                                                Label(:dept_name)))\n=#","category":"page"},{"location":"queries/#Mix-1","page":"Query Algebra","title":"Mix","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The query Mix(X₁, X₂ … Xₙ) emits records containing all combinations of elements generated by X₁, X₂ … Xₙ.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Mix(It.name, It.employee)\n#-> It.department >> Mix(It.name, It.employee)\n\nchicago[Q]\n#=>\n   │ department                                             │\n   │ name    employee{name,position,salary,rate}            │\n───┼────────────────────────────────────────────────────────┼\n 1 │ POLICE  JEFFERY A, SERGEANT, 101442, missing           │\n 2 │ POLICE  NANCY A, POLICE OFFICER, 80016, missing        │\n 3 │ POLICE  ANTHONY A, POLICE OFFICER, 72510, missing      │\n 4 │ POLICE  ALBA M, POLICE CADET, missing, 9.46            │\n 5 │ FIRE    JAMES A, FIRE ENGINEER-EMT, 103350, missing    │\n 6 │ FIRE    DANIEL A, FIREFIGHTER-EMT, 95484, missing      │\n 7 │ FIRE    ROBERT K, FIREFIGHTER-EMT, 103272, missing     │\n 8 │ OEMC    LAKENYA A, CROSSING GUARD, missing, 17.68      │\n 9 │ OEMC    DORIS A, CROSSING GUARD, missing, 19.38        │\n10 │ OEMC    BRENDA B, TRAFFIC CONTROL AIDE, 64392, missing │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"When a field has no label, an ordinal label is assigned.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Mix(It.name, It.employee.rate >> round.(It))\n\nchicago[Q]\n#=>\n  │ department   │\n  │ name    #B   │\n──┼──────────────┼\n1 │ POLICE   9.0 │\n2 │ OEMC    18.0 │\n3 │ OEMC    19.0 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Similarly, duplicate fields are replaced by ordinal labels.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Mix(It.name, It.employee.name)\n\nchicago[Q]\n#=>\n   │ department        │\n   │ #A      name      │\n───┼───────────────────┼\n 1 │ POLICE  JEFFERY A │\n 2 │ POLICE  NANCY A   │\n 3 │ POLICE  ANTHONY A │\n 4 │ POLICE  ALBA M    │\n 5 │ FIRE    JAMES A   │\n 6 │ FIRE    DANIEL A  │\n 7 │ FIRE    ROBERT K  │\n 8 │ OEMC    LAKENYA A │\n 9 │ OEMC    DORIS A   │\n10 │ OEMC    BRENDA B  │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Mix(X₁, X₂ … Xₙ) is written as mix(X₁, X₂ … Xₙ).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.mix(name, employee)\n#-> Get(:department) >> Mix(Get(:name), Get(:employee))","category":"page"},{"location":"queries/#Lift-1","page":"Query Algebra","title":"Lift","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The Lift constructor is used to convert Julia values and functions to queries.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Lift(val) makes a query primitive from a Julia value.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Lift(\"Hello World!\")\n#-> Lift(\"Hello World!\")\n\nchicago[Q]\n#=>\n┼──────────────┼\n│ Hello World! │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Lifting missing produces no output.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Lift(missing)\n#-> Lift(missing)\n\nchicago[Q]\n#=>\n(empty)\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Lifting a vector produces plural output.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Lift('a':'c')\n#-> Lift('a':1:'c')\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"When lifting a vector, we can specify the cardinality constraint.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Lift('a':'c', :x1toN)\n#-> Lift('a':1:'c', :x1toN)\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ a │\n2 │ b │\n3 │ c │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Lift can also convert Julia functions to query combinators.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Inc(X) = Lift(x -> x+1, (X,))\n\nQ = Lift(0) >> Inc(It)\n#-> Lift(0) >> Lift(x -> x + 1, (It,))\n\nchicago[Q]\n#=>\n┼───┼\n│ 1 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Functions of multiple arguments are also supported.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"GT(X, Y) = Lift(>, (X, Y))\n\nQ = It.department.employee >>\n    Record(It.name, It.salary, GT(It.salary, 100000))\n#=>\nIt.department.employee >>\nRecord(It.name, It.salary, Lift(>, (It.salary, 100000)))\n=#\n\nchicago[Q]\n#=>\n   │ employee                 │\n   │ name       salary  #C    │\n───┼──────────────────────────┼\n 1 │ JEFFERY A  101442   true │\n 2 │ NANCY A     80016  false │\n 3 │ ANTHONY A   72510  false │\n 4 │ ALBA M                   │\n 5 │ JAMES A    103350   true │\n 6 │ DANIEL A    95484  false │\n 7 │ ROBERT K   103272   true │\n 8 │ LAKENYA A                │\n 9 │ DORIS A                  │\n10 │ BRENDA B    64392  false │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Just as functions with no arguments.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"using Random: seed!\n\nseed!(0)\n\nQ = Lift(rand, ())\n#-> Lift(rand, ())\n\nchicago[Q]\n#=>\n┼──────────┼\n│ 0.823648 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Functions with vector arguments are supported.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"using Statistics: mean\n\nMean(X) = Lift(mean, (X,))\n\nQ = Mean(It.department.employee.salary)\n#-> Lift(mean, (It.department.employee.salary,))\n\nchicago[Q]\n#=>\n┼─────────┼\n│ 88638.0 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Just like with regular values, missing and vector results are interpreted as no and plural output.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Inc(missing)\n#-> Lift(x -> x + 1, (missing,))\n\nchicago[Q]\n#=>\n(empty)\n=#\n\nOneTo(N) = Lift(UnitRange, (1, N))\n\nQ = OneTo(3)\n#-> Lift(UnitRange, (1, 3))\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ 1 │\n2 │ 2 │\n3 │ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Julia functions are lifted when they are broadcasted over queries.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = mean.(It.department.employee.salary)\n#-> mean.(It.department.employee.salary)\n\nchicago[Q]\n#=>\n┼─────────┼\n│ 88638.0 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, values and functions are lifted automatically.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query \"Hello World!\"\n#-> Lift(\"Hello World!\")\n\n@query missing\n#-> Lift(missing)\n\n@query 'a':'c'\n#-> Lift(Colon, (Lift('a'), Lift('c')))\n\n@query (0; it + 1)\n#-> Lift(0) >> Lift(+, (It, Lift(1)))\n\n@query department.employee{name, salary, salary > 100000}\n#=>\nGet(:department) >>\nGet(:employee) >>\nRecord(Get(:name), Get(:salary), Lift(>, (Get(:salary), Lift(100000))))\n=#\n\n@query mean(department.employee.salary)\n#-> Lift(mean, (Get(:department) >> Get(:employee) >> Get(:salary),))","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Query-valued functions are also supported.  They are not lifted, but applied immediately.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"increment(x) = @query $x + 1\n\n@query increment(1)\n#-> Lift(+, (Lift(1), Lift(1)))","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Query value functions could also be defined via Lift.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"increment(x) = Lift(+, (x, 1))\n\n@query increment(1 + 1)\n#-> Lift(+, (Lift(+, (Lift(1), Lift(1))), 1))","category":"page"},{"location":"queries/#Each-1","page":"Query Algebra","title":"Each","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Each serves as a barrier for aggregate queries.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> (It.employee >> Count)\n#-> It.department >> It.employee >> Count\n\nchicago[Q]\n#=>\n┼────┼\n│ 10 │\n=#\n\nQ = It.department >> Each(It.employee >> Count)\n#-> It.department >> Each(It.employee >> Count)\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ 4 │\n2 │ 3 │\n3 │ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Note that Record and Lift also serve as natural barriers for aggregate queries.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Record(It.name, It.employee >> Count)\n#-> It.department >> Record(It.name, It.employee >> Count)\n\nchicago[Q]\n#=>\n  │ department │\n  │ name    #B │\n──┼────────────┼\n1 │ POLICE   4 │\n2 │ FIRE     3 │\n3 │ OEMC     3 │\n=#\n\nQ = It.department >>\n    (1 .* (It.employee >> Count))\n#-> It.department >> 1 .* (It.employee >> Count)\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ 4 │\n2 │ 3 │\n3 │ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Each(X) is written as each(X).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.each(employee.count())\n#-> Get(:department) >> Each(Get(:employee) >> Then(Count))","category":"page"},{"location":"queries/#Label-1","page":"Query Algebra","title":"Label","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use the Label() primitive to assign a label to the output.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Count(It.department) >> Label(:num_dept)\n#-> Count(It.department) >> Label(:num_dept)\n\nchicago[Q]\n#=>\n│ num_dept │\n┼──────────┼\n│        3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"As a shorthand, we can use =>.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = :num_dept => Count(It.department)\n#-> :num_dept => Count(It.department)\n\nchicago[Q]\n#=>\n│ num_dept │\n┼──────────┼\n│        3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, we could use label(name) or => syntax.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query count(department).label(num_dept)\n#-> Count(Get(:department)) >> Label(:num_dept)\n\n@query num_dept => count(department)\n#-> Count(Get(:department)) >> Label(:num_dept)","category":"page"},{"location":"queries/#Tag-1","page":"Query Algebra","title":"Tag","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use Tag() constructor to assign a name to a query.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"DeptSize = Count(It.employee) >> Label(:dept_size)\n#-> Count(It.employee) >> Label(:dept_size)\n\nDeptSize = Tag(:DeptSize, DeptSize)\n#-> DeptSize\n\nQ = It.department >> Record(It.name, DeptSize)\n#-> It.department >> Record(It.name, DeptSize)\n\nchicago[Q]\n#=>\n  │ department        │\n  │ name    dept_size │\n──┼───────────────────┼\n1 │ POLICE          4 │\n2 │ FIRE            3 │\n3 │ OEMC            3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Tag() is also used to assign a name to a query combinator.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"SalaryOver(X) = It.salary .> X\n\nSalaryOver(100000)\n#-> It.salary .> 100000\n\nSalaryOver(X) = Tag(SalaryOver, (X,), It.salary .> X)\n\nSalaryOver(100000)\n#-> SalaryOver(100000)\n\nQ = It.department.employee >>\n    Filter(SalaryOver(100000))\n#-> It.department.employee >> Filter(SalaryOver(100000))\n\nchicago[Q]\n#=>\n  │ employee                                   │\n  │ name       position           salary  rate │\n──┼────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT           101442       │\n2 │ JAMES A    FIRE ENGINEER-EMT  103350       │\n3 │ ROBERT K   FIREFIGHTER-EMT    103272       │\n=#","category":"page"},{"location":"queries/#Get-1","page":"Query Algebra","title":"Get","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use the Get(name) to extract the value of a record field.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Get(:department) >> Get(:name)\n#-> Get(:department) >> Get(:name)\n\nchicago[Q]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n3 │ OEMC   │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"As a shorthand, extracting an attribute of It generates a Get() query.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.name\n#-> It.department.name\n\nchicago[Q]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n3 │ OEMC   │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We can also extract fields that have ordinal labels, but the label name is not preserved.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Record(It.name, Count(It.employee)) >>\n    It.B\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ 4 │\n2 │ 3 │\n3 │ 3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Same notation is used to extract values of context parameters defined with Keep() or Given().","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(:dept_name => It.name) >>\n    It.employee >>\n    Record(It.dept_name, It.name)\n\nchicago[Q]\n#=>\n   │ employee             │\n   │ dept_name  name      │\n───┼──────────────────────┼\n 1 │ POLICE     JEFFERY A │\n 2 │ POLICE     NANCY A   │\n 3 │ POLICE     ANTHONY A │\n 4 │ POLICE     ALBA M    │\n 5 │ FIRE       JAMES A   │\n 6 │ FIRE       DANIEL A  │\n 7 │ FIRE       ROBERT K  │\n 8 │ OEMC       LAKENYA A │\n 9 │ OEMC       DORIS A   │\n10 │ OEMC       BRENDA B  │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"A context parameter is preferred if it has the same name as a record field.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(It.name) >>\n    It.employee >>\n    Record(It.name, It.position)\n\nchicago[Q]\n#=>\n   │ employee                     │\n   │ name    position             │\n───┼──────────────────────────────┼\n 1 │ POLICE  SERGEANT             │\n 2 │ POLICE  POLICE OFFICER       │\n 3 │ POLICE  POLICE OFFICER       │\n 4 │ POLICE  POLICE CADET         │\n 5 │ FIRE    FIRE ENGINEER-EMT    │\n 6 │ FIRE    FIREFIGHTER-EMT      │\n 7 │ FIRE    FIREFIGHTER-EMT      │\n 8 │ OEMC    CROSSING GUARD       │\n 9 │ OEMC    CROSSING GUARD       │\n10 │ OEMC    TRAFFIC CONTROL AIDE │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"If there is no attribute with the given name, an error is reported.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee.ssn\n\nchicago[Q]\n#=>\nERROR: cannot find \"ssn\" at\n(0:N) × (name = (1:1) × String, position = (1:1) × String, salary = (0:1) × Int64, rate = (0:1) × Float64)\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Regular and named tuples also support attribute lookup.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Lift((name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442)) >>\n    It.position\n\nchicago[Q]\n#=>\n│ position │\n┼──────────┼\n│ SERGEANT │\n=#\n\nQ = Lift((name = \"JEFFERY A\", position = \"SERGEANT\", salary = 101442)) >>\n    It.ssn\n\nchicago[Q]\n#=>\nERROR: cannot find \"ssn\" at\n(1:1) × NamedTuple{(:name, :position, :salary),Tuple{String,String,Int64}}\n=#\n\nQ = Lift((\"JEFFERY A\", \"SERGEANT\", 101442)) >>\n    It.B\n\nchicago[Q]\n#=>\n┼──────────┼\n│ SERGEANT │\n=#\n\nQ = Lift((\"JEFFERY A\", \"SERGEANT\", 101442)) >>\n    It.Z\n\nchicago[Q]\n#=>\nERROR: cannot find \"Z\" at\n(1:1) × Tuple{String,String,Int64}\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Get(:name) is written as name.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.name\n#-> Get(:department) >> Get(:name)","category":"page"},{"location":"queries/#Keep-and-Given-1","page":"Query Algebra","title":"Keep and Given","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use the combinator Keep() to assign a value to a context parameter.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(:dept_name => It.name) >>\n    It.employee >>\n    Record(It.dept_name, It.name)\n#=>\nIt.department >>\nKeep(:dept_name => It.name) >>\nIt.employee >>\nRecord(It.dept_name, It.name)\n=#\n\nchicago[Q]\n#=>\n   │ employee             │\n   │ dept_name  name      │\n───┼──────────────────────┼\n 1 │ POLICE     JEFFERY A │\n 2 │ POLICE     NANCY A   │\n 3 │ POLICE     ANTHONY A │\n 4 │ POLICE     ALBA M    │\n 5 │ FIRE       JAMES A   │\n 6 │ FIRE       DANIEL A  │\n 7 │ FIRE       ROBERT K  │\n 8 │ OEMC       LAKENYA A │\n 9 │ OEMC       DORIS A   │\n10 │ OEMC       BRENDA B  │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Several context parameters could be defined together.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(:size => Count(It.employee),\n         :half => It.size .÷ 2) >>\n    Each(It.employee >> Take(It.half))\n\nchicago[Q]\n#=>\n  │ employee                                    │\n  │ name       position           salary  rate  │\n──┼─────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT           101442        │\n2 │ NANCY A    POLICE OFFICER      80016        │\n3 │ JAMES A    FIRE ENGINEER-EMT  103350        │\n4 │ LAKENYA A  CROSSING GUARD             17.68 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Keep() requires that the parameter is labeled.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(Count(It.employee))\n\nchicago[Q]\n#-> ERROR: parameter name is not specified","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Keep() will override an existing parameter with the same name.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Keep(:current_name => It.name) >>\n    It.employee >>\n    Filter(It.current_name .== \"POLICE\") >>\n    Keep(:current_name => It.name) >>\n    It.current_name\n\nchicago[Q]\n#=>\n  │ current_name │\n──┼──────────────┼\n1 │ JEFFERY A    │\n2 │ NANCY A      │\n3 │ ANTHONY A    │\n4 │ ALBA M       │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Combinator Given() is used to evaluate a query with the given context parameters.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Given(:size => Count(It.employee),\n          :half => It.size .÷ 2,\n          It.employee >> Take(It.half))\n#=>\nIt.department >> Given(:size => Count(It.employee),\n                       :half => div.(It.size, 2),\n                       It.employee >> Take(It.half))\n=#\n\nchicago[Q]\n#=>\n  │ employee                                    │\n  │ name       position           salary  rate  │\n──┼─────────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT           101442        │\n2 │ NANCY A    POLICE OFFICER      80016        │\n3 │ JAMES A    FIRE ENGINEER-EMT  103350        │\n4 │ LAKENYA A  CROSSING GUARD             17.68 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Given() does not let any parameters defined within its scope escape it.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Given(Keep(It.name)) >>\n    It.employee >>\n    It.name\n\nchicago[Q]\n#=>\n   │ name      │\n───┼───────────┼\n 1 │ JEFFERY A │\n 2 │ NANCY A   │\n 3 │ ANTHONY A │\n 4 │ ALBA M    │\n 5 │ JAMES A   │\n 6 │ DANIEL A  │\n 7 │ ROBERT K  │\n 8 │ LAKENYA A │\n 9 │ DORIS A   │\n10 │ BRENDA B  │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Given has an alias called Let.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Let\n#-> DataKnots.Given","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Keep(X) and Given(X, Q) are written as keep(X) and given(X, Q).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.keep(dept_name => name).employee{dept_name, name}\n#=>\nGet(:department) >>\nKeep(Get(:name) >> Label(:dept_name)) >>\nGet(:employee) >>\nRecord(Get(:dept_name), Get(:name))\n=#\n\n@query begin\n    department\n    given(size => count(employee),\n          half => size ÷ 2,\n          employee.take(half))\nend\n#=>\nGet(:department) >> Given(Count(Get(:employee)) >> Label(:size),\n                          Lift(div, (Get(:size), Lift(2))) >>\n                          Label(:half),\n                          Get(:employee) >> Take(Get(:half)))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Alternatively, the let clause is translated to a Given expression.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query begin\n    department\n    let dept_name => name\n        employee{dept_name, name}\n    end\nend\n#=>\nGet(:department) >> Given(Get(:name) >> Label(:dept_name),\n                          Get(:employee) >> Record(Get(:dept_name),\n                                                   Get(:name)))\n=#\n\n@query begin\n    department\n    let size => count(employee), half => size ÷ 2\n        employee.take(half)\n    end\nend\n#=>\nGet(:department) >> Given(Count(Get(:employee)) >> Label(:size),\n                          Lift(div, (Get(:size), Lift(2))) >>\n                          Label(:half),\n                          Get(:employee) >> Take(Get(:half)))\n=#","category":"page"},{"location":"queries/#Count,-Exists,-Sum,-Max,-Min-1","page":"Query Algebra","title":"Count, Exists, Sum, Max, Min","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Count(X), Sum(X), Max(X), Min(X) evaluate the X and emit the number of elements, their sum, maximum, and minimum respectively.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Rate = It.department.employee.rate\n\nQ = Record(Rate,\n           :count => Count(Rate),\n           :sum => Sum(Rate),\n           :max => Max(Rate),\n           :min => Min(Rate))\n#=>\nRecord(It.department.employee.rate,\n       :count => Count(It.department.employee.rate),\n       :sum => Sum(It.department.employee.rate),\n       :max => Max(It.department.employee.rate),\n       :min => Min(It.department.employee.rate))\n=#\n\nchicago[Q]\n#=>\n│ rate                count  sum    max    min  │\n┼───────────────────────────────────────────────┼\n│ 9.46; 17.68; 19.38      3  46.52  19.38  9.46 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Count, Sum, Max, and Min could also be used as aggregate primitives.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Record(Rate,\n           :count => Rate >> Count,\n           :sum => Rate >> Sum,\n           :max => Rate >> Max,\n           :min => Rate >> Min)\n#=>\nRecord(It.department.employee.rate,\n       :count => It.department.employee.rate >> Count,\n       :sum => It.department.employee.rate >> Sum,\n       :max => It.department.employee.rate >> Max,\n       :min => It.department.employee.rate >> Min)\n=#\n\nchicago[Q]\n#=>\n│ rate                count  sum    max    min  │\n┼───────────────────────────────────────────────┼\n│ 9.46; 17.68; 19.38      3  46.52  19.38  9.46 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"When applied to an empty input, Sum emits 0, Min and Max emit no output.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Rate = It.employee.rate\n\nQ = It.department >>\n    Record(It.name,\n           Rate,\n           :count => Count(Rate),\n           :sum => Sum(Rate),\n           :max => Max(Rate),\n           :min => Min(Rate))\n\nchicago[Q]\n#=>\n  │ department                                       │\n  │ name    rate          count  sum    max    min   │\n──┼──────────────────────────────────────────────────┼\n1 │ POLICE  9.46              1   9.46   9.46   9.46 │\n2 │ FIRE                      0   0.0                │\n3 │ OEMC    17.68; 19.38      2  37.06  19.38  17.68 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Exists(X) evaluates X and emits a Boolean value that indicates whether X produces at least one value or not.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee >>\n    Record(It.name,\n           It.salary,\n           :has_salary => Exists(It.salary),\n           It.rate,\n           :has_rate => It.rate >> Exists)\n#=>\nIt.department.employee >> Record(It.name,\n                                 It.salary,\n                                 :has_salary => Exists(It.salary),\n                                 It.rate,\n                                 :has_rate => It.rate >> Exists)\n=#\n\nchicago[Q]\n#=>\n   │ employee                                       │\n   │ name       salary  has_salary  rate   has_rate │\n───┼────────────────────────────────────────────────┼\n 1 │ JEFFERY A  101442        true            false │\n 2 │ NANCY A     80016        true            false │\n 3 │ ANTHONY A   72510        true            false │\n 4 │ ALBA M                  false   9.46      true │\n 5 │ JAMES A    103350        true            false │\n 6 │ DANIEL A    95484        true            false │\n 7 │ ROBERT K   103272        true            false │\n 8 │ LAKENYA A               false  17.68      true │\n 9 │ DORIS A                 false  19.38      true │\n10 │ BRENDA B    64392        true            false │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"These operations are also available in the @query notation.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query begin\n    department.employee.rate.collect()\n    {rate, count(rate), sum(rate), max(rate), min(rate)}\nend\n#=>\nGet(:department) >>\nGet(:employee) >>\nGet(:rate) >>\nThen(Collect) >>\nRecord(Get(:rate),\n       Count(Get(:rate)),\n       Sum(Get(:rate)),\n       Max(Get(:rate)),\n       Min(Get(:rate)))\n=#\n\n@query begin\n    department\n    collect(employee.rate)\n    {rate, rate.count(), rate.sum(), rate.max(), rate.min()}\nend\n#=>\nGet(:department) >>\nCollect(Get(:employee) >> Get(:rate)) >>\nRecord(Get(:rate),\n       Get(:rate) >> Then(Count),\n       Get(:rate) >> Then(Sum),\n       Get(:rate) >> Then(Max),\n       Get(:rate) >> Then(Min))\n=#\n\n@query department.employee{name, exists(salary), rate.exists()}\n#=>\nGet(:department) >>\nGet(:employee) >>\nRecord(Get(:name), Exists(Get(:salary)), Get(:rate) >> Then(Exists))\n=#","category":"page"},{"location":"queries/#Filter-1","page":"Query Algebra","title":"Filter","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use Filter() to filter the input by the given predicate.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Filter(It.name .== \"POLICE\") >>\n    It.employee >>\n    Filter(It.name .== \"JEFFERY A\")\n#=>\nIt.department >>\nFilter(It.name .== \"POLICE\") >>\nIt.employee >>\nFilter(It.name .== \"JEFFERY A\")\n=#\n\nchicago[Q]\n#=>\n  │ employee                          │\n  │ name       position  salary  rate │\n──┼───────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT  101442       │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The predicate must produce true of false values.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Filter(Count(It.employee))\n\nchicago[Q]\n#-> ERROR: expected a predicate","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The input data is dropped when the output of the predicate contains only false elements.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Filter(It.employee >> (It.salary .> 100000)) >>\n    Record(It.name, It.employee.salary)\n\nchicago[Q]\n#=>\n  │ department                    │\n  │ name    salary                │\n──┼───────────────────────────────┼\n1 │ POLICE  101442; 80016; 72510  │\n2 │ FIRE    103350; 95484; 103272 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, we write filter(X).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query begin\n    department\n    filter(name == \"POLICE\")\n    employee\n    filter(name == \"JEFFERY A\")\nend\n#=>\nGet(:department) >>\nFilter(Lift(==, (Get(:name), Lift(\"POLICE\")))) >>\nGet(:employee) >>\nFilter(Lift(==, (Get(:name), Lift(\"JEFFERY A\"))))\n=#","category":"page"},{"location":"queries/#First,-Last,-Nth-1","page":"Query Algebra","title":"First, Last, Nth","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We can use First(X), Last(X) and Nth(X, N) to extract the first, the last, or the N-th element of the output of X.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[It.department.name]\n#=>\n  │ name   │\n──┼────────┼\n1 │ POLICE │\n2 │ FIRE   │\n3 │ OEMC   │\n=#\n\nQ = First(It.department.name)\n#-> First(It.department.name)\n\nchicago[Q]\n#=>\n│ name   │\n┼────────┼\n│ POLICE │\n=#\n\nQ = Last(It.department.name)\n#-> Last(It.department.name)\n\nchicago[Q]\n#=>\n│ name │\n┼──────┼\n│ OEMC │\n=#\n\nQ = Nth(It.department.name, 2)\n#-> Nth(It.department.name, 2)\n\nchicago[Q]\n#=>\n│ name │\n┼──────┼\n│ FIRE │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"These operations also have an aggregate form.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.name >> First\n#-> It.department.name >> First\n\nchicago[Q]\n#=>\n│ name   │\n┼────────┼\n│ POLICE │\n=#\n\nQ = It.department.name >> Last\n#-> It.department.name >> Last\n\nchicago[Q]\n#=>\n│ name │\n┼──────┼\n│ OEMC │\n=#\n\nQ = It.department.name >> Nth(2)\n#-> It.department.name >> Nth(2)\n\nchicago[Q]\n#=>\n│ name │\n┼──────┼\n│ FIRE │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Nth can take a query argument, which is evaluated against the input source and must produce a singular mandatory integer value.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[Nth(It.department.name, Count(It.department) .- 1)]\n#=>\n│ name │\n┼──────┼\n│ FIRE │\n=#\n\nchicago[It.department.name >> Nth(Count(It.department) .- 1)]\n#=>\n│ name │\n┼──────┼\n│ FIRE │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, we write first(), last() and nth(N).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query first(department)\n#-> First(Get(:department))\n\n@query last(department)\n#-> Last(Get(:department))\n\n@query nth(department, 2)\n#-> Nth(Get(:department), Lift(2))\n\n@query department.first()\n#-> Get(:department) >> Then(First)\n\n@query department.last()\n#-> Get(:department) >> Then(Last)\n\n@query department.nth(2)\n#-> Get(:department) >> Nth(Lift(2))","category":"page"},{"location":"queries/#Take-and-Drop-1","page":"Query Algebra","title":"Take and Drop","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use Take(N) and Drop(N) to pass or drop the first N input elements.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Employee =\n    It.department >>\n    Filter(It.name .== \"POLICE\") >>\n    It.employee\n\nQ = Employee >> Take(3)\n#-> It.department >> Filter(It.name .== \"POLICE\") >> It.employee >> Take(3)\n\nchicago[Q]\n#=>\n  │ employee                                │\n  │ name       position        salary  rate │\n──┼─────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT        101442       │\n2 │ NANCY A    POLICE OFFICER   80016       │\n3 │ ANTHONY A  POLICE OFFICER   72510       │\n=#\n\nQ = Employee >> Drop(3)\n#-> It.department >> Filter(It.name .== \"POLICE\") >> It.employee >> Drop(3)\n\nchicago[Q]\n#=>\n  │ employee                           │\n  │ name    position      salary  rate │\n──┼────────────────────────────────────┼\n1 │ ALBA M  POLICE CADET          9.46 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Take(-N) drops the last N elements, while Drop(-N) keeps the last N elements.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Employee >> Take(-3)\n\nchicago[Q]\n#=>\n  │ employee                          │\n  │ name       position  salary  rate │\n──┼───────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT  101442       │\n=#\n\nQ = Employee >> Drop(-3)\n\nchicago[Q]\n#=>\n  │ employee                                │\n  │ name       position        salary  rate │\n──┼─────────────────────────────────────────┼\n1 │ NANCY A    POLICE OFFICER   80016       │\n2 │ ANTHONY A  POLICE OFFICER   72510       │\n3 │ ALBA M     POLICE CADET            9.46 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Take and Drop accept a query argument, which is evaluated against the input source and must produce a singular integer.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Half = Count(Employee) .÷ 2\n\nQ = Employee >> Take(Half)\n\nchicago[Q]\n#=>\n  │ employee                                │\n  │ name       position        salary  rate │\n──┼─────────────────────────────────────────┼\n1 │ JEFFERY A  SERGEANT        101442       │\n2 │ NANCY A    POLICE OFFICER   80016       │\n=#\n\nQ = Take(Employee >> It.name)\n\nchicago[Q]\n#-> ERROR: expected a singular integer","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, we write take(N) and drop(N).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.employee.take(3)\n#-> Get(:department) >> Get(:employee) >> Take(Lift(3))\n\n@query department.employee.drop(3)\n#-> Get(:department) >> Get(:employee) >> Drop(Lift(3))","category":"page"},{"location":"queries/#Is0to1,-Is0toN,-Is1to1,-Is1toN-1","page":"Query Algebra","title":"Is0to1, Is0toN, Is1to1, Is1toN","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The Is1to1 query asserts that the input exists and is singular.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Take(1) >>\n    Is1to1\n#-> It.department >> Take(1) >> Is1to1\n\nchicago[Q]\n#=>\n│ department                                                          │\n│ name    employee{name,position,salary,rate}                         │\n┼─────────────────────────────────────────────────────────────────────┼\n│ POLICE  JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLICE OFFIC…│\n=#\n\nshape(chicago[Q])\n#=>\nBlockOf(⋮\n        x1to1) |>\nIsLabeled(:department)\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"This operation can also be used in a combinator form.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q >>= Is1to1(It.employee >> Take(1))\n#-> It.department >> Take(1) >> Is1to1 >> Is1to1(It.employee >> Take(1))\n\nchicago[Q]\n#=>\n│ employee                          │\n│ name       position  salary  rate │\n┼───────────────────────────────────┼\n│ JEFFERY A  SERGEANT  101442       │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Other cardinality constraints can also be asserted.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"chicago[It.department.name >> Take(1) >> Is0to1] |> shape\n#-> BlockOf(String, x0to1) |> IsLabeled(:name)\n\nchicago[It.department.name >> Take(1) >> Is0toN] |> shape\n#-> BlockOf(String) |> IsLabeled(:name)\n\nchicago[It.department.name >> Take(1) >> Is1toN] |> shape\n#-> BlockOf(String, x1toN) |> IsLabeled(:name)\n\nchicago[Is0to1(It.department.name >> Take(1))] |> shape\n#-> BlockOf(String, x0to1) |> IsLabeled(:name)\n\nchicago[Is0toN(It.department.name >> Take(1))] |> shape\n#-> BlockOf(String) |> IsLabeled(:name)\n\nchicago[Is1toN(It.department.name >> Take(1))] |> shape\n#-> BlockOf(String, x1toN) |> IsLabeled(:name)","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"When the constraint is not satisfied, an error is reported.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >> Record(It.name, It.employee >> Is1to1)\n\nchicago[Q]\n#-> ERROR: \"employee\": expected a singular value, relative to \"department\"","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"These operations could also be used to widen the cardinality constraint.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = Count(It.department) >> Is1toN\n\nchicago[Q]\n#=>\n──┼───┼\n1 │ 3 │\n=#\n\nshape(chicago[Q])\n#-> BlockOf(Int64, x1toN)","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, these operations are written as is0to1(), is0toN(), is1to1(), is1toN().","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query chicago department.name.take(1).is1to1()\n#=>\n│ name   │\n┼────────┼\n│ POLICE │\n=#\n\n@query chicago is1to1(department.name.take(1))\n#=>\n│ name   │\n┼────────┼\n│ POLICE │\n=#\n\nshape(@query chicago department.name.take(1).is0to1())\n#-> BlockOf(String, x0to1) |> IsLabeled(:name)\n\nshape(@query chicago department.name.take(1).is0toN())\n#-> BlockOf(String) |> IsLabeled(:name)\n\nshape(@query chicago department.name.take(1).is1toN())\n#-> BlockOf(String, x1toN) |> IsLabeled(:name)\n\nshape(@query chicago is0to1(department.name.take(1)))\n#-> BlockOf(String, x0to1) |> IsLabeled(:name)\n\nshape(@query chicago is0toN(department.name.take(1)))\n#-> BlockOf(String) |> IsLabeled(:name)\n\nshape(@query chicago is1toN(department.name.take(1)))\n#-> BlockOf(String, x1toN) |> IsLabeled(:name)","category":"page"},{"location":"queries/#Unique-and-Group-1","page":"Query Algebra","title":"Unique and Group","text":"","category":"section"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use the Unique combinator to produce unique elements of a collection.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Record(It.name, Unique(It.employee.position))\n#-> It.department >> Record(It.name, Unique(It.employee.position))\n\nchicago[Q]\n#=>\n  │ department                                     │\n  │ name    position                               │\n──┼────────────────────────────────────────────────┼\n1 │ POLICE  POLICE CADET; POLICE OFFICER; SERGEANT │\n2 │ FIRE    FIRE ENGINEER-EMT; FIREFIGHTER-EMT     │\n3 │ OEMC    CROSSING GUARD; TRAFFIC CONTROL AIDE   │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Unique also has a primitive query form.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee.position >> Unique\n#-> It.department.employee.position >> Unique\n\nchicago[Q]\n#=>\n  │ position             │\n──┼──────────────────────┼\n1 │ CROSSING GUARD       │\n2 │ FIRE ENGINEER-EMT    │\n3 │ FIREFIGHTER-EMT      │\n4 │ POLICE CADET         │\n5 │ POLICE OFFICER       │\n6 │ SERGEANT             │\n7 │ TRAFFIC CONTROL AIDE │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, Unique(X) is written as unique(X).","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department{name, unique(employee.position)}\n#=>\nGet(:department) >> Record(Get(:name),\n                           Unique(Get(:employee) >> Get(:position)))\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"The aggregate query form of Unique is written as unique().","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query department.employee.position.unique()\n#=>\nGet(:department) >> Get(:employee) >> Get(:position) >> Then(Unique)\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"We use the Group combinator to group the input by the given key.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee >>\n    Group(It.position)\n#-> It.department.employee >> Group(It.position)\n\nchicago[Q]\n#=>\n  │ position              employee{name,position,salary,rate}         │\n──┼───────────────────────────────────────────────────────────────────┼\n1 │ CROSSING GUARD        LAKENYA A, CROSSING GUARD, missing, 17.68; …│\n2 │ FIRE ENGINEER-EMT     JAMES A, FIRE ENGINEER-EMT, 103350, missing │\n3 │ FIREFIGHTER-EMT       DANIEL A, FIREFIGHTER-EMT, 95484, missing; …│\n4 │ POLICE CADET          ALBA M, POLICE CADET, missing, 9.46         │\n5 │ POLICE OFFICER        NANCY A, POLICE OFFICER, 80016, missing; AN…│\n6 │ SERGEANT              JEFFERY A, SERGEANT, 101442, missing        │\n7 │ TRAFFIC CONTROL AIDE  BRENDA B, TRAFFIC CONTROL AIDE, 64392, miss…│\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Arbitrary key expressions are supported.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department >>\n    Group(:size => Count(It.employee)) >>\n    Record(It.size, :count => Count(It.department))\n\nchicago[Q]\n#=>\n  │ size  count │\n──┼─────────────┼\n1 │    3      2 │\n2 │    4      1 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Empty keys are placed on top.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee >>\n    Group(:grade => It.salary .÷ 10000) >>\n    Record(It.grade, :n => Count(It.employee))\n\nchicago[Q]\n#=>\n  │ grade  n │\n──┼──────────┼\n1 │        3 │\n2 │     6  1 │\n3 │     7  1 │\n4 │     8  1 │\n5 │     9  1 │\n6 │    10  3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"More than one key column could be provided.","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"Q = It.department.employee >>\n    Group(ismissing.(It.salary),\n          ismissing.(It.rate)) >>\n    Record(It.A, It.B, Count(It.employee))\n\nchicago[Q]\n#=>\n  │ #A     #B     #C │\n──┼──────────────────┼\n1 │ false   true   7 │\n2 │  true  false   3 │\n=#","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"In @query notation, we write group().","category":"page"},{"location":"queries/#","page":"Query Algebra","title":"Query Algebra","text":"@query begin\n    department\n    group(size => count(employee))\n    {size, count => count(department)}\nend\n#=>\nGet(:department) >>\nGroup(Count(Get(:employee)) >> Label(:size)) >>\nRecord(Get(:size), Count(Get(:department)) >> Label(:count))\n=#","category":"page"}]
}
