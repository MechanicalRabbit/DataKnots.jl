<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Query Algebra · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../tutorial/">DataKnots Tutorial</a></li><li><a class="toctext" href="../thinking/">Thinking in Combinators</a></li><li><a class="toctext" href="../reference/">Reference</a></li><li><a class="toctext" href="../implementation/">Implementation Notes</a><ul><li class="current"><a class="toctext" href>Query Algebra</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#API-Reference-1">API Reference</a></li><li><a class="toctext" href="#Test-Suite-1">Test Suite</a></li></ul></li></ul></li><li><a class="toctext" href="../simulation/">Tutorial: Simulated Data</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="../implementation/">Implementation Notes</a></li><li><a href>Query Algebra</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/queries.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Query Algebra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Query-Algebra-1" href="#Query-Algebra-1">Query Algebra</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>In this section, we sketch the design and implementation of the query algebra. We will need the following definitions.</p><pre><code class="language-julia">using DataKnots:
    @VectorTree,
    Count,
    DataKnot,
    Drop,
    Each,
    Environment,
    Filter,
    Get,
    Given,
    It,
    Label,
    Lift,
    Max,
    Min,
    Record,
    Tag,
    Take,
    compile,
    elements,
    optimize,
    stub,
    uncover</code></pre><p>As a running example, we will use the following dataset of city departments with associated employees.  This dataset is serialized as a nested structure with a singleton root record, which holds all department records, each of which holds associated employee records.</p><pre><code class="language-julia">chicago_data =
    @VectorTree (department = [(name     = (1:1)String,
                                employee = [(name     = (1:1)String,
                                             position = (1:1)String,
                                             salary   = (0:1)Int,
                                             rate     = (0:1)Float64)])],) [
        (department = [
            (name     = &quot;POLICE&quot;,
             employee = [&quot;JEFFERY A&quot;  &quot;SERGEANT&quot;           101442   missing
                         &quot;NANCY A&quot;    &quot;POLICE OFFICER&quot;     80016    missing]),
            (name     = &quot;FIRE&quot;,
             employee = [&quot;JAMES A&quot;    &quot;FIRE ENGINEER-EMT&quot;  103350   missing
                         &quot;DANIEL A&quot;   &quot;FIRE FIGHTER-EMT&quot;   95484    missing]),
            (name     = &quot;OEMC&quot;,
             employee = [&quot;LAKENYA A&quot;  &quot;CROSSING GUARD&quot;     missing  17.68
                         &quot;DORIS A&quot;    &quot;CROSSING GUARD&quot;     missing  19.38])],
        )
    ]

chicago = DataKnot(chicago_data, :x1to1)
#=&gt;
│ department                                                                   …
┼──────────────────────────────────────────────────────────────────────────────…
│ POLICE, [JEFFERY A, SERGEANT, 101442, missing; NANCY A, POLICE OFFICER, 80016…
=#</code></pre><h3><a class="nav-anchor" id="Assembling-queries-1" href="#Assembling-queries-1">Assembling queries</a></h3><p>In DataKnots, we query data by assembling and running <code>Query</code> objects.  Queries are assembled algebraically: they either come a set of atomic <em>primitive</em> queries, or are built from other queries using query <em>combinators</em>.</p><p>For example, consider the query:</p><pre><code class="language-julia">Employees = Get(:department) &gt;&gt; Get(:employee)
#-&gt; Get(:department) &gt;&gt; Get(:employee)</code></pre><p>This query traverses the dataset through fields <em>department</em> and <em>employee</em>. It is assembled from two primitive queries <code>Get(:department)</code> and <code>Get(:employee)</code> connected using the query composition combinator <code>&gt;&gt;</code>.</p><p>Since attribute traversal is so common, DataKnots provides a shorthand notation.</p><pre><code class="language-julia">Employees = It.department.employee
#-&gt; It.department.employee</code></pre><p>To apply a query to a <code>DataKnot</code>, we use indexing notation.  The output of a query is also a <code>DataKnot</code>.</p><pre><code class="language-julia">chicago[Employees]
#=&gt;
  │ employee                                    │
  │ name       position           salary  rate  │
──┼─────────────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT           101442        │
2 │ NANCY A    POLICE OFFICER      80016        │
3 │ JAMES A    FIRE ENGINEER-EMT  103350        │
4 │ DANIEL A   FIRE FIGHTER-EMT    95484        │
5 │ LAKENYA A  CROSSING GUARD             17.68 │
6 │ DORIS A    CROSSING GUARD             19.38 │
=#</code></pre><p>Regular Julia values and functions could be used to create query components. Specifically, any Julia value could be converted to a query primitive, and any Julia function could be converted to a query combinator.</p><p>For example, let us find find employees whose salary is greater than $100k. For this purpose, we need to construct a predicate query that compares the <em>salary</em> field with a specific number.</p><p>If we were constructing an ordinary predicate function, we would write:</p><pre><code class="language-julia">salary_over_100k(emp) = emp.salary &gt; 100000</code></pre><p>An equivalent query is constructed as follows:</p><pre><code class="language-julia">SalaryOver100K = Lift(&gt;, (Get(:salary), Lift(100000)))
#-&gt; Lift(&gt;, (Get(:salary), Lift(100000)))</code></pre><p>This query expression is assembled from two primitive components: <code>Get(:salary)</code> and <code>Lift(100000)</code>, which serve as parameters of the <code>Lift(&gt;)</code> combinator.  Here, <code>Lift</code> is used twice.  <code>Lift</code> applied to a regular Julia value converts it to a <em>constant</em> query primitive while <code>Lift</code> applied to a function <em>lifts</em> it to a query combinator.</p><p>As a shorthand notation for lifting functions and operators, DataKnots supports broadcasting syntax:</p><pre><code class="language-julia">SalaryOver100K = It.salary .&gt; 100000
#-&gt; It.salary .&gt; 100000</code></pre><p>To test this query, we can append it to the <code>Employees</code> query using the composition combinator.</p><pre><code class="language-julia">chicago[Employees &gt;&gt; SalaryOver100K]
#=&gt;
  │ It    │
──┼───────┼
1 │  true │
2 │ false │
3 │  true │
4 │ false │
=#</code></pre><p>However, this only gives us a list of bare Boolean values disconnected from the respective employees.  To contextualize this output, we can use the <code>Record</code> combinator.</p><pre><code class="language-julia">chicago[Employees &gt;&gt; Record(It.name,
                            It.salary,
                            :salary_over_100k =&gt; SalaryOver100K)]
#=&gt;
  │ employee                            │
  │ name       salary  salary_over_100k │
──┼─────────────────────────────────────┼
1 │ JEFFERY A  101442              true │
2 │ NANCY A     80016             false │
3 │ JAMES A    103350              true │
4 │ DANIEL A    95484             false │
5 │ LAKENYA A                           │
6 │ DORIS A                             │
=#</code></pre><p>To actually filter the data using this predicate query, we need to use the <code>Filter</code> combinator.</p><pre><code class="language-julia">EmployeesWithSalaryOver100K = Employees &gt;&gt; Filter(SalaryOver100K)
#-&gt; It.department.employee &gt;&gt; Filter(It.salary .&gt; 100000)

chicago[EmployeesWithSalaryOver100K]
#=&gt;
  │ employee                                   │
  │ name       position           salary  rate │
──┼────────────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT           101442       │
2 │ JAMES A    FIRE ENGINEER-EMT  103350       │
=#</code></pre><p>DataKnots provides a number of useful query constructors.  For example, to find the number of items produced by a query, we can use the <code>Count</code> combinator.</p><pre><code class="language-julia">chicago[Count(EmployeesWithSalaryOver100K)]
#=&gt;
│ It │
┼────┼
│  2 │
=#</code></pre><p>In general, query algebra forms an XPath-like domain-specific language.  It is designed to let the user construct queries incrementally, with each step being individually crafted and tested.  It also encourages the user to create reusable query components and remix them in creative ways.</p><h3><a class="nav-anchor" id="Compiling-queries-1" href="#Compiling-queries-1">Compiling queries</a></h3><p>In DataKnots, applying a query to the input data is a two-phase process. First, the query is compiled to a pipeline.  Second, this pipeline transforms the input data to the output data.</p><p>Let us elaborate on the role of pipelines and queries.  In DataKnots, just like pipelines are used to transform data, a query can transform pipelines.  That is, a query can be applied to a pipeline to produce a new pipeline.</p><p>To run a query on the given data, we apply the query to a <em>trivial</em> pipeline. The generated pipeline is used to actually transform the data.</p><p>To demonstrate how to compile a query, let us use <code>EmployeesWithSalaryOver100K</code> from the previous section.  Recall that it could be represented as follows:</p><pre><code class="language-julia">Get(:department) &gt;&gt; Get(:employee) &gt;&gt; Filter(Get(:salary) .&gt; 100000)
#-&gt; Get(:department) &gt;&gt; Get(:employee) &gt;&gt; Filter(Get(:salary) .&gt; 100000)</code></pre><p>This query is constructed using a composition combinator.  A query composition transforms a pipeline by sequentially applying the component queries. Therefore, to find the pipeline of <code>EmployeesWithSalaryOver100K</code>, we need to start with a trivial pipeline and sequentially tranfrorm it with the queries <code>Get(:department)</code>, <code>Get(:employee)</code> and <code>Filter(SalaryOver100K)</code>.</p><p>The trivial pipeline can be obtained from the input data.</p><pre><code class="language-julia">p0 = stub(chicago)
#-&gt; pass()</code></pre><p>We use the function <code>compile()</code> to apply a query to a pipeline.  To run <code>compile()</code> we need to create the <em>environment</em> object.</p><pre><code class="language-julia">env = Environment()

p1 = compile(Get(:department), env, p0)
#-&gt; chain_of(with_elements(column(:department)), flatten())</code></pre><p>The pipeline <code>p1</code> fetches the attribute <em>department</em> from the input data.  In general, <code>Get(name)</code> maps a pipeline to its monadic composition with <code>column(name)</code>.  For example, when we apply <code>Get(:employee)</code> to <code>p1</code>, what we get is the result of <code>compose(p1, column(:employee))</code>.</p><pre><code class="language-julia">p2 = compile(Get(:employee), env, p1)
#=&gt;
chain_of(chain_of(with_elements(column(:department)), flatten()),
         chain_of(with_elements(column(:employee)), flatten()))
=#</code></pre><p>To finish assembling the pipeline, we apply <code>Filter(SalaryOver100K)</code> to <code>p2</code>. <code>Filter</code> acts on the input pipeline as follows.  First, it compiles the predicate query using the trivial pipeline on the output of <code>p2</code>.</p><pre><code class="language-julia">pc0 = stub(p2)
#-&gt; wrap()

pc1 = compile(SalaryOver100K, env, pc0)
#=&gt;
chain_of(wrap(),
         chain_of(
             with_elements(
                 chain_of(
                     chain_of(
                         ⋮
                         tuple_lift(&gt;)),
                     adapt_missing())),
             flatten()))
=#</code></pre><p><code>Filter(SalaryOver100K)</code> then combines the pipelines <code>p2</code> and <code>pc1</code> using the pipeline primitive <code>sieve()</code>.</p><pre><code class="language-julia">p3 = compile(Filter(SalaryOver100K), env, p2)
#=&gt;
chain_of(
    chain_of(chain_of(with_elements(column(:department)), flatten()),
             chain_of(with_elements(column(:employee)), flatten())),
    chain_of(
        with_elements(
            chain_of(
                ⋮
                sieve())),
        flatten()))
=#</code></pre><p>The resulting pipeline could be compacted by simplifying the pipeline expression.</p><pre><code class="language-julia">p = optimize(uncover(p3))
#=&gt;
chain_of(with_elements(chain_of(column(:department),
                                with_elements(column(:employee)))),
         flatten(),
         flatten(),
         with_elements(chain_of(tuple_of(pass(),
                                         chain_of(tuple_of(column(:salary),
                                                           chain_of(
                                                               filler(100000),
                                                               wrap())),
                                                  tuple_lift(&gt;),
                                                  adapt_missing(),
                                                  block_any())),
                                sieve())),
         flatten())
=#</code></pre><p>Applying this pipeline to the input data gives us the output of the query.</p><pre><code class="language-julia">p(chicago)
#=&gt;
  │ employee                                   │
  │ name       position           salary  rate │
──┼────────────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT           101442       │
2 │ JAMES A    FIRE ENGINEER-EMT  103350       │
=#</code></pre><h2><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Count-Tuple{Any}" href="#DataKnots.Count-Tuple{Any}"><code>DataKnots.Count</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Count(X)
X &gt;&gt; Count</code></pre><p>Counts the number of elements produced by <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L825-L830">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Drop-Tuple{Any}" href="#DataKnots.Drop-Tuple{Any}"><code>DataKnots.Drop</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Drop(N)</code></pre><p>Drops the first <code>N</code> elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L965-L969">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Each-Tuple{Any}" href="#DataKnots.Each-Tuple{Any}"><code>DataKnots.Each</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Each(X) :: Query</code></pre><p>This query evaluates <code>X</code> elementwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L568-L572">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Filter-Tuple{Any}" href="#DataKnots.Filter-Tuple{Any}"><code>DataKnots.Filter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Filter(X)</code></pre><p>Filters the input by condition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L918-L922">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Get-Tuple{Any}" href="#DataKnots.Get-Tuple{Any}"><code>DataKnots.Get</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Get(name)</code></pre><p>Finds an attribute or a parameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L637-L641">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Given-Tuple{Any,Vararg{Any,N} where N}" href="#DataKnots.Given-Tuple{Any,Vararg{Any,N} where N}"><code>DataKnots.Given</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Given(P, X)</code></pre><p>Specifies the parameter and bounds its scope.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L776-L780">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Keep-Tuple{Any,Vararg{Any,N} where N}" href="#DataKnots.Keep-Tuple{Any,Vararg{Any,N} where N}"><code>DataKnots.Keep</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Keep(P)</code></pre><p>Specifies the parameter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L750-L754">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Label-Tuple{Symbol}" href="#DataKnots.Label-Tuple{Symbol}"><code>DataKnots.Label</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Label(lbl::Symbol) :: Query</code></pre><p>Assigns a label to the output.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L583-L587">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Lift-Tuple{Any,Tuple}" href="#DataKnots.Lift-Tuple{Any,Tuple}"><code>DataKnots.Lift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Lift(f, (X₁, X₂ … Xₙ)) :: Query</code></pre><p>This query uses the outputs of <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code> as arguments of <code>f</code>.  The output of <code>f</code> is emitted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L499-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Lift-Tuple{Any}" href="#DataKnots.Lift-Tuple{Any}"><code>DataKnots.Lift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Lift(val) :: Query</code></pre><p>This query emits the given value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L491-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Max-Tuple{Any}" href="#DataKnots.Max-Tuple{Any}"><code>DataKnots.Max</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Max(X)
X &gt;&gt; Max</code></pre><p>Finds the maximum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L854-L859">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Min-Tuple{Any}" href="#DataKnots.Min-Tuple{Any}"><code>DataKnots.Min</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Min(X)
X &gt;&gt; Min</code></pre><p>Finds the minimum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L866-L871">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Record-Tuple" href="#DataKnots.Record-Tuple"><code>DataKnots.Record</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Record(X₁, X₂ … Xₙ) :: Query</code></pre><p>This query emits records, whose fields are generated by <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L450-L454">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Sum-Tuple{Any}" href="#DataKnots.Sum-Tuple{Any}"><code>DataKnots.Sum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Sum(X)
X &gt;&gt; Sum</code></pre><p>Sums the elements produced by <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L842-L847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Tag-Tuple{Symbol,Any}" href="#DataKnots.Tag-Tuple{Symbol,Any}"><code>DataKnots.Tag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Tag(name::Symbol, F) :: Query
Tag(name::Symbol, (X₁, X₂ … Xₙ), F) :: Query</code></pre><p>Assigns a name to a query.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L602-L607">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Take-Tuple{Any}" href="#DataKnots.Take-Tuple{Any}"><code>DataKnots.Take</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Take(N)</code></pre><p>Takes the first <code>N</code> elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L957-L961">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Environment" href="#DataKnots.Environment"><code>DataKnots.Environment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Environment()</code></pre><p>Query compilation state.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Navigation" href="#DataKnots.Navigation"><code>DataKnots.Navigation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">It</code></pre><p>Identity query with respect to the query composition.</p><pre><code class="language-julia">It.a.b.c</code></pre><p>Equivalent to <code>Get(:a) &gt;&gt; Get(:b) &gt;&gt; Get(:c)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L57-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataKnots.Query" href="#DataKnots.Query"><code>DataKnots.Query</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Query(op, args...)</code></pre><p>A query is implemented as a pipeline transformation.  Specifically, a query takes a pipeline that maps <em>origin</em> to <em>input</em> and generates a pipeline that maps <em>origin</em> to <em>output</em>.</p><p>Parameter <code>op</code> is a function that performs the transformation; <code>args</code> are extra arguments passed to the function.</p><p>The query transforms an input pipeline <code>p</code> by invoking <code>op</code> with the following arguments:</p><pre><code class="language-julia">op(env::Environment, q::Pipeline, args...)</code></pre><p>The result of <code>op</code> must be the output pipeline.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L18-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataKnot,Any}" href="#Base.getindex-Tuple{DataKnot,Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">db::DataKnot[F::Query; params...] :: DataKnot</code></pre><p>Queries <code>db</code> with <code>F</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rbt-lang/DataKnots.jl/blob/ba3f8a2fabe25b39d87f6b823c4c4b5bdb78c11f/src/queries.jl#L87-L91">source</a></section><h2><a class="nav-anchor" id="Test-Suite-1" href="#Test-Suite-1">Test Suite</a></h2><h3><a class="nav-anchor" id="Querying-1" href="#Querying-1">Querying</a></h3><p>A <code>Query</code> is applied to a <code>DataKnot</code> using the array indexing syntax.</p><pre><code class="language-julia">Q = Count(It.department)

chicago[Q]
#=&gt;
│ It │
┼────┼
│  3 │
=#</code></pre><p>Any parameters to the query should be be passed as keyword arguments.</p><pre><code class="language-julia">Q = It.department &gt;&gt;
    Filter(Count(It.employee &gt;&gt; Filter(It.salary .&gt; It.AMT)) .&gt;= It.SZ) &gt;&gt;
    Count

chicago[Q, AMT=100000, SZ=1]
#=&gt;
│ It │
┼────┼
│  2 │
=#</code></pre><p>We can use the function <code>compile()</code> to see the query plan.</p><pre><code class="language-julia">p = compile(chicago, Count(It.department))
#=&gt;
chain_of(with_elements(chain_of(column(:department), block_length(), wrap())),
         flatten())
=#

p(chicago)
#=&gt;
│ It │
┼────┼
│  3 │
=#</code></pre><h3><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h3><p>Queries can be composed sequentially using the <code>&gt;&gt;</code> combinator.</p><pre><code class="language-julia">Q = Lift(3) &gt;&gt; (It .+ 4) &gt;&gt; (It .* 6)
#-&gt; Lift(3) &gt;&gt; (It .+ 4) &gt;&gt; It .* 6

chicago[Q]
#=&gt;
│ It │
┼────┼
│ 42 │
=#</code></pre><p>The <code>It</code> query primitive is the identity with respect to <code>&gt;&gt;</code>.</p><pre><code class="language-julia">Q = It &gt;&gt; Q &gt;&gt; It
#-&gt; It &gt;&gt; Lift(3) &gt;&gt; (It .+ 4) &gt;&gt; It .* 6 &gt;&gt; It

chicago[Q]
#=&gt;
│ It │
┼────┼
│ 42 │
=#</code></pre><h3><a class="nav-anchor" id="Record-1" href="#Record-1"><code>Record</code></a></h3><p>The query <code>Record(X₁, X₂ … Xₙ)</code> emits records with the fields generated by <code>X₁</code>, <code>X₂</code> … <code>Xₙ</code>.</p><pre><code class="language-julia">Q = It.department &gt;&gt;
    Record(It.name,
           :size =&gt; Count(It.employee))
#-&gt; It.department &gt;&gt; Record(It.name, :size =&gt; Count(It.employee))

chicago[Q]
#=&gt;
  │ department   │
  │ name    size │
──┼──────────────┼
1 │ POLICE     2 │
2 │ FIRE       2 │
3 │ OEMC       2 │
=#</code></pre><p>If a field has no label, an ordinal label (<code>#A</code>, <code>#B</code> … <code>#AA</code>, <code>#AB</code> …) is assigned.</p><pre><code class="language-julia">Q = It.department &gt;&gt; Record(It.name, Count(It.employee))
#-&gt; It.department &gt;&gt; Record(It.name, Count(It.employee))

chicago[Q]
#=&gt;
  │ department │
  │ name    #B │
──┼────────────┼
1 │ POLICE   2 │
2 │ FIRE     2 │
3 │ OEMC     2 │
=#</code></pre><p>Similarly, when there are duplicate labels, only the last one survives.</p><pre><code class="language-julia">Q = It.department &gt;&gt; Record(It.name, It.employee.name)
#-&gt; It.department &gt;&gt; Record(It.name, It.employee.name)

chicago[Q]
#=&gt;
  │ department                 │
  │ #A      name               │
──┼────────────────────────────┼
1 │ POLICE  JEFFERY A; NANCY A │
2 │ FIRE    JAMES A; DANIEL A  │
3 │ OEMC    LAKENYA A; DORIS A │
=#</code></pre><h3><a class="nav-anchor" id="Lift-1" href="#Lift-1"><code>Lift</code></a></h3><p>The <code>Lift</code> constructor is used to convert Julia values and functions to queries.</p><p><code>Lift(val)</code> makes a query primitive from a Julia value.</p><pre><code class="language-julia">Q = Lift(&quot;Hello World!&quot;)
#-&gt; Lift(&quot;Hello World!&quot;)

chicago[Q]
#=&gt;
│ It           │
┼──────────────┼
│ Hello World! │
=#</code></pre><p>Lifting <code>missing</code> produces no output.</p><pre><code class="language-julia">Q = Lift(missing)
#-&gt; Lift(missing)

chicago[Q]
#=&gt;
│ It │
┼────┼
=#</code></pre><p>Lifting a vector produces plural output.</p><pre><code class="language-julia">Q = Lift(&#39;a&#39;:&#39;c&#39;)
#-&gt; Lift(&#39;a&#39;:1:&#39;c&#39;)

chicago[Q]
#=&gt;
  │ It │
──┼────┼
1 │ a  │
2 │ b  │
3 │ c  │
=#</code></pre><p><code>Lift</code> can also convert Julia functions to query combinators.</p><pre><code class="language-julia">Inc(X) = Lift(x -&gt; x+1, (X,))

Q = Lift(0) &gt;&gt; Inc(It)
#-&gt; Lift(0) &gt;&gt; Lift(x -&gt; x + 1, (It,))

chicago[Q]
#=&gt;
│ It │
┼────┼
│  1 │
=#</code></pre><p>Functions of multiple arguments are also supported.</p><pre><code class="language-julia">GT(X, Y) = Lift(&gt;, (X, Y))

Q = It.department.employee &gt;&gt;
    Record(It.name, It.salary, GT(It.salary, 100000))
#=&gt;
It.department.employee &gt;&gt;
Record(It.name, It.salary, Lift(&gt;, (It.salary, 100000)))
=#

chicago[Q]
#=&gt;
  │ employee                 │
  │ name       salary  #C    │
──┼──────────────────────────┼
1 │ JEFFERY A  101442   true │
2 │ NANCY A     80016  false │
3 │ JAMES A    103350   true │
4 │ DANIEL A    95484  false │
5 │ LAKENYA A                │
6 │ DORIS A                  │
=#</code></pre><p>Just as functions with no arguments.</p><pre><code class="language-julia">using Random: seed!

seed!(0)

Q = Lift(rand, ())
#-&gt; Lift(rand, ())

chicago[Q]
#=&gt;
│ It       │
┼──────────┼
│ 0.823648 │
=#</code></pre><p>Functions with vector arguments are supported.</p><pre><code class="language-julia">using Statistics: mean

Mean(X) = Lift(mean, (X,))

Q = Mean(It.department.employee.salary)
#-&gt; Lift(mean, (It.department.employee.salary,))

chicago[Q]
#=&gt;
│ It      │
┼─────────┼
│ 95073.0 │
=#</code></pre><p>Just like with regular values, <code>missing</code> and vector results are interpreted as no and plural output.</p><pre><code class="language-julia">Q = Inc(missing)
#-&gt; Lift(x -&gt; x + 1, (missing,))

chicago[Q]
#=&gt;
│ It │
┼────┼
=#

OneTo(N) = Lift(UnitRange, (1, N))

Q = OneTo(3)
#-&gt; Lift(UnitRange, (1, 3))

chicago[Q]
#=&gt;
  │ It │
──┼────┼
1 │  1 │
2 │  2 │
3 │  3 │
=#</code></pre><p>Julia functions are lifted when they are broadcasted over queries.</p><pre><code class="language-julia">Q = mean.(It.department.employee.salary)
#-&gt; mean.(It.department.employee.salary)

chicago[Q]
#=&gt;
│ It      │
┼─────────┼
│ 95073.0 │
=#</code></pre><h3><a class="nav-anchor" id="Each-1" href="#Each-1"><code>Each</code></a></h3><p><code>Each</code> serves as a barrier for aggregate queries.</p><pre><code class="language-julia">Q = It.department &gt;&gt; (It.employee &gt;&gt; Count)
#-&gt; It.department &gt;&gt; It.employee &gt;&gt; Count

chicago[Q]
#=&gt;
│ It │
┼────┼
│  6 │
=#

Q = It.department &gt;&gt; Each(It.employee &gt;&gt; Count)
#-&gt; It.department &gt;&gt; Each(It.employee &gt;&gt; Count)

chicago[Q]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  2 │
3 │  2 │
=#</code></pre><p>Note that <code>Record</code> and <code>Lift</code> also serve as natural barriers for aggregate queries.</p><pre><code class="language-julia">Q = It.department &gt;&gt;
    Record(It.name, It.employee &gt;&gt; Count)
#-&gt; It.department &gt;&gt; Record(It.name, It.employee &gt;&gt; Count)

chicago[Q]
#=&gt;
  │ department │
  │ name    #B │
──┼────────────┼
1 │ POLICE   2 │
2 │ FIRE     2 │
3 │ OEMC     2 │
=#

Q = It.department &gt;&gt;
    (1 .* (It.employee &gt;&gt; Count))
#-&gt; It.department &gt;&gt; 1 .* (It.employee &gt;&gt; Count)

chicago[Q]
#=&gt;
  │ It │
──┼────┼
1 │  2 │
2 │  2 │
3 │  2 │
=#</code></pre><h3><a class="nav-anchor" id="Label-1" href="#Label-1"><code>Label</code></a></h3><p>We use the <code>Label()</code> primitive to assign a label to the output.</p><pre><code class="language-julia">Q = Count(It.department) &gt;&gt; Label(:num_dept)
#-&gt; Count(It.department) &gt;&gt; Label(:num_dept)

chicago[Q]
#=&gt;
│ num_dept │
┼──────────┼
│        3 │
=#</code></pre><p>As a shorthand, we can use <code>=&gt;</code>.</p><pre><code class="language-julia">Q = :num_dept =&gt; Count(It.department)
#-&gt; :num_dept =&gt; Count(It.department)

chicago[Q]
#=&gt;
│ num_dept │
┼──────────┼
│        3 │
=#</code></pre><h3><a class="nav-anchor" id="Tag-1" href="#Tag-1"><code>Tag</code></a></h3><p>We use <code>Tag()</code> constructor to assign a name to a query.</p><pre><code class="language-julia">DeptSize = Count(It.employee) &gt;&gt; Label(:dept_size)
#-&gt; Count(It.employee) &gt;&gt; Label(:dept_size)

DeptSize = Tag(:DeptSize, DeptSize)
#-&gt; DeptSize

Q = It.department &gt;&gt; Record(It.name, DeptSize)
#-&gt; It.department &gt;&gt; Record(It.name, DeptSize)

chicago[Q]
#=&gt;
  │ department        │
  │ name    dept_size │
──┼───────────────────┼
1 │ POLICE          2 │
2 │ FIRE            2 │
3 │ OEMC            2 │
=#</code></pre><p><code>Tag()</code> is also used to assign a name to a query combinator.</p><pre><code class="language-julia">SalaryOver(X) = It.salary .&gt; X

SalaryOver(100000)
#-&gt; It.salary .&gt; 100000

SalaryOver(X) = Tag(SalaryOver, (X,), It.salary .&gt; X)

SalaryOver(100000)
#-&gt; SalaryOver(100000)

Q = It.department.employee &gt;&gt;
    Filter(SalaryOver(100000))
#-&gt; It.department.employee &gt;&gt; Filter(SalaryOver(100000))

chicago[Q]
#=&gt;
  │ employee                                   │
  │ name       position           salary  rate │
──┼────────────────────────────────────────────┼
1 │ JEFFERY A  SERGEANT           101442       │
2 │ JAMES A    FIRE ENGINEER-EMT  103350       │
=#</code></pre><footer><hr/><a class="previous" href="../knots/"><span class="direction">Previous</span><span class="title">Data Knots</span></a><a class="next" href="../simulation/"><span class="direction">Next</span><span class="title">Tutorial: Simulated Data</span></a></footer></article></body></html>
