# Query Backend

The `Queries` module contains primitive operations and combinators for
transforming parallel vectors.

    using DataKnots.Vectors
    using DataKnots.Queries


## Lifting

Many vector operations can be generated by lifting.  For example,
`lift_const()` generates a primitive operation that maps any input vector to
the output vector of the same length filled with the given value.

    q = lift_const(200000)
    #-> lift_const(200000)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> [200000, 200000, 200000]

Similarly, the output of `lift_block()` is a block vector filled with the given
block.

    q = lift_block(["POLICE", "FIRE"])
    #-> lift_block(["POLICE", "FIRE"])

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @Parallel [String] [["POLICE", "FIRE"], ["POLICE", "FIRE"], ["POLICE", "FIRE"]]

A variant of `lift_block()` called `lift_null()` outputs a block vector with
empty blocks.

    q = lift_null()
    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @Parallel [Union{}] [missing, missing, missing]

Any scalar function could be lifted to a vector operation by applying it to
each element of the input vector.

    q = lift(titlecase)
    #-> lift(titlecase)

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> ["Garry M", "Anthony R", "Dana A"]

Similarly, any scalar function of several arguments could be lifted to an
operation on tuple vectors.

    q = lift_to_tuple(>)
    #-> lift_to_tuple(>)

    q(@Parallel (Int, Int) [260004 200000; 185364 200000; 170112 200000])
    #-> Bool[true, false, false]

It is also possible to apply a scalar function of several arguments to a tuple
vector that has block vectors for its columns.  In this case, the function is
applied to every combination of values from all the blocks on the same row.

    q = lift_to_block_tuple(>)

    q(@Parallel ([Int], [Int]) [[260004, 185364, 170112] 200000; missing 200000; [202728, 197736] [200000, 200000]])
    #-> @Parallel [Bool] [Bool[true, false, false], missing, Bool[true, true, false, false]]

Any function that takes a vector argument can be lifted to an operation on
block vectors.

    q = lift_to_block(length)
    #-> lift_to_block(length)

    q(@Parallel [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]])
    #-> [3, 2]

Some vector functions may expect a non-empty vector as an argument.  In this
case, we should provide the value to replace empty blocks.

    q = lift_to_block(maximum, missing)
    #-> lift_to_block(maximum, missing)

    q(@Parallel [Int] [[260004, 185364, 170112], [], [202728, 197736]])
    #-> Union{Missing, Int}[260004, missing, 202728]


## Decoding vectors

Any vector of tuples can be converted to a tuple vector.

    q = decode_tuple()
    #-> decode_tuple()

    q([("GARRY M", 260004), ("ANTHONY R", 185364), ("DANA A", 170112)]) |> display
    #=>
    TupleVector of 3 × (String, Int):
     ("GARRY M", 260004)
     ("ANTHONY R", 185364)
     ("DANA A", 170112)
    =#

Vectors of named tuples are also supported.

    q([(name="GARRY M", salary=260004), (name="ANTHONY R", salary=185364), (name="DANA A", salary=170112)]) |> display
    #=>
    TupleVector of 3 × (name = String, salary = Int):
     (name = "GARRY M", salary = 260004)
     (name = "ANTHONY R", salary = 185364)
     (name = "DANA A", salary = 170112)
    =#

A vector of vector objects can be converted to a block vector.

    q = decode_vector()
    #-> decode_vector()

    q([[260004, 185364, 170112], Int[], [202728, 197736]])
    #-> @Parallel [Int] [[260004, 185364, 170112], missing, [202728, 197736]]

Similarly, a vector containing `missing` values can be converted to a block
vector with zero- and one-element blocks.

    q = decode_missing()
    #-> decode_missing()

    q([260004, 185364, 170112, missing, 202728, 197736])
    #-> @Parallel [Int] [260004, 185364, 170112, missing, 202728, 197736]


## Tuple vectors

To create a tuple vector, we use the combinator `tuple_of()`. Its arguments are
the functions that generate the columns of the tuple.

    q = tuple_of(:title => lift(titlecase), :last => lift(last))
    #-> tuple_of([:title, :last], [lift(titlecase), lift(last)])

    q(["GARRY M", "ANTHONY R", "DANA A"]) |> display
    #=>
    TupleVector of 3 × (title = String, last = Char):
     (title = "Garry M", last = 'M')
     (title = "Anthony R", last = 'R')
     (title = "Dana A", last = 'A')
    =#

To extract a column of a tuple vector, we use the primitive `column()`.  It
accepts either the column position or the column name.

    q = column(1)
    #-> column(1)

    q(@Parallel (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112])
    #-> ["GARRY M", "ANTHONY R", "DANA A"]

    q = column(:salary)
    #-> column(:salary)

    q(@Parallel (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112])
    #-> [260004, 185364, 170112]

Finally, we can apply an arbitrary transformation to a selected column of a
tuple vector.

    q = in_tuple(:name, lift(titlecase))
    #-> in_tuple(:name, lift(titlecase))

    q(@Parallel (name = String, salary = Int) ["GARRY M" 260004; "ANTHONY R" 185364; "DANA A" 170112]) |> display
    #=>
    TupleVector of 3 × (name = String, salary = Int):
     (name = "Garry M", salary = 260004)
     (name = "Anthony R", salary = 185364)
     (name = "Dana A", salary = 170112)
    =#


## Block vectors

Primitive `as_block()` wraps the elements of the input vector to one-element blocks.

    q = as_block()
    #-> as_block()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> @Parallel [String] ["GARRY M", "ANTHONY R", "DANA A"]

In the opposite direction, primitive `flat_block()` flattens a block vector
with block elements.

    q = flat_block()
    #-> flat_block()

    q(@Parallel [[String]] [[["GARRY M"], ["ANTHONY R", "DANA A"]], [missing, ["JOSE S"], ["CHARLES S"]]])
    #-> @Parallel [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]]

Finally, we can apply an arbitrary transformation to every element of a block vector.

    q = in_block(lift(titlecase))
    #-> in_block(lift(titlecase))

    q(@Parallel [String] [["GARRY M", "ANTHONY R", "DANA A"], ["JOSE S", "CHARLES S"]])
    #-> @Parallel [String] [["Garry M", "Anthony R", "Dana A"], ["Jose S", "Charles S"]]

The `pull_block()` primitive converts a tuple vector with a block column to a
block vector of tuples.

    q = pull_block(1)
    #-> pull_block(1)

    q(@Parallel ([Int], [Int]) [
        [260004, 185364, 170112]    200000
        missing                     200000
        [202728, 197736]            [200000, 200000]]
    ) |> display
    #=>
    BlockVector of 3 × [(Int, [Int])]:
     [(260004, 200000), (185364, 200000), (170112, 200000)]
     missing
     [(202728, [200000, 200000]), (197736, [200000, 200000])]
    =#

It is also possible to pull all block columns from a tuple vector.

    q = pull_every_block()
    #-> pull_every_block()

    q(@Parallel ([Int], [Int]) [
        [260004, 185364, 170112]    200000
        missing                     200000
        [202728, 197736]            [200000, 200000]]
    ) |> display
    #=>
    BlockVector of 3 × [(Int, Int)]:
     [(260004, 200000), (185364, 200000), (170112, 200000)]
     missing
     [(202728, 200000), (202728, 200000), (197736, 200000), (197736, 200000)]
    =#


## Index vectors

An index vector could be dereferenced using the `dereference()` primitive.

    q = dereference()
    #-> dereference()

    q(@Parallel &DEPT [1, 1, 1, 2] where {DEPT = ["POLICE", "FIRE"]})
    #-> ["POLICE", "POLICE", "POLICE", "FIRE"]


## Composition

We can compose a sequence of transformations using the `chain_of()` combinator.

    q = chain_of(
            column(:employee),
            in_block(lift(titlecase)))
    #-> chain_of(column(:employee), in_block(lift(titlecase)))

    q(@Parallel (department = String, employee = [String]) [
        "POLICE"    ["GARRY M", "ANTHONY R", "DANA A"]
        "FIRE"      ["JOSE S", "CHARLES S"]])
    #-> @Parallel [String] [["Garry M", "Anthony R", "Dana A"], ["Jose S", "Charles S"]]

The empty chain `chain_of()` has an alias `pass()`.

    q = pass()
    #-> pass()

    q(["GARRY M", "ANTHONY R", "DANA A"])
    #-> ["GARRY M", "ANTHONY R", "DANA A"]

