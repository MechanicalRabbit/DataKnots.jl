<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Primer · DataKnots.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataKnots.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></li><li><span class="toctext">Concepts</span><ul><li class="current"><a class="toctext" href>Primer</a><ul class="internal"><li><a class="toctext" href="#The-Unit-Knot-1">The Unit Knot</a></li><li><a class="toctext" href="#Constant-Queries-1">Constant Queries</a></li><li><a class="toctext" href="#Composition-and-Identity-1">Composition &amp; Identity</a></li><li><a class="toctext" href="#Lifting-Functions-1">Lifting Functions</a></li><li><a class="toctext" href="#Aggregate-Queries-1">Aggregate Queries</a></li><li><a class="toctext" href="#Take-1">Take</a></li><li><a class="toctext" href="#Group-1">Group</a></li><li><a class="toctext" href="#Query-Parameters-1">Query Parameters</a></li><li><a class="toctext" href="#Julia-Integration-1">Julia Integration</a></li></ul></li><li><a class="toctext" href="../vectors/">Column Store</a></li><li><a class="toctext" href="../pipelines/">Pipeline Algebra</a></li><li><a class="toctext" href="../shapes/">Shapes and Signatures</a></li><li><a class="toctext" href="../knots/">Data Knots</a></li><li><a class="toctext" href="../queries/">Query Algebra</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Concepts</li><li><a href>Primer</a></li></ul><a class="edit-page" href="https://github.com/rbt-lang/DataKnots.jl/blob/master/doc/src/primer.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Primer</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Primer-1" href="#Primer-1">Primer</a></h1><p>DataKnots is a Julia library for building database queries. In DataKnots, queries are assembled algebraically: they either come from a set of atomic <em>primitives</em> or are built from other queries using <em>combinators</em>.</p><p>To start working with DataKnots, we import the package:</p><pre><code class="language-julia">using DataKnots</code></pre><h2><a class="nav-anchor" id="The-Unit-Knot-1" href="#The-Unit-Knot-1">The Unit Knot</a></h2><p>A <code>DataKnot</code>, or just <em>knot</em>, is a container for structured, vectorized data. The <code>unitknot</code> is a trivial knot used as the starting point for constructing other knots.</p><pre><code class="language-julia">unitknot
#=&gt;
┼──┼
│  │
=#</code></pre><p>The unit knot has a single value, an empty tuple. You could get the value of any knot using Julia&#39;s <code>get</code> function.</p><pre><code class="language-julia">get(unitknot)
#-&gt; ()</code></pre><h2><a class="nav-anchor" id="Constant-Queries-1" href="#Constant-Queries-1">Constant Queries</a></h2><p>Any Julia value could be converted to a <em>query</em> using the <code>Lift</code> constructor. Queries constructed this way are constant: for each input element they receive, they output the given value. Consider the query <code>Hello</code>, lifted from the string value <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">Hello = Lift(&quot;Hello World&quot;)</code></pre><p>To query <code>unitknot</code> with <code>Hello</code>, we use indexing notation <code>unitknot[Hello]</code>. In this case, <code>Hello</code> receives <code>nothing</code> from <code>unitknot</code> and produces the value, <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">unitknot[Hello]
#=&gt;
┼─────────────┼
│ Hello World │
=#</code></pre><p>A <code>Tuple</code> lifted to a constant query is displayed as a table.</p><pre><code class="language-julia">unitknot[Lift((name=&quot;DataKnots&quot;, version=&quot;0.1&quot;))]
#=&gt;
│ name       version │
┼────────────────────┼
│ DataKnots  0.1     │
=#</code></pre><p>A <code>missing</code> value lifted to a constant query produces no output.</p><pre><code class="language-julia">unitknot[Lift(missing)]
#=&gt;
(empty)
=#</code></pre><p>A <code>Vector</code> lifted to a constant query will produce plural output.</p><pre><code class="language-julia">unitknot[Lift(&#39;a&#39;:&#39;c&#39;)]
#=&gt;
──┼───┼
1 │ a │
2 │ b │
3 │ c │
=#</code></pre><p>We call queries constructed this way primitives, as they do not rely upon any other query. There are also combinators, which build new queries from existing ones.</p><h2><a class="nav-anchor" id="Composition-and-Identity-1" href="#Composition-and-Identity-1">Composition &amp; Identity</a></h2><p>Two queries can be connected sequentially using the <em>composition</em> combinator (<code>&gt;&gt;</code>). Consider the composition <code>Lift(1:3) &gt;&gt; Hello</code>. Since <code>Hello</code> produces a value for each input element, preceding it with <code>Lift(1:3)</code> generates three copies of <code>&quot;Hello World&quot;</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Hello]
#=&gt;
──┼─────────────┼
1 │ Hello World │
2 │ Hello World │
3 │ Hello World │
=#</code></pre><p>If we compose two plural queries, <code>Lift(1:2)</code> and <code>Lift(&#39;a&#39;:&#39;c&#39;)</code>, the output will contain the elements of <code>&#39;a&#39;:&#39;c&#39;</code> repeated twice.</p><pre><code class="language-julia">unitknot[Lift(1:2) &gt;&gt; Lift(&#39;a&#39;:&#39;c&#39;)]
#=&gt;
──┼───┼
1 │ a │
2 │ b │
3 │ c │
4 │ a │
5 │ b │
6 │ c │
=#</code></pre><p>The <em>identity</em> with respect to query composition is called <code>It</code>. This primitive can be composed with any query without changing the query&#39;s output.</p><pre><code class="language-julia">unitknot[Hello &gt;&gt; It]
#=&gt;
┼─────────────┼
│ Hello World │
=#</code></pre><p>The identity primitive, <code>It</code>, can be used to construct queries which rely upon the output from previous processing.</p><pre><code class="language-julia">Increment = It .+ 1
unitknot[Lift(1:3) &gt;&gt; Increment]
#=&gt;
──┼───┼
1 │ 2 │
2 │ 3 │
3 │ 4 │
=#</code></pre><p>In DataKnots, queries are built algebraically, starting with query primitives, such as constants (<code>Lift</code>) or the identity (<code>It</code>), and then arranged with with combinators, such as composition (<code>&gt;&gt;</code>). This lets us define sophisticated query components and remix them in creative ways.</p><h2><a class="nav-anchor" id="Lifting-Functions-1" href="#Lifting-Functions-1">Lifting Functions</a></h2><p>Any function could be used in a query. Consider the function <code>double(x)</code> that, when applied to a <code>Number</code>, produces a <code>Number</code>:</p><pre><code class="language-julia">double(x) = 2x
double(3) #-&gt; 6</code></pre><p>What we want is an analogue to <code>double</code> which, instead of operating on numbers, operates on queries. Such functions are called query combinators. We can convert any function to a combinator by passing the function and its arguments to <code>Lift</code>.</p><pre><code class="language-julia">Double(X) = Lift(double, (X,))</code></pre><p>For a given query <code>X</code>, the combinator <code>Double(X)</code> evaluates <code>X</code> and then runs each output element though the <code>double</code> function.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Double(It)]
#=&gt;
──┼───┼
1 │ 2 │
2 │ 4 │
3 │ 6 │
=#</code></pre><p>Alternatively, instead of <code>Lift</code> we could use broadcasting. For example, <code>double.(It)</code> is equivalent to <code>Lift(double, (It,))</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; double.(It)]
#=&gt;
──┼───┼
1 │ 2 │
2 │ 4 │
3 │ 6 │
=#</code></pre><p>Broadcasting also works with operators.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (It .+ 1)]
#=&gt;
──┼───┼
1 │ 2 │
2 │ 3 │
3 │ 4 │
=#</code></pre><p>Unary operators can be broadcast as well.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (√).(It)]
#=&gt;
──┼─────────┼
1 │ 1.0     │
2 │ 1.41421 │
3 │ 1.73205 │
=#</code></pre><p>Broadcasting could only be used when at least one argument is a query. For this reason, when defining a combinator, it is recommended to use <code>Lift</code> over broadcasting.</p><pre><code class="language-julia">Sqrt(X) = Lift(√, (X,))

unitknot[Sqrt(2)]
#=&gt;
┼─────────┼
│ 1.41421 │
=#</code></pre><p>Vector-valued functions give rise to plural queries. Here, the unit range constructor is lifted to a query combinator that builds plural queries.</p><pre><code class="language-julia">OneTo(X) = Lift(:, (1, X))

unitknot[OneTo(3)]
#=&gt;
──┼───┼
1 │ 1 │
2 │ 2 │
3 │ 3 │
=#</code></pre><p>Since later in this guide we&#39;ll want to enumerate the alphabet, let&#39;s define a combinator for that as well. In this definition, anonymous function syntax (<code>-&gt;</code>) is used to build an expression that is then lifted to queries.</p><pre><code class="language-julia">Chars(N) = Lift(n -&gt; &#39;a&#39;:&#39;a&#39;+n-1, (N,))

unitknot[Chars(3)]
#=&gt;
──┼───┼
1 │ a │
2 │ b │
3 │ c │
=#</code></pre><p>Lifting lets us use rich statistical and data processing functions from within our queries.</p><h2><a class="nav-anchor" id="Aggregate-Queries-1" href="#Aggregate-Queries-1">Aggregate Queries</a></h2><p>So far queries have been <em>elementwise</em>; that is, for each input element, they produce zero or more output elements. Consider the <code>Count</code> primitive; it returns the number of its input elements.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Count]
#=&gt;
┼───┼
│ 3 │
=#</code></pre><p>An <em>aggregate</em> query such as <code>Count</code> is computed over the input as a whole, and not for each individual element. The semantics of aggregates require discussion. Consider <code>Lift(1:3) &gt;&gt; OneTo(It)</code>.</p><pre><code class="language-julia">OneTo(X) = Lift(:, (1, X))

unitknot[Lift(1:3) &gt;&gt; OneTo(It)]
#=&gt;
──┼───┼
1 │ 1 │
2 │ 1 │
3 │ 2 │
4 │ 1 │
5 │ 2 │
6 │ 3 │
=#</code></pre><p>By appending <code>&gt;&gt; Sum</code> we could aggregate the entire input flow, producing a single output element.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; OneTo(It) &gt;&gt; Sum]
#=&gt;
┼────┼
│ 10 │
=#</code></pre><p>What if we wanted to produce sums by the outer query, <code>Lift(1:3)</code>? Since query composition (<code>&gt;&gt;</code>) is associative, adding parenthesis around <code>OneTo(It) &gt;&gt; Sum</code> will not change the result.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (OneTo(It) &gt;&gt; Sum)]
#=&gt;
┼────┼
│ 10 │
=#</code></pre><p>We could use <code>Record</code> to create this elementwise barrier. However, it introduces an intermediate, unwanted structure: we asked for sums, not a table with sums.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt;
         Record(:data =&gt; OneTo(It),
                :sum =&gt; OneTo(It) &gt;&gt; Sum)]
#=&gt;
  │ data     sum │
──┼──────────────┼
1 │ 1          1 │
2 │ 1; 2       3 │
3 │ 1; 2; 3    6 │
=#</code></pre><p>We need the <code>Each</code> combinator, which much the same as <code>Record</code>, acts as an elementwise barrier. For each input element, <code>Each</code> evaluates its argument, and then collects the outputs.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Each(OneTo(It) &gt;&gt; Sum)]
#=&gt;
──┼───┼
1 │ 1 │
2 │ 3 │
3 │ 6 │
=#</code></pre><p>Normally, one wouldn&#39;t need to use <code>Each</code> — for aggregates such as <code>Sum</code> or <code>Count</code>, the query <code>Y &gt;&gt; Each(X &gt;&gt; Count)</code> is equivalent to <code>Y &gt;&gt; Count(X)</code>. Hence, we could use the combinator form of <code>Sum</code> to do this relative summation.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Sum(OneTo(It))]
#=&gt;
──┼───┼
1 │ 1 │
2 │ 3 │
3 │ 6 │
=#</code></pre><p>Julia functions taking a vector argument, such as <code>mean</code>, can be lifted to a combinator taking a plural query. When performed, the plural output is converted into the function&#39;s vector argument.</p><pre><code class="language-julia">using Statistics
Mean(X) = mean.(X)

unitknot[Mean(Lift(1:3) &gt;&gt; Sum(OneTo(It)))]
#=&gt;
┼─────────┼
│ 3.33333 │
=#</code></pre><p>To use <code>Mean</code> as a query primitive, we use <code>Then</code> to build a query that aggregates elements from its input. Next, we register this query aggregate so it is used when <code>Mean</code> is treated as a query.</p><pre><code class="language-julia">DataKnots.Lift(::typeof(Mean)) = DataKnots.Then(Mean)</code></pre><p>Once these are done, one could take an average of sums as follows:</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Sum(OneTo(It)) &gt;&gt; Mean]
#=&gt;
┼─────────┼
│ 3.33333 │
=#</code></pre><p>In DataKnots, summary operations are expressed as aggregate query primitives or as query combinators taking a plural query argument. Moreover, custom aggregates can be constructed from native Julia functions and lifted into the query algebra.</p><h2><a class="nav-anchor" id="Take-1" href="#Take-1">Take</a></h2><p>Unlike <code>Filter</code> which evaluates its argument for each input element, the argument to <code>Take</code> is evaluated once, and in the context of the input&#39;s <em>source</em>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; Each(Lift(&#39;a&#39;:&#39;c&#39;) &gt;&gt; Take(It))]
#=&gt;
──┼───┼
1 │ a │
2 │ a │
3 │ b │
4 │ a │
5 │ b │
6 │ c │
=#</code></pre><p>In this example, the argument of <code>Take</code> evaluates in the context of <code>Lift(1:3)</code>. Therefore, <code>Take</code> will be performed three times, where <code>It</code> has the values <code>1</code>, <code>2</code>, and <code>3</code>.</p><h2><a class="nav-anchor" id="Group-1" href="#Group-1">Group</a></h2><p>Before we can demonstrate <code>Group</code>, we need an interesting dataset. Let&#39;s create a flat list of numbers with two characteristics.</p><pre><code class="language-julia">DataRow = :data=&gt; Record(:no =&gt; It,
                         :even =&gt; iseven.(It),
                         :char =&gt; Char.((It .+ 2) .% 3 .+ 97))
DataSet = Lift(1:9) &gt;&gt; DataRow

unitknot[DataSet]
#=&gt;
  │ data            │
  │ no  even   char │
──┼─────────────────┼
1 │  1  false  a    │
2 │  2   true  b    │
3 │  3  false  c    │
4 │  4   true  a    │
5 │  5  false  b    │
6 │  6   true  c    │
7 │  7  false  a    │
8 │  8   true  b    │
9 │  9  false  c    │
=#</code></pre><p>The <code>Group</code> combinator rearranges the dataset to bucket unique values of a particular expression together with its matching data.</p><pre><code class="language-julia">unitknot[DataSet &gt;&gt; Group(It.char)]
#=&gt;
  │ char  data{no,even,char}                   │
──┼────────────────────────────────────────────┼
1 │ a     1, false, a; 4, true, a; 7, false, a │
2 │ b     2, true, b; 5, false, b; 8, true, b  │
3 │ c     3, false, c; 6, true, c; 9, false, c │
=#</code></pre><p>With this rearrangement, we could summarize data with respect to the grouping expression.</p><pre><code class="language-julia">unitknot[DataSet &gt;&gt;
         Group(It.char) &gt;&gt;
         Record(It.char,
                It.data.no,
                :count =&gt; Count(It.data),
                :mean =&gt; mean.(It.data.no))]
#=&gt;
  │ char  no       count  mean │
──┼────────────────────────────┼
1 │ a     1; 4; 7      3   4.0 │
2 │ b     2; 5; 8      3   5.0 │
3 │ c     3; 6; 9      3   6.0 │
=#</code></pre><p>It&#39;s possible to group by more than one expression.</p><pre><code class="language-julia">unitknot[DataSet &gt;&gt;
         Group(It.even, It.char) &gt;&gt;
         Record(It.even, It.char, It.data.no)]
#=&gt;
  │ even   char  no   │
──┼───────────────────┼
1 │ false  a     1; 7 │
2 │ false  b     5    │
3 │ false  c     3; 9 │
4 │  true  a     4    │
5 │  true  b     2; 8 │
6 │  true  c     6    │
=#</code></pre><p>The <code>Group</code> combinator lets you adapt the structure of a dataset to form a hierarchy suitable to a particular analysis.</p><h2><a class="nav-anchor" id="Query-Parameters-1" href="#Query-Parameters-1">Query Parameters</a></h2><p>With DataKnots, parameters can be provided so that static data can be used within query expressions. By convention, we use upper case, singular labels for query parameters.</p><pre><code class="language-julia">unitknot[&quot;Hello &quot; .* Get(:WHO), WHO=&quot;World&quot;]
#=&gt;
┼─────────────┼
│ Hello World │
=#</code></pre><p>To make <code>Get</code> convenient, <code>It</code> provides a shorthand syntax.</p><pre><code class="language-julia">unitknot[&quot;Hello &quot; .* It.WHO, WHO=&quot;World&quot;]
#=&gt;
┼─────────────┼
│ Hello World │
=#</code></pre><p>Query parameters are available anywhere in the query. They could, for example be used within a filter.</p><pre><code class="language-julia">query = OneTo(6) &gt;&gt; Filter(It .&gt; It.START)

unitknot[query, START=3]
#=&gt;
──┼───┼
1 │ 4 │
2 │ 5 │
3 │ 6 │
=#</code></pre><p>Parameters can also be defined as part of a query using <code>Given</code>. This combinator takes set of pairs (<code>=&gt;</code>) that map symbols (<code>:name</code>) onto query expressions. The subsequent argument is then evaluated in a naming context where the defined parameters are available for reuse.</p><pre><code class="language-julia">unitknot[Given(:WHO =&gt; &quot;World&quot;, &quot;Hello &quot; .* Get(:WHO))]
#=&gt;
┼─────────────┼
│ Hello World │
=#</code></pre><p>Query parameters can be especially useful when managing aggregates, or with expressions that one may wish to repeat more than once.</p><pre><code class="language-julia">GreaterThanAverage(X) =
  Given(:AVG =&gt; Mean(X),
        X &gt;&gt; Filter(It .&gt; Get(:AVG)))

unitknot[GreaterThanAverage(OneTo(6))]
#=&gt;
──┼───┼
1 │ 4 │
2 │ 5 │
3 │ 6 │
=#</code></pre><p>With <code>Given</code> the parameter provided, <code>AVG</code> does not leak into the surrounding context.</p><pre><code class="language-julia">unitknot[GreaterThanAverage(OneTo(6)) &gt;&gt; It.AVG]
#-&gt; ERROR: cannot find &quot;AVG&quot; at ⋮</code></pre><p>In DataKnots, query parameters permit external data to be used within query expressions. Parameters that are defined with <code>Given</code> can be used to remember values and reuse them.</p><h2><a class="nav-anchor" id="Julia-Integration-1" href="#Julia-Integration-1">Julia Integration</a></h2><p>DataKnots is a query algebra embedded in the Julia programming language. We should discuss the interaction between the semantics of the query algebra and the semantics of Julia.</p><h3><a class="nav-anchor" id="Precedence-of-Composition-1" href="#Precedence-of-Composition-1">Precedence of Composition</a></h3><p>DataKnots uses Julia&#39;s bitshift operator (<code>&gt;&gt;</code>) for composition.</p><p>This works visually, but the <em>precedence</em> of this operator does not match user expectations. Specifically, common binary operators such as addition (<code>+</code>) have a lower precedence.</p><p>This expectation mismatch could lead a user to write:</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; It .+ It]
#-&gt; ERROR: cannot apply + to Tuple{Array{Int64,1},Tuple{}}⋮</code></pre><p>To fix this query, we add parentheses.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; (It .+ It)]
#=&gt;
──┼───┼
1 │ 2 │
2 │ 4 │
3 │ 6 │
=#</code></pre><h3><a class="nav-anchor" id="Composition-of-Queries-1" href="#Composition-of-Queries-1">Composition of Queries</a></h3><p>For bitshift operator (<code>&gt;&gt;</code>) to work as composition, the first operand must be a query.</p><pre><code class="language-julia">unitknot[1:3 &gt;&gt; &quot;Hello&quot;]
#-&gt; ERROR: MethodError: no method matching &gt;&gt;(::Int64, ::String)⋮</code></pre><p>To fix this query, we use <code>Lift</code> to convert the first operand to a query.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; &quot;Hello&quot;]
#=&gt;
──┼───────┼
1 │ Hello │
2 │ Hello │
3 │ Hello │
=#</code></pre><h3><a class="nav-anchor" id="Broadcasting-over-Queries-1" href="#Broadcasting-over-Queries-1">Broadcasting over Queries</a></h3><p>Broadcasting can be used to convert function calls into query expressions. For broadcasting to build a query, at least one argument must be a query.</p><p>Even when the argument isn&#39;t a query, the result often works as expected.</p><pre><code class="language-julia">unitknot[iseven.(2)]
#=&gt;
┼──────┼
│ true │
=#</code></pre><p>In this case, <code>iseven.(2)</code> is evaluated to the constant <code>true</code>, which is automatically lifted to a constant query.</p><p>For some functions this may lead to unexpected results. Suppose we need to generate 3 random characters.</p><pre><code class="language-julia">using Random: seed!, rand
seed!(1)
rand(&#39;a&#39;:&#39;z&#39;)
#-&gt; &#39;o&#39;</code></pre><p>We could try to make the following query.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; rand(&#39;a&#39;:&#39;z&#39;)]
#=&gt;
──┼───┼
1 │ c │
2 │ c │
3 │ c │
=#</code></pre><p>Unfortunately, the function <code>rand</code> evaluated once, which gives us the same value repeated 3 times. Let&#39;s try broadcasting.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; rand.(&#39;a&#39;:&#39;z&#39;)]
#-&gt; ERROR: ArgumentError: Sampler for this object is not defined⋮</code></pre><p>For broadcasting to generate a query, we need at least one argument to be a query. If we don&#39;t have a query argument, we could make one using <code>Lift</code>.</p><pre><code class="language-julia">unitknot[Lift(1:3) &gt;&gt; rand.(Lift(&#39;a&#39;:&#39;z&#39;))]
#=&gt;
──┼───┼
1 │ h │
2 │ b │
3 │ v │
=#</code></pre><footer><hr/><a class="previous" href="../reference/"><span class="direction">Previous</span><span class="title">Reference</span></a><a class="next" href="../vectors/"><span class="direction">Next</span><span class="title">Column Store</span></a></footer></article></body></html>
